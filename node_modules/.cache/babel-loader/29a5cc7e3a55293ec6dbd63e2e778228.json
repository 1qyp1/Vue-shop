{"ast":null,"code":"/*!\n * Vue.js v2.7.10\n * (c) 2014-2022 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\nrequire(\"core-js/modules/web.immediate.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst emptyObject = Object.freeze({});\nconst isArray = Array.isArray; // These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\n\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n/**\r\n * Check if value is primitive.\r\n */\n\n\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n  typeof value === 'symbol' || typeof value === 'boolean';\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\r\n * Quick object check - this is primarily used to tell\r\n * objects from primitive values when we know the value\r\n * is a JSON-compliant type.\r\n */\n\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n/**\r\n * Get the raw type string of a value, e.g., [object Object].\r\n */\n\n\nconst _toString = Object.prototype.toString;\n\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\n/**\r\n * Strict object type check. Only returns true\r\n * for plain JavaScript objects.\r\n */\n\n\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n/**\r\n * Check if val is a valid array index.\r\n */\n\n\nfunction isValidArrayIndex(val) {\n  const n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\n\nfunction isPromise(val) {\n  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n}\n/**\r\n * Convert a value to a string that is actually rendered.\r\n */\n\n\nfunction toString(val) {\n  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n}\n/**\r\n * Convert an input value to a number for persistence.\r\n * If the conversion fails, return original string.\r\n */\n\n\nfunction toNumber(val) {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n */\n\n\nfunction makeMap(str, expectsLowerCase) {\n  const map = Object.create(null);\n  const list = str.split(',');\n\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n\n  return expectsLowerCase ? val => map[val.toLowerCase()] : val => map[val];\n}\n/**\r\n * Check if a tag is a built-in tag.\r\n */\n\n\nconst isBuiltInTag = makeMap('slot,component', true);\n/**\r\n * Check if an attribute is a reserved attribute.\r\n */\n\nconst isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n/**\r\n * Remove an item from an array.\r\n */\n\nfunction remove$2(arr, item) {\n  if (arr.length) {\n    const index = arr.indexOf(item);\n\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n/**\r\n * Check whether an object has the property.\r\n */\n\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n/**\r\n * Create a cached version of a pure function.\r\n */\n\n\nfunction cached(fn) {\n  const cache = Object.create(null);\n  return function cachedFn(str) {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n/**\r\n * Camelize a hyphen-delimited string.\r\n */\n\n\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cached(str => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '');\n});\n/**\r\n * Capitalize a string.\r\n */\n\nconst capitalize = cached(str => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n/**\r\n * Hyphenate a camelCase string.\r\n */\n\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cached(str => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n/**\r\n * Simple bind polyfill for environments that do not support it,\r\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\r\n * since native bind is now performant enough in most browsers.\r\n * But removing it would mean breaking code that was able to run in\r\n * PhantomJS 1.x, so this must be kept for backward compatibility.\r\n */\n\n/* istanbul ignore next */\n\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    const l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n} // @ts-expect-error bind cannot be `undefined`\n\n\nconst bind = Function.prototype.bind ? nativeBind : polyfillBind;\n/**\r\n * Convert an Array-like object to a real Array.\r\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  let i = list.length - start;\n  const ret = new Array(i);\n\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n\n  return ret;\n}\n/**\r\n * Mix properties into target object.\r\n */\n\n\nfunction extend(to, _from) {\n  for (const key in _from) {\n    to[key] = _from[key];\n  }\n\n  return to;\n}\n/**\r\n * Merge an Array of Objects into a single Object.\r\n */\n\n\nfunction toObject(arr) {\n  const res = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n\n  return res;\n}\n/* eslint-disable no-unused-vars */\n\n/**\r\n * Perform no operation.\r\n * Stubbing args to make Flow happy without leaving useless transpiled code\r\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\r\n */\n\n\nfunction noop(a, b, c) {}\n/**\r\n * Always return false.\r\n */\n\n\nconst no = (a, b, c) => false;\n/* eslint-enable no-unused-vars */\n\n/**\r\n * Return the same value.\r\n */\n\n\nconst identity = _ => _;\n/**\r\n * Check if two values are loosely equal - that is,\r\n * if they are plain objects, do they have the same shape?\r\n */\n\n\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  const isObjectA = isObject(a);\n  const isObjectB = isObject(b);\n\n  if (isObjectA && isObjectB) {\n    try {\n      const isArrayA = Array.isArray(a);\n      const isArrayB = Array.isArray(b);\n\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every((e, i) => {\n          return looseEqual(e, b[i]);\n        });\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n      } else if (!isArrayA && !isArrayB) {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(key => {\n          return looseEqual(a[key], b[key]);\n        });\n      } else {\n        /* istanbul ignore next */\n        return false;\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n/**\r\n * Return the first index at which a loosely equal value can be\r\n * found in the array (if value is a plain object, the array must\r\n * contain an object of the same shape), or -1 if it is not present.\r\n */\n\n\nfunction looseIndexOf(arr, val) {\n  for (let i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) return i;\n  }\n\n  return -1;\n}\n/**\r\n * Ensure a function is called only once.\r\n */\n\n\nfunction once(fn) {\n  let called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill\n\n\nfunction hasChanged(x, y) {\n  if (x === y) {\n    return x === 0 && 1 / x !== 1 / y;\n  } else {\n    return x === x || y === y;\n  }\n}\n\nconst SSR_ATTR = 'data-server-rendered';\nconst ASSET_TYPES = ['component', 'directive', 'filter'];\nconst LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch', 'renderTracked', 'renderTriggered'];\nvar config = {\n  /**\r\n   * Option merge strategies (used in core/util/options)\r\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\r\n   * Whether to suppress warnings.\r\n   */\n  silent: false,\n\n  /**\r\n   * Show production mode tip message on boot?\r\n   */\n  productionTip: true,\n\n  /**\r\n   * Whether to enable devtools\r\n   */\n  devtools: true,\n\n  /**\r\n   * Whether to record perf\r\n   */\n  performance: false,\n\n  /**\r\n   * Error handler for watcher errors\r\n   */\n  errorHandler: null,\n\n  /**\r\n   * Warn handler for watcher warns\r\n   */\n  warnHandler: null,\n\n  /**\r\n   * Ignore certain custom elements\r\n   */\n  ignoredElements: [],\n\n  /**\r\n   * Custom user key aliases for v-on\r\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\r\n   * Check if a tag is reserved so that it cannot be registered as a\r\n   * component. This is platform-dependent and may be overwritten.\r\n   */\n  isReservedTag: no,\n\n  /**\r\n   * Check if an attribute is reserved so that it cannot be used as a component\r\n   * prop. This is platform-dependent and may be overwritten.\r\n   */\n  isReservedAttr: no,\n\n  /**\r\n   * Check if a tag is an unknown element.\r\n   * Platform-dependent.\r\n   */\n  isUnknownElement: no,\n\n  /**\r\n   * Get the namespace of an element\r\n   */\n  getTagNamespace: noop,\n\n  /**\r\n   * Parse the real tag name for the specific platform.\r\n   */\n  parsePlatformTagName: identity,\n\n  /**\r\n   * Check if an attribute must be bound using property, e.g. value\r\n   * Platform-dependent.\r\n   */\n  mustUseProp: no,\n\n  /**\r\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\r\n   * This will significantly reduce performance if set to false.\r\n   */\n  async: true,\n\n  /**\r\n   * Exposed for legacy reasons\r\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n/**\r\n * unicode letters used for parsing html tags, component names and property paths.\r\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\r\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\r\n */\n\nconst unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n/**\r\n * Check if a string starts with $ or _\r\n */\n\nfunction isReserved(str) {\n  const c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5f;\n}\n/**\r\n * Define a property.\r\n */\n\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n/**\r\n * Parse simple path.\r\n */\n\n\nconst bailRE = new RegExp(`[^${unicodeRegExp.source}.$_\\\\d]`);\n\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n\n  const segments = path.split('.');\n  return function (obj) {\n    for (let i = 0; i < segments.length; i++) {\n      if (!obj) return;\n      obj = obj[segments[i]];\n    }\n\n    return obj;\n  };\n} // can we use __proto__?\n\n\nconst hasProto = ('__proto__' in {}); // Browser environment sniffing\n\nconst inBrowser = typeof window !== 'undefined';\nconst UA = inBrowser && window.navigator.userAgent.toLowerCase();\nconst isIE = UA && /msie|trident/.test(UA);\nconst isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nconst isEdge = UA && UA.indexOf('edge/') > 0;\nUA && UA.indexOf('android') > 0;\nconst isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nUA && /chrome\\/\\d+/.test(UA) && !isEdge;\nUA && /phantomjs/.test(UA);\nconst isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n// @ts-expect-error firebox support\n\nconst nativeWatch = {}.watch;\nlet supportsPassive = false;\n\nif (inBrowser) {\n  try {\n    const opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n\n    }); // https://github.com/facebook/flow/issues/285\n\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n} // this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\n\n\nlet _isServer;\n\nconst isServerRendering = () => {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n\n  return _isServer;\n}; // detect devtools\n\n\nconst devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n/* istanbul ignore next */\n\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nconst hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nlet _Set; // $flow-disable-line\n\n/* istanbul ignore if */\n\n\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = class Set {\n    constructor() {\n      this.set = Object.create(null);\n    }\n\n    has(key) {\n      return this.set[key] === true;\n    }\n\n    add(key) {\n      this.set[key] = true;\n    }\n\n    clear() {\n      this.set = Object.create(null);\n    }\n\n  };\n}\n\nlet currentInstance = null;\n/**\r\n * This is exposed for compatibility with v3 (e.g. some functions in VueUse\r\n * relies on it). Do not use this internally, just use `currentInstance`.\r\n *\r\n * @internal this function needs manual type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\n\nfunction getCurrentInstance() {\n  return currentInstance && {\n    proxy: currentInstance\n  };\n}\n/**\r\n * @internal\r\n */\n\n\nfunction setCurrentInstance(vm = null) {\n  if (!vm) currentInstance && currentInstance._scope.off();\n  currentInstance = vm;\n  vm && vm._scope.on();\n}\n/**\r\n * @internal\r\n */\n\n\nclass VNode {\n  constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  } // DEPRECATED: alias for componentInstance for backwards compat.\n\n  /* istanbul ignore next */\n\n\n  get child() {\n    return this.componentInstance;\n  }\n\n}\n\nconst createEmptyVNode = (text = '') => {\n  const node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n} // optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\n\n\nfunction cloneVNode(vnode) {\n  const cloned = new VNode(vnode.tag, vnode.data, // #7975\n  // clone children array to avoid mutating original in case of cloning\n  // a child.\n  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned;\n}\n\nlet uid$2 = 0;\n/**\r\n * A dep is an observable that can have multiple\r\n * directives subscribing to it.\r\n * @internal\r\n */\n\nclass Dep {\n  constructor() {\n    this.id = uid$2++;\n    this.subs = [];\n  }\n\n  addSub(sub) {\n    this.subs.push(sub);\n  }\n\n  removeSub(sub) {\n    remove$2(this.subs, sub);\n  }\n\n  depend(info) {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n\n      if (info && Dep.target.onTrack) {\n        Dep.target.onTrack(Object.assign({\n          effect: Dep.target\n        }, info));\n      }\n    }\n  }\n\n  notify(info) {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice();\n\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort((a, b) => a.id - b.id);\n    }\n\n    for (let i = 0, l = subs.length; i < l; i++) {\n      if (info) {\n        const sub = subs[i];\n        sub.onTrigger && sub.onTrigger(Object.assign({\n          effect: subs[i]\n        }, info));\n      }\n\n      subs[i].update();\n    }\n  }\n\n} // The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\n\n\nDep.target = null;\nconst targetStack = [];\n\nfunction pushTarget(target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget() {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n/*\r\n * not type checking this file because flow doesn't play well with\r\n * dynamically accessing methods on Array prototype\r\n */\n\n\nconst arrayProto = Array.prototype;\nconst arrayMethods = Object.create(arrayProto);\nconst methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n/**\r\n * Intercept mutating methods and emit events\r\n */\n\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method];\n  def(arrayMethods, method, function mutator(...args) {\n    const result = original.apply(this, args);\n    const ob = this.__ob__;\n    let inserted;\n\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n\n    if (inserted) ob.observeArray(inserted); // notify change\n\n    {\n      ob.dep.notify({\n        type: \"array mutation\"\n        /* TriggerOpTypes.ARRAY_MUTATION */\n        ,\n        target: this,\n        key: method\n      });\n    }\n    return result;\n  });\n});\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods);\nconst NO_INIITIAL_VALUE = {};\n/**\r\n * In some cases we may want to disable observation inside a component's\r\n * update computation.\r\n */\n\nlet shouldObserve = true;\n\nfunction toggleObserving(value) {\n  shouldObserve = value;\n} // ssr mock dep\n\n\nconst mockDep = {\n  notify: noop,\n  depend: noop,\n  addSub: noop,\n  removeSub: noop\n};\n/**\r\n * Observer class that is attached to each observed\r\n * object. Once attached, the observer converts the target\r\n * object's property keys into getter/setters that\r\n * collect dependencies and dispatch updates.\r\n */\n\nclass Observer {\n  constructor(value, shallow = false, mock = false) {\n    this.value = value;\n    this.shallow = shallow;\n    this.mock = mock; // this.value = value\n\n    this.dep = mock ? mockDep : new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n\n    if (isArray(value)) {\n      if (!mock) {\n        if (hasProto) {\n          value.__proto__ = arrayMethods;\n          /* eslint-enable no-proto */\n        } else {\n          for (let i = 0, l = arrayKeys.length; i < l; i++) {\n            const key = arrayKeys[i];\n            def(value, key, arrayMethods[key]);\n          }\n        }\n      }\n\n      if (!shallow) {\n        this.observeArray(value);\n      }\n    } else {\n      /**\r\n       * Walk through all properties and convert them into\r\n       * getter/setters. This method should only be called when\r\n       * value type is Object.\r\n       */\n      const keys = Object.keys(value);\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);\n      }\n    }\n  }\n  /**\r\n   * Observe a list of Array items.\r\n   */\n\n\n  observeArray(value) {\n    for (let i = 0, l = value.length; i < l; i++) {\n      observe(value[i], false, this.mock);\n    }\n  }\n\n} // helpers\n\n/**\r\n * Attempt to create an observer instance for a value,\r\n * returns the new observer if successfully observed,\r\n * or the existing observer if the value already has one.\r\n */\n\n\nfunction observe(value, shallow, ssrMockReactivity) {\n  if (!isObject(value) || isRef(value) || value instanceof VNode) {\n    return;\n  }\n\n  let ob;\n\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldObserve && (ssrMockReactivity || !isServerRendering()) && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value.__v_skip\n  /* ReactiveFlags.SKIP */\n  ) {\n    ob = new Observer(value, shallow, ssrMockReactivity);\n  }\n\n  return ob;\n}\n/**\r\n * Define a reactive property on an Object.\r\n */\n\n\nfunction defineReactive(obj, key, val, customSetter, shallow, mock) {\n  const dep = new Dep();\n  const property = Object.getOwnPropertyDescriptor(obj, key);\n\n  if (property && property.configurable === false) {\n    return;\n  } // cater for pre-defined getter/setters\n\n\n  const getter = property && property.get;\n  const setter = property && property.set;\n\n  if ((!getter || setter) && (val === NO_INIITIAL_VALUE || arguments.length === 2)) {\n    val = obj[key];\n  }\n\n  let childOb = !shallow && observe(val, false, mock);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      const value = getter ? getter.call(obj) : val;\n\n      if (Dep.target) {\n        {\n          dep.depend({\n            target: obj,\n            type: \"get\"\n            /* TrackOpTypes.GET */\n            ,\n            key\n          });\n        }\n\n        if (childOb) {\n          childOb.dep.depend();\n\n          if (isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n\n      return isRef(value) && !shallow ? value.value : value;\n    },\n    set: function reactiveSetter(newVal) {\n      const value = getter ? getter.call(obj) : val;\n\n      if (!hasChanged(value, newVal)) {\n        return;\n      }\n\n      if (customSetter) {\n        customSetter();\n      }\n\n      if (setter) {\n        setter.call(obj, newVal);\n      } else if (getter) {\n        // #7981: for accessor properties without setter\n        return;\n      } else if (!shallow && isRef(value) && !isRef(newVal)) {\n        value.value = newVal;\n        return;\n      } else {\n        val = newVal;\n      }\n\n      childOb = !shallow && observe(newVal, false, mock);\n      {\n        dep.notify({\n          type: \"set\"\n          /* TriggerOpTypes.SET */\n          ,\n          target: obj,\n          key,\n          newValue: newVal,\n          oldValue: value\n        });\n      }\n    }\n  });\n  return dep;\n}\n\nfunction set(target, key, val) {\n  if (isUndef(target) || isPrimitive(target)) {\n    warn(`Cannot set reactive property on undefined, null, or primitive value: ${target}`);\n  }\n\n  if (isReadonly(target)) {\n    warn(`Set operation on key \"${key}\" failed: target is readonly.`);\n    return;\n  }\n\n  const ob = target.__ob__;\n\n  if (isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val); // when mocking for SSR, array methods are not hijacked\n\n    if (ob && !ob.shallow && ob.mock) {\n      observe(val, false, true);\n    }\n\n    return val;\n  }\n\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val;\n  }\n\n  if (target._isVue || ob && ob.vmCount) {\n    warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n\n  defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);\n  {\n    ob.dep.notify({\n      type: \"add\"\n      /* TriggerOpTypes.ADD */\n      ,\n      target: target,\n      key,\n      newValue: val,\n      oldValue: undefined\n    });\n  }\n  return val;\n}\n\nfunction del(target, key) {\n  if (isUndef(target) || isPrimitive(target)) {\n    warn(`Cannot delete reactive property on undefined, null, or primitive value: ${target}`);\n  }\n\n  if (isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return;\n  }\n\n  const ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n    warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n\n  if (isReadonly(target)) {\n    warn(`Delete operation on key \"${key}\" failed: target is readonly.`);\n    return;\n  }\n\n  if (!hasOwn(target, key)) {\n    return;\n  }\n\n  delete target[key];\n\n  if (!ob) {\n    return;\n  }\n\n  {\n    ob.dep.notify({\n      type: \"delete\"\n      /* TriggerOpTypes.DELETE */\n      ,\n      target: target,\n      key\n    });\n  }\n}\n/**\r\n * Collect dependencies on array elements when the array is touched, since\r\n * we cannot intercept array element access like property getters.\r\n */\n\n\nfunction dependArray(value) {\n  for (let e, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n\n    if (e && e.__ob__) {\n      e.__ob__.dep.depend();\n    }\n\n    if (isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\nfunction reactive(target) {\n  makeReactive(target, false);\n  return target;\n}\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\n\n\nfunction shallowReactive(target) {\n  makeReactive(target, true);\n  def(target, \"__v_isShallow\"\n  /* ReactiveFlags.IS_SHALLOW */\n  , true);\n  return target;\n}\n\nfunction makeReactive(target, shallow) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (!isReadonly(target)) {\n    {\n      if (isArray(target)) {\n        warn(`Avoid using Array as root value for ${shallow ? `shallowReactive()` : `reactive()`} as it cannot be tracked in watch() or watchEffect(). Use ${shallow ? `shallowRef()` : `ref()`} instead. This is a Vue-2-only limitation.`);\n      }\n\n      const existingOb = target && target.__ob__;\n\n      if (existingOb && existingOb.shallow !== shallow) {\n        warn(`Target is already a ${existingOb.shallow ? `` : `non-`}shallow reactive object, and cannot be converted to ${shallow ? `` : `non-`}shallow.`);\n      }\n    }\n    const ob = observe(target, shallow, isServerRendering()\n    /* ssr mock reactivity */\n    );\n\n    if (!ob) {\n      if (target == null || isPrimitive(target)) {\n        warn(`value cannot be made reactive: ${String(target)}`);\n      }\n\n      if (isCollectionType(target)) {\n        warn(`Vue 2 does not support reactive collection types such as Map or Set.`);\n      }\n    }\n  }\n}\n\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"\n    /* ReactiveFlags.RAW */\n    ]);\n  }\n\n  return !!(value && value.__ob__);\n}\n\nfunction isShallow(value) {\n  return !!(value && value.__v_isShallow);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value.__v_isReadonly);\n}\n\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"\n  /* ReactiveFlags.RAW */\n  ];\n  return raw ? toRaw(raw) : observed;\n}\n\nfunction markRaw(value) {\n  def(value, \"__v_skip\"\n  /* ReactiveFlags.SKIP */\n  , true);\n  return value;\n}\n/**\r\n * @internal\r\n */\n\n\nfunction isCollectionType(value) {\n  const type = toRawType(value);\n  return type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet';\n}\n/**\r\n * @internal\r\n */\n\n\nconst RefFlag = `__v_isRef`;\n\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\n\nfunction ref$1(value) {\n  return createRef(value, false);\n}\n\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\n\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n\n  const ref = {};\n  def(ref, RefFlag, true);\n  def(ref, \"__v_isShallow\"\n  /* ReactiveFlags.IS_SHALLOW */\n  , shallow);\n  def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));\n  return ref;\n}\n\nfunction triggerRef(ref) {\n  if (!ref.dep) {\n    warn(`received object is not a triggerable ref.`);\n  }\n\n  {\n    ref.dep && ref.dep.notify({\n      type: \"set\"\n      /* TriggerOpTypes.SET */\n      ,\n      target: ref,\n      key: 'value'\n    });\n  }\n}\n\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nfunction proxyRefs(objectWithRefs) {\n  if (isReactive(objectWithRefs)) {\n    return objectWithRefs;\n  }\n\n  const proxy = {};\n  const keys = Object.keys(objectWithRefs);\n\n  for (let i = 0; i < keys.length; i++) {\n    proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);\n  }\n\n  return proxy;\n}\n\nfunction proxyWithRefUnwrap(target, source, key) {\n  Object.defineProperty(target, key, {\n    enumerable: true,\n    configurable: true,\n    get: () => {\n      const val = source[key];\n\n      if (isRef(val)) {\n        return val.value;\n      } else {\n        const ob = val && val.__ob__;\n        if (ob) ob.dep.depend();\n        return val;\n      }\n    },\n    set: value => {\n      const oldValue = source[key];\n\n      if (isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n      } else {\n        source[key] = value;\n      }\n    }\n  });\n}\n\nfunction customRef(factory) {\n  const dep = new Dep();\n  const {\n    get,\n    set\n  } = factory(() => {\n    {\n      dep.depend({\n        target: ref,\n        type: \"get\"\n        /* TrackOpTypes.GET */\n        ,\n        key: 'value'\n      });\n    }\n  }, () => {\n    {\n      dep.notify({\n        target: ref,\n        type: \"set\"\n        /* TriggerOpTypes.SET */\n        ,\n        key: 'value'\n      });\n    }\n  });\n  const ref = {\n    get value() {\n      return get();\n    },\n\n    set value(newVal) {\n      set(newVal);\n    }\n\n  };\n  def(ref, RefFlag, true);\n  return ref;\n}\n\nfunction toRefs(object) {\n  if (!isReactive(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n\n  const ret = isArray(object) ? new Array(object.length) : {};\n\n  for (const key in object) {\n    ret[key] = toRef(object, key);\n  }\n\n  return ret;\n}\n\nfunction toRef(object, key, defaultValue) {\n  const val = object[key];\n\n  if (isRef(val)) {\n    return val;\n  }\n\n  const ref = {\n    get value() {\n      const val = object[key];\n      return val === undefined ? defaultValue : val;\n    },\n\n    set value(newVal) {\n      object[key] = newVal;\n    }\n\n  };\n  def(ref, RefFlag, true);\n  return ref;\n}\n\nconst rawToReadonlyFlag = `__v_rawToReadonly`;\nconst rawToShallowReadonlyFlag = `__v_rawToShallowReadonly`;\n\nfunction readonly(target) {\n  return createReadonly(target, false);\n}\n\nfunction createReadonly(target, shallow) {\n  if (!isPlainObject(target)) {\n    {\n      if (isArray(target)) {\n        warn(`Vue 2 does not support readonly arrays.`);\n      } else if (isCollectionType(target)) {\n        warn(`Vue 2 does not support readonly collection types such as Map or Set.`);\n      } else {\n        warn(`value cannot be made readonly: ${typeof target}`);\n      }\n    }\n    return target;\n  } // already a readonly object\n\n\n  if (isReadonly(target)) {\n    return target;\n  } // already has a readonly proxy\n\n\n  const existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;\n  const existingProxy = target[existingFlag];\n\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  const proxy = Object.create(Object.getPrototypeOf(target));\n  def(target, existingFlag, proxy);\n  def(proxy, \"__v_isReadonly\"\n  /* ReactiveFlags.IS_READONLY */\n  , true);\n  def(proxy, \"__v_raw\"\n  /* ReactiveFlags.RAW */\n  , target);\n\n  if (isRef(target)) {\n    def(proxy, RefFlag, true);\n  }\n\n  if (shallow || isShallow(target)) {\n    def(proxy, \"__v_isShallow\"\n    /* ReactiveFlags.IS_SHALLOW */\n    , true);\n  }\n\n  const keys = Object.keys(target);\n\n  for (let i = 0; i < keys.length; i++) {\n    defineReadonlyProperty(proxy, target, keys[i], shallow);\n  }\n\n  return proxy;\n}\n\nfunction defineReadonlyProperty(proxy, target, key, shallow) {\n  Object.defineProperty(proxy, key, {\n    enumerable: true,\n    configurable: true,\n\n    get() {\n      const val = target[key];\n      return shallow || !isPlainObject(val) ? val : readonly(val);\n    },\n\n    set() {\n      warn(`Set operation on key \"${key}\" failed: target is readonly.`);\n    }\n\n  });\n}\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\n\n\nfunction shallowReadonly(target) {\n  return createReadonly(target, true);\n}\n\nfunction computed(getterOrOptions, debugOptions) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n\n  if (onlyGetter) {\n    getter = getterOrOptions;\n\n    setter = () => {\n      warn('Write operation failed: computed value is readonly');\n    };\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  const watcher = isServerRendering() ? null : new Watcher(currentInstance, getter, noop, {\n    lazy: true\n  });\n\n  if (watcher && debugOptions) {\n    watcher.onTrack = debugOptions.onTrack;\n    watcher.onTrigger = debugOptions.onTrigger;\n  }\n\n  const ref = {\n    // some libs rely on the presence effect for checking computed refs\n    // from normal refs, but the implementation doesn't matter\n    effect: watcher,\n\n    get value() {\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n\n        if (Dep.target) {\n          if (Dep.target.onTrack) {\n            Dep.target.onTrack({\n              effect: Dep.target,\n              target: ref,\n              type: \"get\"\n              /* TrackOpTypes.GET */\n              ,\n              key: 'value'\n            });\n          }\n\n          watcher.depend();\n        }\n\n        return watcher.value;\n      } else {\n        return getter();\n      }\n    },\n\n    set value(newVal) {\n      setter(newVal);\n    }\n\n  };\n  def(ref, RefFlag, true);\n  def(ref, \"__v_isReadonly\"\n  /* ReactiveFlags.IS_READONLY */\n  , onlyGetter);\n  return ref;\n}\n\nconst WATCHER = `watcher`;\nconst WATCHER_CB = `${WATCHER} callback`;\nconst WATCHER_GETTER = `${WATCHER} getter`;\nconst WATCHER_CLEANUP = `${WATCHER} cleanup`; // Simple effect.\n\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\n\nfunction watchPostEffect(effect, options) {\n  return doWatch(effect, null, Object.assign(Object.assign({}, options), {\n    flush: 'post'\n  }));\n}\n\nfunction watchSyncEffect(effect, options) {\n  return doWatch(effect, null, Object.assign(Object.assign({}, options), {\n    flush: 'sync'\n  }));\n} // initial value for watchers to trigger on undefined initial values\n\n\nconst INITIAL_WATCHER_VALUE = {}; // implementation\n\nfunction watch(source, cb, options) {\n  if (typeof cb !== 'function') {\n    warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` + `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` + `supports \\`watch(source, cb, options?) signature.`);\n  }\n\n  return doWatch(source, cb, options);\n}\n\nfunction doWatch(source, cb, {\n  immediate,\n  deep,\n  flush = 'pre',\n  onTrack,\n  onTrigger\n} = emptyObject) {\n  if (!cb) {\n    if (immediate !== undefined) {\n      warn(`watch() \"immediate\" option is only respected when using the ` + `watch(source, callback, options?) signature.`);\n    }\n\n    if (deep !== undefined) {\n      warn(`watch() \"deep\" option is only respected when using the ` + `watch(source, callback, options?) signature.`);\n    }\n  }\n\n  const warnInvalidSource = s => {\n    warn(`Invalid watch source: ${s}. A watch source can only be a getter/effect ` + `function, a ref, a reactive object, or an array of these types.`);\n  };\n\n  const instance = currentInstance;\n\n  const call = (fn, type, args = null) => invokeWithErrorHandling(fn, null, args, instance, type);\n\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n\n  if (isRef(source)) {\n    getter = () => source.value;\n\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => {\n      source.__ob__.dep.depend();\n\n      return source;\n    };\n\n    deep = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s));\n\n    getter = () => source.map(s => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return traverse(s);\n      } else if (isFunction(s)) {\n        return call(s, WATCHER_GETTER);\n      } else {\n        warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () => call(source, WATCHER_GETTER);\n    } else {\n      // no cb -> simple effect\n      getter = () => {\n        if (instance && instance._isDestroyed) {\n          return;\n        }\n\n        if (cleanup) {\n          cleanup();\n        }\n\n        return call(source, WATCHER, [onCleanup]);\n      };\n    }\n  } else {\n    getter = noop;\n    warnInvalidSource(source);\n  }\n\n  if (cb && deep) {\n    const baseGetter = getter;\n\n    getter = () => traverse(baseGetter());\n  }\n\n  let cleanup;\n\n  let onCleanup = fn => {\n    cleanup = watcher.onStop = () => {\n      call(fn, WATCHER_CLEANUP);\n    };\n  }; // in SSR there is no need to setup an actual effect, and it should be noop\n  // unless it's eager\n\n\n  if (isServerRendering()) {\n    // we will also not call the invalidate callback (+ runner is not set up)\n    onCleanup = noop;\n\n    if (!cb) {\n      getter();\n    } else if (immediate) {\n      call(cb, WATCHER_CB, [getter(), isMultiSource ? [] : undefined, onCleanup]);\n    }\n\n    return noop;\n  }\n\n  const watcher = new Watcher(currentInstance, getter, noop, {\n    lazy: true\n  });\n  watcher.noRecurse = !cb;\n  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE; // overwrite default run\n\n  watcher.run = () => {\n    if (!watcher.active) {\n      return;\n    }\n\n    if (cb) {\n      // watch(source, cb)\n      const newValue = watcher.get();\n\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        // cleanup before running cb again\n        if (cleanup) {\n          cleanup();\n        }\n\n        call(cb, WATCHER_CB, [newValue, // pass undefined as the old value when it's changed for the first time\n        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onCleanup]);\n        oldValue = newValue;\n      }\n    } else {\n      // watchEffect\n      watcher.get();\n    }\n  };\n\n  if (flush === 'sync') {\n    watcher.update = watcher.run;\n  } else if (flush === 'post') {\n    watcher.post = true;\n\n    watcher.update = () => queueWatcher(watcher);\n  } else {\n    // pre\n    watcher.update = () => {\n      if (instance && instance === currentInstance && !instance._isMounted) {\n        // pre-watcher triggered before\n        const buffer = instance._preWatchers || (instance._preWatchers = []);\n        if (buffer.indexOf(watcher) < 0) buffer.push(watcher);\n      } else {\n        queueWatcher(watcher);\n      }\n    };\n  }\n\n  {\n    watcher.onTrack = onTrack;\n    watcher.onTrigger = onTrigger;\n  } // initial run\n\n  if (cb) {\n    if (immediate) {\n      watcher.run();\n    } else {\n      oldValue = watcher.get();\n    }\n  } else if (flush === 'post' && instance) {\n    instance.$once('hook:mounted', () => watcher.get());\n  } else {\n    watcher.get();\n  }\n\n  return () => {\n    watcher.teardown();\n  };\n}\n\nlet activeEffectScope;\n\nclass EffectScope {\n  constructor(detached = false) {\n    /**\r\n     * @internal\r\n     */\n    this.active = true;\n    /**\r\n     * @internal\r\n     */\n\n    this.effects = [];\n    /**\r\n     * @internal\r\n     */\n\n    this.cleanups = [];\n\n    if (!detached && activeEffectScope) {\n      this.parent = activeEffectScope;\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n\n  run(fn) {\n    if (this.active) {\n      const currentEffectScope = activeEffectScope;\n\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\n\n\n  on() {\n    activeEffectScope = this;\n  }\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\n\n\n  off() {\n    activeEffectScope = this.parent;\n  }\n\n  stop(fromParent) {\n    if (this.active) {\n      let i, l;\n\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].teardown();\n      }\n\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      } // nested scope, dereference from parent to avoid memory leaks\n\n\n      if (this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes.pop();\n\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n\n      this.active = false;\n    }\n  }\n\n}\n\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\n/**\r\n * @internal\r\n */\n\n\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\n\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\n\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else {\n    warn(`onScopeDispose() is called when there is no active effect scope` + ` to be associated with.`);\n  }\n}\n\nfunction provide(key, value) {\n  if (!currentInstance) {\n    {\n      warn(`provide() can only be used inside setup().`);\n    }\n  } else {\n    // TS doesn't allow symbol as index type\n    resolveProvided(currentInstance)[key] = value;\n  }\n}\n\nfunction resolveProvided(vm) {\n  // by default an instance inherits its parent's provides object\n  // but when it needs to provide values of its own, it creates its\n  // own provides object using parent provides object as prototype.\n  // this way in `inject` we can simply look up injections from direct\n  // parent and let the prototype chain do the work.\n  const existing = vm._provided;\n  const parentProvides = vm.$parent && vm.$parent._provided;\n\n  if (parentProvides === existing) {\n    return vm._provided = Object.create(parentProvides);\n  } else {\n    return existing;\n  }\n}\n\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n  // fallback to `currentRenderingInstance` so that this can be called in\n  // a functional component\n  const instance = currentInstance;\n\n  if (instance) {\n    // #2400\n    // to support `app.use` plugins,\n    // fallback to appContext's `provides` if the instance is at root\n    const provides = instance.$parent && instance.$parent._provided;\n\n    if (provides && key in provides) {\n      // TS doesn't allow symbol as index type\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance) : defaultValue;\n    } else {\n      warn(`injection \"${String(key)}\" not found.`);\n    }\n  } else {\n    warn(`inject() can only be used inside setup() or functional components.`);\n  }\n}\n\nconst normalizeEvent = cached(name => {\n  const passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  const once = name.charAt(0) === '~'; // Prefixed last, checked first\n\n  name = once ? name.slice(1) : name;\n  const capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name,\n    once,\n    capture,\n    passive\n  };\n});\n\nfunction createFnInvoker(fns, vm) {\n  function invoker() {\n    const fns = invoker.fns;\n\n    if (isArray(fns)) {\n      const cloned = fns.slice();\n\n      for (let i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`);\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, `v-on handler`);\n    }\n  }\n\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {\n  let name, cur, old, event;\n\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n\n    if (isUndef(cur)) {\n      warn(`Invalid handler for event \"${event.name}\": got ` + String(cur), vm);\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n\n  let invoker;\n  const oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n\n    remove$2(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  const propOptions = Ctor.options.props;\n\n  if (isUndef(propOptions)) {\n    return;\n  }\n\n  const res = {};\n  const {\n    attrs,\n    props\n  } = data;\n\n  if (isDef(attrs) || isDef(props)) {\n    for (const key in propOptions) {\n      const altKey = hyphenate(key);\n      {\n        const keyInLowerCase = key.toLowerCase();\n\n        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n          tip(`Prop \"${keyInLowerCase}\" is passed to component ` + `${formatComponentName( // @ts-expect-error tag is string\n          tag || Ctor)}, but the declared prop name is` + ` \"${key}\". ` + `Note that HTML attributes are case-insensitive and camelCased ` + `props need to use their kebab-case equivalents when using in-DOM ` + `templates. You should probably use \"${altKey}\" instead of \"${key}\".`);\n        }\n      }\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n\n      if (!preserve) {\n        delete hash[key];\n      }\n\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n\n      if (!preserve) {\n        delete hash[altKey];\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\n\n\nfunction simpleNormalizeChildren(children) {\n  for (let i = 0; i < children.length; i++) {\n    if (isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n\n  return children;\n} // 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\n\n\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  const res = [];\n  let i, c, lastIndex, last;\n\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') continue;\n    lastIndex = res.length - 1;\n    last = res[lastIndex]; //  nested\n\n    if (isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`); // merge adjacent text nodes\n\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + c[0].text);\n          c.shift();\n        }\n\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = `__vlist${nestedIndex}_${i}__`;\n        }\n\n        res.push(c);\n      }\n    }\n  }\n\n  return res;\n}\n/**\r\n * Runtime helper for rendering v-for lists.\r\n */\n\n\nfunction renderList(val, render) {\n  let ret = null,\n      i,\n      l,\n      keys,\n      key;\n\n  if (isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      const iterator = val[Symbol.iterator]();\n      let result = iterator.next();\n\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n\n  if (!isDef(ret)) {\n    ret = [];\n  }\n\n  ret._isVList = true;\n  return ret;\n}\n/**\r\n * Runtime helper for rendering <slot>\r\n */\n\n\nfunction renderSlot(name, fallbackRender, props, bindObject) {\n  const scopedSlotFn = this.$scopedSlots[name];\n  let nodes;\n\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n\n    if (bindObject) {\n      if (!isObject(bindObject)) {\n        warn('slot v-bind without argument expects an Object', this);\n      }\n\n      props = extend(extend({}, bindObject), props);\n    }\n\n    nodes = scopedSlotFn(props) || (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n  } else {\n    nodes = this.$slots[name] || (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n  }\n\n  const target = props && props.slot;\n\n  if (target) {\n    return this.$createElement('template', {\n      slot: target\n    }, nodes);\n  } else {\n    return nodes;\n  }\n}\n/**\r\n * Runtime helper for resolving filters\r\n */\n\n\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\nfunction isKeyNotMatch(expect, actual) {\n  if (isArray(expect)) {\n    return expect.indexOf(actual) === -1;\n  } else {\n    return expect !== actual;\n  }\n}\n/**\r\n * Runtime helper for checking keyCodes from config.\r\n * exposed as Vue.prototype._k\r\n * passing in eventKeyName as last argument separately for backwards compat\r\n */\n\n\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n  const mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName);\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key;\n  }\n\n  return eventKeyCode === undefined;\n}\n/**\r\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\r\n */\n\n\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n  if (value) {\n    if (!isObject(value)) {\n      warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (isArray(value)) {\n        value = toObject(value);\n      }\n\n      let hash;\n\n      for (const key in value) {\n        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n          hash = data;\n        } else {\n          const type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n\n        const camelizedKey = camelize(key);\n        const hyphenatedKey = hyphenate(key);\n\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            const on = data.on || (data.on = {});\n\n            on[`update:${key}`] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      }\n    }\n  }\n\n  return data;\n}\n/**\r\n * Runtime helper for rendering static trees.\r\n */\n\n\nfunction renderStatic(index, isInFor) {\n  const cached = this._staticTrees || (this._staticTrees = []);\n  let tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n\n  if (tree && !isInFor) {\n    return tree;\n  } // otherwise, render a fresh tree.\n\n\n  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates\n  );\n  markStatic(tree, `__static__${index}`, false);\n  return tree;\n}\n/**\r\n * Runtime helper for v-once.\r\n * Effectively it means marking the node as static with a unique key.\r\n */\n\n\nfunction markOnce(tree, index, key) {\n  markStatic(tree, `__once__${index}${key ? `_${key}` : ``}`, true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (isArray(tree)) {\n    for (let i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], `${key}_${i}`, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\nfunction bindObjectListeners(data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      warn('v-on without argument expects an Object value', this);\n    } else {\n      const on = data.on = data.on ? extend({}, data.on) : {};\n\n      for (const key in value) {\n        const existing = on[key];\n        const ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n\n  return data;\n}\n\nfunction resolveScopedSlots(fns, res, // the following are added in 2.6\nhasDynamicKeys, contentHashKey) {\n  res = res || {\n    $stable: !hasDynamicKeys\n  };\n\n  for (let i = 0; i < fns.length; i++) {\n    const slot = fns[i];\n\n    if (isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      // @ts-expect-error\n      if (slot.proxy) {\n        // @ts-expect-error\n        slot.fn.proxy = true;\n      }\n\n      res[slot.key] = slot.fn;\n    }\n  }\n\n  if (contentHashKey) {\n    res.$key = contentHashKey;\n  }\n\n  return res;\n} // helper to process dynamic keys for dynamic arguments in v-bind and v-on.\n\n\nfunction bindDynamicKeys(baseObj, values) {\n  for (let i = 0; i < values.length; i += 2) {\n    const key = values[i];\n\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (key !== '' && key !== null) {\n      // null is a special value for explicitly removing a binding\n      warn(`Invalid value for dynamic directive argument (expected string or null): ${key}`, this);\n    }\n  }\n\n  return baseObj;\n} // helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\n\n\nfunction prependModifier(value, symbol) {\n  return typeof value === 'string' ? symbol + value : value;\n}\n\nfunction installRenderHelpers(target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n/**\r\n * Runtime helper for resolving raw children VNodes into a slot object.\r\n */\n\n\nfunction resolveSlots(children, context) {\n  if (!children || !children.length) {\n    return {};\n  }\n\n  const slots = {};\n\n  for (let i = 0, l = children.length; i < l; i++) {\n    const child = children[i];\n    const data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    } // named slots should only be respected if the vnode was rendered in the\n    // same context.\n\n\n    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n      const name = data.slot;\n      const slot = slots[name] || (slots[name] = []);\n\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  } // ignore slots that contains only whitespace\n\n\n  for (const name in slots) {\n    if (slots[name].every(isWhitespace)) {\n      delete slots[name];\n    }\n  }\n\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment && !node.asyncFactory || node.text === ' ';\n}\n\nfunction isAsyncPlaceholder(node) {\n  // @ts-expect-error not really boolean type\n  return node.isComment && node.asyncFactory;\n}\n\nfunction normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {\n  let res;\n  const hasNormalSlots = Object.keys(normalSlots).length > 0;\n  const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;\n  const key = scopedSlots && scopedSlots.$key;\n\n  if (!scopedSlots) {\n    res = {};\n  } else if (scopedSlots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return scopedSlots._normalized;\n  } else if (isStable && prevScopedSlots && prevScopedSlots !== emptyObject && key === prevScopedSlots.$key && !hasNormalSlots && !prevScopedSlots.$hasNormal) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevScopedSlots;\n  } else {\n    res = {};\n\n    for (const key in scopedSlots) {\n      if (scopedSlots[key] && key[0] !== '$') {\n        res[key] = normalizeScopedSlot(ownerVm, normalSlots, key, scopedSlots[key]);\n      }\n    }\n  } // expose normal slots on scopedSlots\n\n\n  for (const key in normalSlots) {\n    if (!(key in res)) {\n      res[key] = proxyNormalSlot(normalSlots, key);\n    }\n  } // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n\n\n  if (scopedSlots && Object.isExtensible(scopedSlots)) {\n    scopedSlots._normalized = res;\n  }\n\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res;\n}\n\nfunction normalizeScopedSlot(vm, normalSlots, key, fn) {\n  const normalized = function () {\n    const cur = currentInstance;\n    setCurrentInstance(vm);\n    let res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !isArray(res) ? [res] // single vnode\n    : normalizeChildren(res);\n    const vnode = res && res[0];\n    setCurrentInstance(cur);\n    return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391\n    ? undefined : res;\n  }; // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n\n\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n\n  return normalized;\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return () => slots[key];\n}\n\nfunction initSetup(vm) {\n  const options = vm.$options;\n  const setup = options.setup;\n\n  if (setup) {\n    const ctx = vm._setupContext = createSetupContext(vm);\n    setCurrentInstance(vm);\n    pushTarget();\n    const setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, `setup`);\n    popTarget();\n    setCurrentInstance();\n\n    if (isFunction(setupResult)) {\n      // render function\n      // @ts-ignore\n      options.render = setupResult;\n    } else if (isObject(setupResult)) {\n      // bindings\n      if (setupResult instanceof VNode) {\n        warn(`setup() should not return VNodes directly - ` + `return a render function instead.`);\n      }\n\n      vm._setupState = setupResult; // __sfc indicates compiled bindings from <script setup>\n\n      if (!setupResult.__sfc) {\n        for (const key in setupResult) {\n          if (!isReserved(key)) {\n            proxyWithRefUnwrap(vm, setupResult, key);\n          } else {\n            warn(`Avoid using variables that start with _ or $ in setup().`);\n          }\n        }\n      } else {\n        // exposed for compiled render fn\n        const proxy = vm._setupProxy = {};\n\n        for (const key in setupResult) {\n          if (key !== '__sfc') {\n            proxyWithRefUnwrap(proxy, setupResult, key);\n          }\n        }\n      }\n    } else if (setupResult !== undefined) {\n      warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\n    }\n  }\n}\n\nfunction createSetupContext(vm) {\n  let exposeCalled = false;\n  return {\n    get attrs() {\n      if (!vm._attrsProxy) {\n        const proxy = vm._attrsProxy = {};\n        def(proxy, '_v_attr_proxy', true);\n        syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');\n      }\n\n      return vm._attrsProxy;\n    },\n\n    get listeners() {\n      if (!vm._listenersProxy) {\n        const proxy = vm._listenersProxy = {};\n        syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');\n      }\n\n      return vm._listenersProxy;\n    },\n\n    get slots() {\n      return initSlotsProxy(vm);\n    },\n\n    emit: bind(vm.$emit, vm),\n\n    expose(exposed) {\n      {\n        if (exposeCalled) {\n          warn(`expose() should be called only once per setup().`, vm);\n        }\n\n        exposeCalled = true;\n      }\n\n      if (exposed) {\n        Object.keys(exposed).forEach(key => proxyWithRefUnwrap(vm, exposed, key));\n      }\n    }\n\n  };\n}\n\nfunction syncSetupProxy(to, from, prev, instance, type) {\n  let changed = false;\n\n  for (const key in from) {\n    if (!(key in to)) {\n      changed = true;\n      defineProxyAttr(to, key, instance, type);\n    } else if (from[key] !== prev[key]) {\n      changed = true;\n    }\n  }\n\n  for (const key in to) {\n    if (!(key in from)) {\n      changed = true;\n      delete to[key];\n    }\n  }\n\n  return changed;\n}\n\nfunction defineProxyAttr(proxy, key, instance, type) {\n  Object.defineProperty(proxy, key, {\n    enumerable: true,\n    configurable: true,\n\n    get() {\n      return instance[type][key];\n    }\n\n  });\n}\n\nfunction initSlotsProxy(vm) {\n  if (!vm._slotsProxy) {\n    syncSetupSlots(vm._slotsProxy = {}, vm.$scopedSlots);\n  }\n\n  return vm._slotsProxy;\n}\n\nfunction syncSetupSlots(to, from) {\n  for (const key in from) {\n    to[key] = from[key];\n  }\n\n  for (const key in to) {\n    if (!(key in from)) {\n      delete to[key];\n    }\n  }\n}\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\n\n\nfunction useSlots() {\n  return getContext().slots;\n}\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\n\n\nfunction useAttrs() {\n  return getContext().attrs;\n}\n/**\r\n * Vue 2 only\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\n\n\nfunction useListeners() {\n  return getContext().listeners;\n}\n\nfunction getContext() {\n  if (!currentInstance) {\n    warn(`useContext() called without active instance.`);\n  }\n\n  const vm = currentInstance;\n  return vm._setupContext || (vm._setupContext = createSetupContext(vm));\n}\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\n\n\nfunction mergeDefaults(raw, defaults) {\n  const props = isArray(raw) ? raw.reduce((normalized, p) => (normalized[p] = {}, normalized), {}) : raw;\n\n  for (const key in defaults) {\n    const opt = props[key];\n\n    if (opt) {\n      if (isArray(opt) || isFunction(opt)) {\n        props[key] = {\n          type: opt,\n          default: defaults[key]\n        };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      props[key] = {\n        default: defaults[key]\n      };\n    } else {\n      warn(`props default key \"${key}\" has no corresponding declaration.`);\n    }\n  }\n\n  return props;\n}\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n\n  vm._staticTrees = null; // v-once cached trees\n\n  const options = vm.$options;\n  const parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n  const renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = parentVnode ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots) : emptyObject; // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  // @ts-expect-error\n\n  vm._c = (a, b, c, d) => createElement$1(vm, a, b, c, d, false); // normalization is always applied for the public version, used in\n  // user-written render functions.\n  // @ts-expect-error\n\n\n  vm.$createElement = (a, b, c, d) => createElement$1(vm, a, b, c, d, true); // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n\n\n  const parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n\n  {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, () => {\n      !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm);\n    }, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {\n      !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm);\n    }, true);\n  }\n}\n\nlet currentRenderingInstance = null;\n\nfunction renderMixin(Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    const vm = this;\n    const {\n      render,\n      _parentVnode\n    } = vm.$options;\n\n    if (_parentVnode && vm._isMounted) {\n      vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n\n      if (vm._slotsProxy) {\n        syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);\n      }\n    } // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n\n\n    vm.$vnode = _parentVnode; // render self\n\n    let vnode;\n\n    try {\n      // There's no need to maintain a stack because all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      setCurrentInstance(vm);\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, `render`); // return error render result,\n      // or previous vnode to prevent render error causing blank component\n\n      /* istanbul ignore else */\n\n      if (vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, `renderError`);\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n      setCurrentInstance();\n    } // if the returned array contains only a single node, allow it\n\n\n    if (isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    } // return empty vnode in case the render function errored out\n\n\n    if (!(vnode instanceof VNode)) {\n      if (isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n\n      vnode = createEmptyVNode();\n    } // set parent\n\n\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n}\n\nfunction ensureCtor(comp, base) {\n  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n    comp = comp.default;\n  }\n\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n  const node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = {\n    data,\n    context,\n    children,\n    tag\n  };\n  return node;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  const owner = currentRenderingInstance;\n\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    const owners = factory.owners = [owner];\n    let sync = true;\n    let timerLoading = null;\n    let timerTimeout = null;\n    owner.$on('hook:destroyed', () => remove$2(owners, owner));\n\n    const forceRender = renderCompleted => {\n      for (let i = 0, l = owners.length; i < l; i++) {\n        owners[i].$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    const resolve = once(res => {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n    const reject = once(reason => {\n      warn(`Failed to resolve async component: ${String(factory)}` + (reason ? `\\nReason: ${reason}` : ''));\n\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n    const res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            // @ts-expect-error NodeJS timeout type\n            timerLoading = setTimeout(() => {\n              timerLoading = null;\n\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          // @ts-expect-error NodeJS timeout type\n          timerTimeout = setTimeout(() => {\n            timerTimeout = null;\n\n            if (isUndef(factory.resolved)) {\n              reject(`timeout (${res.timeout}ms)`);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false; // return in case resolved synchronously\n\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n\nfunction getFirstComponentChild(children) {\n  if (isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const c = children[i];\n\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c;\n      }\n    }\n  }\n}\n\nconst SIMPLE_NORMALIZE = 1;\nconst ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n// without getting yelled at by flow\n\nfunction createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n    warn(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  } // object syntax in v-bind\n\n\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  } // warn against non-primitive key\n\n\n  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n  } // support single function children as default scoped slot\n\n\n  if (isArray(children) && isFunction(children[0])) {\n    data = data || {};\n    data.scopedSlots = {\n      default: children[0]\n    };\n    children.length = 0;\n  }\n\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n\n  let vnode, ns;\n\n  if (typeof tag === 'string') {\n    let Ctor;\n    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      if (isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {\n        warn(`The .native modifier for v-on is only valid on components but it was used on <${tag}>.`, context);\n      }\n\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n\n  if (isArray(vnode)) {\n    return vnode;\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) applyNS(vnode, ns);\n    if (isDef(data)) registerDeepBindings(data);\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns, force) {\n  vnode.ns = ns;\n\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n\n  if (isDef(vnode.children)) {\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const child = vnode.children[i];\n\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n} // ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\n\n\nfunction registerDeepBindings(data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n/**\r\n * @internal this function needs manual public type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\n\n\nfunction h(type, props, children) {\n  if (!currentInstance) {\n    warn(`globally imported h() can only be invoked when there is an active ` + `component instance, e.g. synchronously in a component's render or setup function.`);\n  }\n\n  return createElement$1(currentInstance, type, props, children, 2, true);\n}\n\nfunction handleError(err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n\n  try {\n    if (vm) {\n      let cur = vm;\n\n      while (cur = cur.$parent) {\n        const hooks = cur.$options.errorCaptured;\n\n        if (hooks) {\n          for (let i = 0; i < hooks.length; i++) {\n            try {\n              const capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) return;\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\n  let res;\n\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(e => handleError(e, vm, info + ` (Promise/async)`));\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n\n  return res;\n}\n\nfunction globalHandleError(err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info);\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n\n  logError(err, vm, info);\n}\n\nfunction logError(err, vm, info) {\n  {\n    warn(`Error in ${info}: \"${err.toString()}\"`, vm);\n  }\n  /* istanbul ignore else */\n\n  if (inBrowser && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err;\n  }\n}\n/* globals MutationObserver */\n\n\nlet isUsingMicroTask = false;\nconst callbacks = [];\nlet pending = false;\n\nfunction flushCallbacks() {\n  pending = false;\n  const copies = callbacks.slice(0);\n  callbacks.length = 0;\n\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n} // Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\n\n\nlet timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n\n/* istanbul ignore next, $flow-disable-line */\n\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve();\n\n  timerFunc = () => {\n    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n    if (isIOS) setTimeout(noop);\n  };\n\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\nMutationObserver.toString() === '[object MutationObserverConstructor]')) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  let counter = 1;\n  const observer = new MutationObserver(flushCallbacks);\n  const textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n\n  timerFunc = () => {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Technically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = () => {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n/**\r\n * @internal\r\n */\n\n\nfunction nextTick(cb, ctx) {\n  let _resolve;\n\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  } // $flow-disable-line\n\n\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve;\n    });\n  }\n}\n\nfunction useCssModule(name = '$style') {\n  /* istanbul ignore else */\n  {\n    if (!currentInstance) {\n      warn(`useCssModule must be called inside setup()`);\n      return emptyObject;\n    }\n\n    const mod = currentInstance[name];\n\n    if (!mod) {\n      warn(`Current instance does not have CSS module named \"${name}\".`);\n      return emptyObject;\n    }\n\n    return mod;\n  }\n}\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\n\n\nfunction useCssVars(getter) {\n  if (!inBrowser && !false) return;\n  const instance = currentInstance;\n\n  if (!instance) {\n    warn(`useCssVars is called without current active component instance.`);\n    return;\n  }\n\n  watchPostEffect(() => {\n    const el = instance.$el;\n    const vars = getter(instance, instance._setupProxy);\n\n    if (el && el.nodeType === 1) {\n      const style = el.style;\n\n      for (const key in vars) {\n        style.setProperty(`--${key}`, vars[key]);\n      }\n    }\n  });\n}\n/**\r\n * v3-compatible async component API.\r\n * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts\r\n * because it relies on existing manual types\r\n */\n\n\nfunction defineAsyncComponent(source) {\n  if (isFunction(source)) {\n    source = {\n      loader: source\n    };\n  }\n\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout,\n    // undefined = never times out\n    suspensible = false,\n    // in Vue 3 default is true\n    onError: userOnError\n  } = source;\n\n  if (suspensible) {\n    warn(`The suspensiblbe option for async components is not supported in Vue2. It is ignored.`);\n  }\n\n  let pendingRequest = null;\n  let retries = 0;\n\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {\n      err = err instanceof Error ? err : new Error(String(err));\n\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n\n          const userFail = () => reject(err);\n\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then(comp => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n\n      if (!comp) {\n        warn(`Async component loader resolved to undefined. ` + `If you are using retry(), make sure to return its return value.`);\n      } // interop module default\n\n\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\n        comp = comp.default;\n      }\n\n      if (comp && !isObject(comp) && !isFunction(comp)) {\n        throw new Error(`Invalid async component load result: ${comp}`);\n      }\n\n      return comp;\n    }));\n  };\n\n  return () => {\n    const component = load();\n    return {\n      component,\n      delay,\n      timeout,\n      error: errorComponent,\n      loading: loadingComponent\n    };\n  };\n}\n\nfunction createLifeCycle(hookName) {\n  return (fn, target = currentInstance) => {\n    if (!target) {\n      warn(`${formatName(hookName)} is called when there is no active component instance to be ` + `associated with. ` + `Lifecycle injection APIs can only be used during execution of setup().`);\n      return;\n    }\n\n    return injectHook(target, hookName, fn);\n  };\n}\n\nfunction formatName(name) {\n  if (name === 'beforeDestroy') {\n    name = 'beforeUnmount';\n  } else if (name === 'destroyed') {\n    name = 'unmounted';\n  }\n\n  return `on${name[0].toUpperCase() + name.slice(1)}`;\n}\n\nfunction injectHook(instance, hookName, fn) {\n  const options = instance.$options;\n  options[hookName] = mergeLifecycleHook(options[hookName], fn);\n}\n\nconst onBeforeMount = createLifeCycle('beforeMount');\nconst onMounted = createLifeCycle('mounted');\nconst onBeforeUpdate = createLifeCycle('beforeUpdate');\nconst onUpdated = createLifeCycle('updated');\nconst onBeforeUnmount = createLifeCycle('beforeDestroy');\nconst onUnmounted = createLifeCycle('destroyed');\nconst onActivated = createLifeCycle('activated');\nconst onDeactivated = createLifeCycle('deactivated');\nconst onServerPrefetch = createLifeCycle('serverPrefetch');\nconst onRenderTracked = createLifeCycle('renderTracked');\nconst onRenderTriggered = createLifeCycle('renderTriggered');\nconst injectErrorCapturedHook = createLifeCycle('errorCaptured');\n\nfunction onErrorCaptured(hook, target = currentInstance) {\n  injectErrorCapturedHook(hook, target);\n}\n/**\r\n * Note: also update dist/vue.runtime.mjs when adding new exports to this file.\r\n */\n\n\nconst version = '2.7.10';\n/**\r\n * @internal type is manually declared in <root>/types/v3-define-component.d.ts\r\n */\n\nfunction defineComponent(options) {\n  return options;\n}\n\nvar vca = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  version: version,\n  defineComponent: defineComponent,\n  ref: ref$1,\n  shallowRef: shallowRef,\n  isRef: isRef,\n  toRef: toRef,\n  toRefs: toRefs,\n  unref: unref,\n  proxyRefs: proxyRefs,\n  customRef: customRef,\n  triggerRef: triggerRef,\n  reactive: reactive,\n  isReactive: isReactive,\n  isReadonly: isReadonly,\n  isShallow: isShallow,\n  isProxy: isProxy,\n  shallowReactive: shallowReactive,\n  markRaw: markRaw,\n  toRaw: toRaw,\n  readonly: readonly,\n  shallowReadonly: shallowReadonly,\n  computed: computed,\n  watch: watch,\n  watchEffect: watchEffect,\n  watchPostEffect: watchPostEffect,\n  watchSyncEffect: watchSyncEffect,\n  EffectScope: EffectScope,\n  effectScope: effectScope,\n  onScopeDispose: onScopeDispose,\n  getCurrentScope: getCurrentScope,\n  provide: provide,\n  inject: inject,\n  h: h,\n  getCurrentInstance: getCurrentInstance,\n  useSlots: useSlots,\n  useAttrs: useAttrs,\n  useListeners: useListeners,\n  mergeDefaults: mergeDefaults,\n  nextTick: nextTick,\n  set: set,\n  del: del,\n  useCssModule: useCssModule,\n  useCssVars: useCssVars,\n  defineAsyncComponent: defineAsyncComponent,\n  onBeforeMount: onBeforeMount,\n  onMounted: onMounted,\n  onBeforeUpdate: onBeforeUpdate,\n  onUpdated: onUpdated,\n  onBeforeUnmount: onBeforeUnmount,\n  onUnmounted: onUnmounted,\n  onActivated: onActivated,\n  onDeactivated: onDeactivated,\n  onServerPrefetch: onServerPrefetch,\n  onRenderTracked: onRenderTracked,\n  onRenderTriggered: onRenderTriggered,\n  onErrorCaptured: onErrorCaptured\n});\nconst seenObjects = new _Set();\n/**\r\n * Recursively traverse an object to evoke all converted\r\n * getters, so that every nested property inside the object\r\n * is collected as a \"deep\" dependency.\r\n */\n\nfunction traverse(val) {\n  _traverse(val, seenObjects);\n\n  seenObjects.clear();\n  return val;\n}\n\nfunction _traverse(val, seen) {\n  let i, keys;\n  const isA = isArray(val);\n\n  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n    return;\n  }\n\n  if (val.__ob__) {\n    const depId = val.__ob__.dep.id;\n\n    if (seen.has(depId)) {\n      return;\n    }\n\n    seen.add(depId);\n  }\n\n  if (isA) {\n    i = val.length;\n\n    while (i--) _traverse(val[i], seen);\n  } else if (isRef(val)) {\n    _traverse(val.value, seen);\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n\n    while (i--) _traverse(val[keys[i]], seen);\n  }\n}\n\nlet uid$1 = 0;\n/**\r\n * A watcher parses an expression, collects dependencies,\r\n * and fires callback when the expression value changes.\r\n * This is used for both the $watch() api and directives.\r\n * @internal\r\n */\n\nclass Watcher {\n  constructor(vm, expOrFn, cb, options, isRenderWatcher) {\n    recordEffectScope(this, // if the active effect scope is manually created (not a component scope),\n    // prioritize it\n    activeEffectScope && !activeEffectScope._vm ? activeEffectScope : vm ? vm._scope : undefined);\n\n    if ((this.vm = vm) && isRenderWatcher) {\n      vm._watcher = this;\n    } // options\n\n\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n      {\n        this.onTrack = options.onTrack;\n        this.onTrigger = options.onTrigger;\n      }\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n\n    this.cb = cb;\n    this.id = ++uid$1; // uid for batching\n\n    this.active = true;\n    this.post = false;\n    this.dirty = this.lazy; // for lazy watchers\n\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString(); // parse expression for getter\n\n    if (isFunction(expOrFn)) {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n\n      if (!this.getter) {\n        this.getter = noop;\n        warn(`Failed watching path: \"${expOrFn}\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n\n    this.value = this.lazy ? undefined : this.get();\n  }\n  /**\r\n   * Evaluate the getter, and re-collect dependencies.\r\n   */\n\n\n  get() {\n    pushTarget(this);\n    let value;\n    const vm = this.vm;\n\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`);\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n\n      popTarget();\n      this.cleanupDeps();\n    }\n\n    return value;\n  }\n  /**\r\n   * Add a dependency to this directive.\r\n   */\n\n\n  addDep(dep) {\n    const id = dep.id;\n\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  }\n  /**\r\n   * Clean up for dependency collection.\r\n   */\n\n\n  cleanupDeps() {\n    let i = this.deps.length;\n\n    while (i--) {\n      const dep = this.deps[i];\n\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n\n    let tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  }\n  /**\r\n   * Subscriber interface.\r\n   * Will be called when a dependency changes.\r\n   */\n\n\n  update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  }\n  /**\r\n   * Scheduler job interface.\r\n   * Will be called by the scheduler.\r\n   */\n\n\n  run() {\n    if (this.active) {\n      const value = this.get();\n\n      if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        const oldValue = this.value;\n        this.value = value;\n\n        if (this.user) {\n          const info = `callback for watcher \"${this.expression}\"`;\n          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  }\n  /**\r\n   * Evaluate the value of the watcher.\r\n   * This only gets called for lazy watchers.\r\n   */\n\n\n  evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  }\n  /**\r\n   * Depend on all deps collected by this watcher.\r\n   */\n\n\n  depend() {\n    let i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].depend();\n    }\n  }\n  /**\r\n   * Remove self from all dependencies' subscriber list.\r\n   */\n\n\n  teardown() {\n    if (this.vm && !this.vm._isBeingDestroyed) {\n      remove$2(this.vm._scope.effects, this);\n    }\n\n    if (this.active) {\n      let i = this.deps.length;\n\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n\n      this.active = false;\n\n      if (this.onStop) {\n        this.onStop();\n      }\n    }\n  }\n\n}\n\nlet mark;\nlet measure;\n{\n  const perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n\n  if (perf && // @ts-ignore\n  perf.mark && // @ts-ignore\n  perf.measure && // @ts-ignore\n  perf.clearMarks && // @ts-ignore\n  perf.clearMeasures) {\n    mark = tag => perf.mark(tag);\n\n    measure = (name, startTag, endTag) => {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag); // perf.clearMeasures(name)\n    };\n  }\n}\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false; // init parent attached events\n\n  const listeners = vm.$options._parentListeners;\n\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nlet target$1;\n\nfunction add$1(event, fn) {\n  target$1.$on(event, fn);\n}\n\nfunction remove$1(event, fn) {\n  target$1.$off(event, fn);\n}\n\nfunction createOnceHandler$1(event, fn) {\n  const _target = target$1;\n  return function onceHandler() {\n    const res = fn.apply(null, arguments);\n\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  };\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target$1 = vm;\n  updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);\n  target$1 = undefined;\n}\n\nfunction eventsMixin(Vue) {\n  const hookRE = /^hook:/;\n\n  Vue.prototype.$on = function (event, fn) {\n    const vm = this;\n\n    if (isArray(event)) {\n      for (let i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    const vm = this;\n\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    const vm = this; // all\n\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    } // array of events\n\n\n    if (isArray(event)) {\n      for (let i = 0, l = event.length; i < l; i++) {\n        vm.$off(event[i], fn);\n      }\n\n      return vm;\n    } // specific event\n\n\n    const cbs = vm._events[event];\n\n    if (!cbs) {\n      return vm;\n    }\n\n    if (!fn) {\n      vm._events[event] = null;\n      return vm;\n    } // specific handler\n\n\n    let cb;\n    let i = cbs.length;\n\n    while (i--) {\n      cb = cbs[i];\n\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    const vm = this;\n    {\n      const lowerCaseEvent = event.toLowerCase();\n\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(`Event \"${lowerCaseEvent}\" is emitted in component ` + `${formatComponentName(vm)} but the handler is registered for \"${event}\". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`);\n      }\n    }\n    let cbs = vm._events[event];\n\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      const args = toArray(arguments, 1);\n      const info = `event handler for \"${event}\"`;\n\n      for (let i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n\n    return vm;\n  };\n}\n\nlet activeInstance = null;\nlet isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  const prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return () => {\n    activeInstance = prevActiveInstance;\n  };\n}\n\nfunction initLifecycle(vm) {\n  const options = vm.$options; // locate first non-abstract parent\n\n  let parent = options.parent;\n\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n  vm.$children = [];\n  vm.$refs = {};\n  vm._provided = parent ? parent._provided : Object.create(null);\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    const vm = this;\n    const prevEl = vm.$el;\n    const prevVnode = vm._vnode;\n    const restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n      /* removeOnly */\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n\n    restoreActiveInstance(); // update __vue__ reference\n\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    } // if parent is an HOC, update its $el as well\n\n\n    let wrapper = vm;\n\n    while (wrapper && wrapper.$vnode && wrapper.$parent && wrapper.$vnode === wrapper.$parent._vnode) {\n      wrapper.$parent.$el = wrapper.$el;\n      wrapper = wrapper.$parent;\n    } // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    const vm = this;\n\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    const vm = this;\n\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n\n    callHook$1(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true; // remove self from parent\n\n    const parent = vm.$parent;\n\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove$2(parent.$children, vm);\n    } // teardown scope. this includes both the render watcher and other\n    // watchers created\n\n\n    vm._scope.stop(); // remove reference from data ob\n    // frozen object may not have observer.\n\n\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    } // call the last hook...\n\n\n    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n    vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n    callHook$1(vm, 'destroyed'); // turn off all instance listeners.\n\n    vm.$off(); // remove __vue__ reference\n\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    } // release circular reference (#6759)\n\n\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n\n  if (!vm.$options.render) {\n    // @ts-expect-error invalid type\n    vm.$options.render = createEmptyVNode;\n    {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n\n  callHook$1(vm, 'beforeMount');\n  let updateComponent;\n  /* istanbul ignore if */\n\n  if (config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name;\n      const id = vm._uid;\n      const startTag = `vue-perf-start:${id}`;\n      const endTag = `vue-perf-end:${id}`;\n      mark(startTag);\n\n      const vnode = vm._render();\n\n      mark(endTag);\n      measure(`vue ${name} render`, startTag, endTag);\n      mark(startTag);\n\n      vm._update(vnode, hydrating);\n\n      mark(endTag);\n      measure(`vue ${name} patch`, startTag, endTag);\n    };\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  const watcherOptions = {\n    before() {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook$1(vm, 'beforeUpdate');\n      }\n    }\n\n  };\n  {\n    watcherOptions.onTrack = e => callHook$1(vm, 'renderTracked', [e]);\n\n    watcherOptions.onTrigger = e => callHook$1(vm, 'renderTriggered', [e]);\n  } // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n\n  new Watcher(vm, updateComponent, noop, watcherOptions, true\n  /* isRenderWatcher */\n  );\n  hydrating = false; // flush buffer for flush: \"pre\" watchers queued in setup()\n\n  const preWatchers = vm._preWatchers;\n\n  if (preWatchers) {\n    for (let i = 0; i < preWatchers.length; i++) {\n      preWatchers[i].run();\n    }\n  } // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n\n\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook$1(vm, 'mounted');\n  }\n\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  {\n    isUpdatingChildComponent = true;\n  } // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n\n  const newScopedSlots = parentVnode.data.scopedSlots;\n  const oldScopedSlots = vm.$scopedSlots;\n  const hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n\n  let needsForceUpdate = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  hasDynamicScopedSlot);\n  const prevVNode = vm.$vnode;\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n\n  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n\n  const attrs = parentVnode.data.attrs || emptyObject;\n\n  if (vm._attrsProxy) {\n    // force update if attrs are accessed and has changed since it may be\n    // passed to a child component.\n    if (syncSetupProxy(vm._attrsProxy, attrs, prevVNode.data && prevVNode.data.attrs || emptyObject, vm, '$attrs')) {\n      needsForceUpdate = true;\n    }\n  }\n\n  vm.$attrs = attrs; // update listeners\n\n  listeners = listeners || emptyObject;\n  const prevListeners = vm.$options._parentListeners;\n\n  if (vm._listenersProxy) {\n    syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');\n  }\n\n  vm.$listeners = vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, prevListeners); // update props\n\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    const props = vm._props;\n    const propKeys = vm.$options._propKeys || [];\n\n    for (let i = 0; i < propKeys.length; i++) {\n      const key = propKeys[i];\n      const propOptions = vm.$options.props; // wtf flow?\n\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n\n    toggleObserving(true); // keep a copy of raw propsData\n\n    vm.$options.propsData = propsData;\n  } // resolve slots + force update if has children\n\n\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) return true;\n  }\n\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n\n    for (let i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n\n    callHook$1(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n\n  if (!vm._inactive) {\n    vm._inactive = true;\n\n    for (let i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n\n    callHook$1(vm, 'deactivated');\n  }\n}\n\nfunction callHook$1(vm, hook, args, setContext = true) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  const prev = currentInstance;\n  setContext && setCurrentInstance(vm);\n  const handlers = vm.$options[hook];\n  const info = `${hook} hook`;\n\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);\n    }\n  }\n\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n\n  setContext && setCurrentInstance(prev);\n  popTarget();\n}\n\nconst MAX_UPDATE_COUNT = 100;\nconst queue = [];\nconst activatedChildren = [];\nlet has = {};\nlet circular = {};\nlet waiting = false;\nlet flushing = false;\nlet index = 0;\n/**\r\n * Reset the scheduler's state.\r\n */\n\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  {\n    circular = {};\n  }\n  waiting = flushing = false;\n} // Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\n\n\nlet currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\nlet getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\n\nif (inBrowser && !isIE) {\n  const performance = window.performance;\n\n  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = () => performance.now();\n  }\n}\n\nconst sortCompareFn = (a, b) => {\n  if (a.post) {\n    if (!b.post) return 1;\n  } else if (b.post) {\n    return -1;\n  }\n\n  return a.id - b.id;\n};\n/**\r\n * Flush both queues and run the watchers.\r\n */\n\n\nfunction flushSchedulerQueue() {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  let watcher, id; // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n\n  queue.sort(sortCompareFn); // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n\n    if (watcher.before) {\n      watcher.before();\n    }\n\n    id = watcher.id;\n    has[id] = null;\n    watcher.run(); // in dev build, check and stop circular updates.\n\n    if (has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn('You may have an infinite update loop ' + (watcher.user ? `in watcher with expression \"${watcher.expression}\"` : `in a component render function.`), watcher.vm);\n        break;\n      }\n    }\n  } // keep copies of post queues before resetting state\n\n\n  const activatedQueue = activatedChildren.slice();\n  const updatedQueue = queue.slice();\n  resetSchedulerState(); // call component updated and activated hooks\n\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue); // devtool hook\n\n  /* istanbul ignore if */\n\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks(queue) {\n  let i = queue.length;\n\n  while (i--) {\n    const watcher = queue[i];\n    const vm = watcher.vm;\n\n    if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook$1(vm, 'updated');\n    }\n  }\n}\n/**\r\n * Queue a kept-alive component that was activated during patch.\r\n * The queue will be processed after the entire tree has been patched.\r\n */\n\n\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true\n    /* true */\n    );\n  }\n}\n/**\r\n * Push a watcher into the watcher queue.\r\n * Jobs with duplicate IDs will be skipped unless it's\r\n * pushed when the queue is being flushed.\r\n */\n\n\nfunction queueWatcher(watcher) {\n  const id = watcher.id;\n\n  if (has[id] != null) {\n    return;\n  }\n\n  if (watcher === Dep.target && watcher.noRecurse) {\n    return;\n  }\n\n  has[id] = true;\n\n  if (!flushing) {\n    queue.push(watcher);\n  } else {\n    // if already flushing, splice the watcher based on its id\n    // if already past its id, it will be run next immediately.\n    let i = queue.length - 1;\n\n    while (i > index && queue[i].id > watcher.id) {\n      i--;\n    }\n\n    queue.splice(i + 1, 0, watcher);\n  } // queue the flush\n\n\n  if (!waiting) {\n    waiting = true;\n\n    if (!config.async) {\n      flushSchedulerQueue();\n      return;\n    }\n\n    nextTick(flushSchedulerQueue);\n  }\n}\n\nfunction initProvide(vm) {\n  const provideOption = vm.$options.provide;\n\n  if (provideOption) {\n    const provided = isFunction(provideOption) ? provideOption.call(vm) : provideOption;\n\n    if (!isObject(provided)) {\n      return;\n    }\n\n    const source = resolveProvided(vm); // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to\n    // iterate the keys ourselves.\n\n    const keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));\n    }\n  }\n}\n\nfunction initInjections(vm) {\n  const result = resolveInject(vm.$options.inject, vm);\n\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(key => {\n      /* istanbul ignore else */\n      {\n        defineReactive(vm, key, result[key], () => {\n          warn(`Avoid mutating an injected value directly since the changes will be ` + `overwritten whenever the provided component re-renders. ` + `injection being mutated: \"${key}\"`, vm);\n        });\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    const result = Object.create(null);\n    const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]; // #6574 in case the inject object is observed...\n\n      if (key === '__ob__') continue;\n      const provideKey = inject[key].from;\n\n      if (provideKey in vm._provided) {\n        result[key] = vm._provided[provideKey];\n      } else if ('default' in inject[key]) {\n        const provideDefault = inject[key].default;\n        result[key] = isFunction(provideDefault) ? provideDefault.call(vm) : provideDefault;\n      } else {\n        warn(`Injection \"${key}\" not found`, vm);\n      }\n    }\n\n    return result;\n  }\n}\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n  const options = Ctor.options; // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n\n  let contextVm;\n\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent; // @ts-ignore\n\n    parent = parent._original;\n  }\n\n  const isCompiled = isTrue(options._compiled);\n  const needNormalization = !isCompiled;\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n\n  this.slots = () => {\n    if (!this.$slots) {\n      normalizeScopedSlots(parent, data.scopedSlots, this.$slots = resolveSlots(children, parent));\n    }\n\n    return this.$slots;\n  };\n\n  Object.defineProperty(this, 'scopedSlots', {\n    enumerable: true,\n\n    get() {\n      return normalizeScopedSlots(parent, data.scopedSlots, this.slots());\n    }\n\n  }); // support for compiled functional template\n\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options; // pre-resolve slots for renderSlot()\n\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = (a, b, c, d) => {\n      const vnode = createElement$1(contextVm, a, b, c, d, needNormalization);\n\n      if (vnode && !isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n\n      return vnode;\n    };\n  } else {\n    this._c = (a, b, c, d) => createElement$1(contextVm, a, b, c, d, needNormalization);\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n  const options = Ctor.options;\n  const props = {};\n  const propOptions = options.props;\n\n  if (isDef(propOptions)) {\n    for (const key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) mergeProps(props, data.attrs);\n    if (isDef(data.props)) mergeProps(props, data.props);\n  }\n\n  const renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n  const vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n  } else if (isArray(vnode)) {\n    const vnodes = normalizeChildren(vnode) || [];\n    const res = new Array(vnodes.length);\n\n    for (let i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n\n    return res;\n  }\n}\n\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  const clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n\n  return clone;\n}\n\nfunction mergeProps(to, from) {\n  for (const key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\nfunction getComponentName(options) {\n  return options.name || options.__name || options._componentTag;\n} // inline hooks to be invoked on component VNodes during patch\n\n\nconst componentVNodeHooks = {\n  init(vnode, hydrating) {\n    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      const mountedNode = vnode; // work around flow\n\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      const child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch(oldVnode, vnode) {\n    const options = vnode.componentOptions;\n    const child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n\n  insert(vnode) {\n    const {\n      context,\n      componentInstance\n    } = vnode;\n\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook$1(componentInstance, 'mounted');\n    }\n\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  },\n\n  destroy(vnode) {\n    const {\n      componentInstance\n    } = vnode;\n\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  }\n\n};\nconst hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  const baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  } // if at this stage it's not a constructor or an async component factory,\n  // reject.\n\n\n  if (typeof Ctor !== 'function') {\n    {\n      warn(`Invalid Component definition: ${String(Ctor)}`, context);\n    }\n    return;\n  } // async component\n\n\n  let asyncFactory; // @ts-expect-error\n\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n    }\n  }\n\n  data = data || {}; // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n\n  resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n  if (isDef(data.model)) {\n    // @ts-expect-error\n    transformModel(Ctor.options, data);\n  } // extract props\n  // @ts-expect-error\n\n\n  const propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n  // @ts-expect-error\n\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  } // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n\n\n  const listeners = data.on; // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n\n  data.on = data.nativeOn; // @ts-expect-error\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n    // work around flow\n    const slot = data.slot;\n    data = {};\n\n    if (slot) {\n      data.slot = slot;\n    }\n  } // install component management hooks onto the placeholder node\n\n\n  installComponentHooks(data); // return a placeholder vnode\n  // @ts-expect-error\n\n  const name = getComponentName(Ctor.options) || tag;\n  const vnode = new VNode( // @ts-expect-error\n  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, // @ts-expect-error\n  {\n    Ctor,\n    propsData,\n    listeners,\n    tag,\n    children\n  }, asyncFactory);\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode( // we know it's MountedComponentVNode but flow doesn't\nvnode, // activeInstance in lifecycle state\nparent) {\n  const options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent\n  }; // check inline-template render functions\n\n  const inlineTemplate = vnode.data.inlineTemplate;\n\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n\n  return new vnode.componentOptions.Ctor(options);\n}\n\nfunction installComponentHooks(data) {\n  const hooks = data.hook || (data.hook = {});\n\n  for (let i = 0; i < hooksToMerge.length; i++) {\n    const key = hooksToMerge[i];\n    const existing = hooks[key];\n    const toMerge = componentVNodeHooks[key]; // @ts-expect-error\n\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook(f1, f2) {\n  const merged = (a, b) => {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n\n  merged._merged = true;\n  return merged;\n} // transform component v-model info (value and callback) into\n// prop and event handler respectively.\n\n\nfunction transformModel(options, data) {\n  const prop = options.model && options.model.prop || 'value';\n  const event = options.model && options.model.event || 'input';\n  (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  const on = data.on || (data.on = {});\n  const existing = on[event];\n  const callback = data.model.callback;\n\n  if (isDef(existing)) {\n    if (isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\nlet warn = noop;\nlet tip = noop;\nlet generateComponentTrace; // work around flow check\n\nlet formatComponentName;\n{\n  const hasConsole = typeof console !== 'undefined';\n  const classifyRE = /(?:^|[-_])(\\w)/g;\n\n  const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\n\n  warn = (msg, vm = currentInstance) => {\n    const trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && !config.silent) {\n      console.error(`[Vue warn]: ${msg}${trace}`);\n    }\n  };\n\n  tip = (msg, vm) => {\n    if (hasConsole && !config.silent) {\n      console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  formatComponentName = (vm, includeFile) => {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n\n    const options = isFunction(vm) && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n    let name = getComponentName(options);\n    const file = options.__file;\n\n    if (!name && file) {\n      const match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? `<${classify(name)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : '');\n  };\n\n  const repeat = (str, n) => {\n    let res = '';\n\n    while (n) {\n      if (n % 2 === 1) res += str;\n      if (n > 1) str += str;\n      n >>= 1;\n    }\n\n    return res;\n  };\n\n  generateComponentTrace = vm => {\n    if (vm._isVue && vm.$parent) {\n      const tree = [];\n      let currentRecursiveSequence = 0;\n\n      while (vm) {\n        if (tree.length > 0) {\n          const last = tree[tree.length - 1];\n\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue;\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n\n      return '\\n\\nfound in\\n\\n' + tree.map((vm, i) => `${i === 0 ? '---> ' : repeat(' ', 5 + i * 2)}${isArray(vm) ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)` : formatComponentName(vm)}`).join('\\n');\n    } else {\n      return `\\n\\n(found in ${formatComponentName(vm)})`;\n    }\n  };\n}\n/**\r\n * Option overwriting strategies are functions that handle\r\n * how to merge a parent option value and a child option\r\n * value into the final value.\r\n */\n\nconst strats = config.optionMergeStrategies;\n/**\r\n * Options with restrictions\r\n */\n\n{\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(`option \"${key}\" can only be used during instance ` + 'creation with the `new` keyword.');\n    }\n\n    return defaultStrat(parent, child);\n  };\n}\n/**\r\n * Helper that recursively merges two data objects together.\r\n */\n\nfunction mergeData(to, from) {\n  if (!from) return to;\n  let key, toVal, fromVal;\n  const keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n  for (let i = 0; i < keys.length; i++) {\n    key = keys[i]; // in case the object is already observed...\n\n    if (key === '__ob__') continue;\n    toVal = to[key];\n    fromVal = from[key];\n\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n\n  return to;\n}\n/**\r\n * Data\r\n */\n\n\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n\n    if (!parentVal) {\n      return childVal;\n    } // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n\n\n    return function mergedDataFn() {\n      return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);\n    };\n  } else {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      const instanceData = isFunction(childVal) ? childVal.call(vm, vm) : childVal;\n      const defaultData = isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal;\n\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n}\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n\n    return mergeDataOrFn(parentVal, childVal);\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm);\n};\n/**\r\n * Hooks and props are merged as arrays.\r\n */\n\n\nfunction mergeLifecycleHook(parentVal, childVal) {\n  const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n  return res ? dedupeHooks(res) : res;\n}\n\nfunction dedupeHooks(hooks) {\n  const res = [];\n\n  for (let i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n\n  return res;\n}\n\nLIFECYCLE_HOOKS.forEach(hook => {\n  strats[hook] = mergeLifecycleHook;\n});\n/**\r\n * Assets\r\n *\r\n * When a vm is present (instance creation), we need to do\r\n * a three-way merge between constructor options, instance\r\n * options and parent options.\r\n */\n\nfunction mergeAssets(parentVal, childVal, vm, key) {\n  const res = Object.create(parentVal || null);\n\n  if (childVal) {\n    assertObjectType(key, childVal, vm);\n    return extend(res, childVal);\n  } else {\n    return res;\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n/**\r\n * Watchers.\r\n *\r\n * Watchers hashes should not overwrite one\r\n * another, so we merge them as arrays.\r\n */\n\nstrats.watch = function (parentVal, childVal, vm, key) {\n  // work around Firefox's Object.prototype.watch...\n  //@ts-expect-error work around\n  if (parentVal === nativeWatch) parentVal = undefined; //@ts-expect-error work around\n\n  if (childVal === nativeWatch) childVal = undefined;\n  /* istanbul ignore if */\n\n  if (!childVal) return Object.create(parentVal || null);\n  {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) return childVal;\n  const ret = {};\n  extend(ret, parentVal);\n\n  for (const key in childVal) {\n    let parent = ret[key];\n    const child = childVal[key];\n\n    if (parent && !isArray(parent)) {\n      parent = [parent];\n    }\n\n    ret[key] = parent ? parent.concat(child) : isArray(child) ? child : [child];\n  }\n\n  return ret;\n};\n/**\r\n * Other object hashes.\r\n */\n\n\nstrats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n  if (childVal && true) {\n    assertObjectType(key, childVal, vm);\n  }\n\n  if (!parentVal) return childVal;\n  const ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) extend(ret, childVal);\n  return ret;\n};\n\nstrats.provide = mergeDataOrFn;\n/**\r\n * Default strategy.\r\n */\n\nconst defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n/**\r\n * Validate component names\r\n */\n\n\nfunction checkComponents(options) {\n  for (const key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName(name) {\n  if (!new RegExp(`^[a-zA-Z][\\\\-\\\\.0-9_${unicodeRegExp.source}]*$`).test(name)) {\n    warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n  }\n\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n  }\n}\n/**\r\n * Ensure all props option syntax are normalized into the\r\n * Object-based format.\r\n */\n\n\nfunction normalizeProps(options, vm) {\n  const props = options.props;\n  if (!props) return;\n  const res = {};\n  let i, val, name;\n\n  if (isArray(props)) {\n    i = props.length;\n\n    while (i--) {\n      val = props[i];\n\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = {\n          type: null\n        };\n      } else {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (const key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : {\n        type: val\n      };\n    }\n  } else {\n    warn(`Invalid value for option \"props\": expected an Array or an Object, ` + `but got ${toRawType(props)}.`, vm);\n  }\n\n  options.props = res;\n}\n/**\r\n * Normalize all injections into Object-based format\r\n */\n\n\nfunction normalizeInject(options, vm) {\n  const inject = options.inject;\n  if (!inject) return;\n  const normalized = options.inject = {};\n\n  if (isArray(inject)) {\n    for (let i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = {\n        from: inject[i]\n      };\n    }\n  } else if (isPlainObject(inject)) {\n    for (const key in inject) {\n      const val = inject[key];\n      normalized[key] = isPlainObject(val) ? extend({\n        from: key\n      }, val) : {\n        from: val\n      };\n    }\n  } else {\n    warn(`Invalid value for option \"inject\": expected an Array or an Object, ` + `but got ${toRawType(inject)}.`, vm);\n  }\n}\n/**\r\n * Normalize raw function directives into object format.\r\n */\n\n\nfunction normalizeDirectives$1(options) {\n  const dirs = options.directives;\n\n  if (dirs) {\n    for (const key in dirs) {\n      const def = dirs[key];\n\n      if (isFunction(def)) {\n        dirs[key] = {\n          bind: def,\n          update: def\n        };\n      }\n    }\n  }\n}\n\nfunction assertObjectType(name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(`Invalid value for option \"${name}\": expected an Object, ` + `but got ${toRawType(value)}.`, vm);\n  }\n}\n/**\r\n * Merge two option objects into a new one.\r\n * Core utility used in both instantiation and inheritance.\r\n */\n\n\nfunction mergeOptions(parent, child, vm) {\n  {\n    checkComponents(child);\n  }\n\n  if (isFunction(child)) {\n    // @ts-expect-error\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives$1(child); // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n      for (let i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  const options = {};\n  let key;\n\n  for (key in parent) {\n    mergeField(key);\n  }\n\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n\n  function mergeField(key) {\n    const strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n\n  return options;\n}\n/**\r\n * Resolve an asset.\r\n * This function is used because child instances need access\r\n * to assets defined in its ancestor chain.\r\n */\n\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n\n  const assets = options[type]; // check local registration variations first\n\n  if (hasOwn(assets, id)) return assets[id];\n  const camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) return assets[camelizedId];\n  const PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]; // fallback to prototype chain\n\n  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n  if (warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);\n  }\n\n  return res;\n}\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  const prop = propOptions[key];\n  const absent = !hasOwn(propsData, key);\n  let value = propsData[key]; // boolean casting\n\n  const booleanIndex = getTypeIndex(Boolean, prop.type);\n\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      const stringIndex = getTypeIndex(String, prop.type);\n\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  } // check default value\n\n\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n    // make sure to observe it.\n\n    const prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n\n  {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value;\n}\n/**\r\n * Get the default value of a prop.\r\n */\n\n\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n\n  const def = prop.default; // warn against non-factory defaults for Object & Array\n\n  if (isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  } // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n\n\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  } // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n\n\n  return isFunction(def) && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n/**\r\n * Assert whether a prop is valid.\r\n */\n\n\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n\n  if (value == null && !prop.required) {\n    return;\n  }\n\n  let type = prop.type;\n  let valid = !type || type === true;\n  const expectedTypes = [];\n\n  if (type) {\n    if (!isArray(type)) {\n      type = [type];\n    }\n\n    for (let i = 0; i < type.length && !valid; i++) {\n      const assertedType = assertType(value, type[i], vm);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  const haveExpectedTypes = expectedTypes.some(t => t);\n\n  if (!valid && haveExpectedTypes) {\n    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n    return;\n  }\n\n  const validator = prop.validator;\n\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nconst simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\n\nfunction assertType(value, type, vm) {\n  let valid;\n  const expectedType = getType(type);\n\n  if (simpleCheckRE.test(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = isArray(value);\n  } else {\n    try {\n      valid = value instanceof type;\n    } catch (e) {\n      warn('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\n      valid = false;\n    }\n  }\n\n  return {\n    valid,\n    expectedType\n  };\n}\n\nconst functionTypeCheckRE = /^\\s*function (\\w+)/;\n/**\r\n * Use function string name to check built-in types,\r\n * because a simple equality check will fail when running\r\n * across different vms / iframes.\r\n */\n\nfunction getType(fn) {\n  const match = fn && fn.toString().match(functionTypeCheckRE);\n  return match ? match[1] : '';\n}\n\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\n\nfunction getTypeIndex(type, expectedTypes) {\n  if (!isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n\n  for (let i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  let message = `Invalid prop: type check failed for prop \"${name}\".` + ` Expected ${expectedTypes.map(capitalize).join(', ')}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = toRawType(value); // check if we need to specify expected value\n\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${styleValue(value, expectedType)}`;\n  }\n\n  message += `, got ${receivedType} `; // check if we need to specify received value\n\n  if (isExplicable(receivedType)) {\n    message += `with value ${styleValue(value, receivedType)}.`;\n  }\n\n  return message;\n}\n\nfunction styleValue(value, type) {\n  if (type === 'String') {\n    return `\"${value}\"`;\n  } else if (type === 'Number') {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\n\nconst EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\n\nfunction isExplicable(value) {\n  return EXPLICABLE_TYPES.some(elem => value.toLowerCase() === elem);\n}\n\nfunction isBoolean(...args) {\n  return args.some(elem => elem.toLowerCase() === 'boolean');\n}\n/* not type checking this file because flow doesn't play well with Proxy */\n\n\nlet initProxy;\n{\n  const allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify\n  );\n\n  const warnNonPresent = (target, key) => {\n    warn(`Property or method \"${key}\" is not defined on the instance but ` + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n  };\n\n  const warnReservedPrefix = (target, key) => {\n    warn(`Property \"${key}\" must be accessed with \"$data.${key}\" because ` + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://v2.vuejs.org/v2/api/#data', target);\n  };\n\n  const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n\n    });\n  }\n\n  const hasHandler = {\n    has(target, key) {\n      const has = (key in target);\n      const isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n      if (!has && !isAllowed) {\n        if (key in target.$data) warnReservedPrefix(target, key);else warnNonPresent(target, key);\n      }\n\n      return has || !isAllowed;\n    }\n\n  };\n  const getHandler = {\n    get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) warnReservedPrefix(target, key);else warnNonPresent(target, key);\n      }\n\n      return target[key];\n    }\n\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      const options = vm.$options;\n      const handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\nconst sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  const opts = vm.$options;\n  if (opts.props) initProps$1(vm, opts.props); // Composition API\n\n  initSetup(vm);\n  if (opts.methods) initMethods(vm, opts.methods);\n\n  if (opts.data) {\n    initData(vm);\n  } else {\n    const ob = observe(vm._data = {});\n    ob && ob.vmCount++;\n  }\n\n  if (opts.computed) initComputed$1(vm, opts.computed);\n\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps$1(vm, propsOptions) {\n  const propsData = vm.$options.propsData || {};\n  const props = vm._props = shallowReactive({}); // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n\n  const keys = vm.$options._propKeys = [];\n  const isRoot = !vm.$parent; // root instance props should be converted\n\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n\n  for (const key in propsOptions) {\n    keys.push(key);\n    const value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n\n    {\n      const hyphenatedKey = hyphenate(key);\n\n      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n        warn(`\"${hyphenatedKey}\" is a reserved attribute and cannot be used as component prop.`, vm);\n      }\n\n      defineReactive(props, key, value, () => {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(`Avoid mutating a prop directly since the value will be ` + `overwritten whenever the parent component re-renders. ` + `Instead, use a data or computed property based on the prop's ` + `value. Prop being mutated: \"${key}\"`, vm);\n        }\n      });\n    } // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n\n    if (!(key in vm)) {\n      proxy(vm, `_props`, key);\n    }\n  }\n\n  toggleObserving(true);\n}\n\nfunction initData(vm) {\n  let data = vm.$options.data;\n  data = vm._data = isFunction(data) ? getData(data, vm) : data || {};\n\n  if (!isPlainObject(data)) {\n    data = {};\n    warn('data functions should return an object:\\n' + 'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  } // proxy data on instance\n\n\n  const keys = Object.keys(data);\n  const props = vm.$options.props;\n  const methods = vm.$options.methods;\n  let i = keys.length;\n\n  while (i--) {\n    const key = keys[i];\n    {\n      if (methods && hasOwn(methods, key)) {\n        warn(`Method \"${key}\" has already been defined as a data property.`, vm);\n      }\n    }\n\n    if (props && hasOwn(props, key)) {\n      warn(`The data property \"${key}\" is already declared as a prop. ` + `Use prop default value instead.`, vm);\n    } else if (!isReserved(key)) {\n      proxy(vm, `_data`, key);\n    }\n  } // observe data\n\n\n  const ob = observe(data);\n  ob && ob.vmCount++;\n}\n\nfunction getData(data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n\n  try {\n    return data.call(vm, vm);\n  } catch (e) {\n    handleError(e, vm, `data()`);\n    return {};\n  } finally {\n    popTarget();\n  }\n}\n\nconst computedWatcherOptions = {\n  lazy: true\n};\n\nfunction initComputed$1(vm, computed) {\n  // $flow-disable-line\n  const watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n  const isSSR = isServerRendering();\n\n  for (const key in computed) {\n    const userDef = computed[key];\n    const getter = isFunction(userDef) ? userDef : userDef.get;\n\n    if (getter == null) {\n      warn(`Getter is missing for computed property \"${key}\".`, vm);\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n    } // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n\n\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else {\n      if (key in vm.$data) {\n        warn(`The computed property \"${key}\" is already defined in data.`, vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm);\n      } else if (vm.$options.methods && key in vm.$options.methods) {\n        warn(`The computed property \"${key}\" is already defined as a method.`, vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  const shouldCache = !isServerRendering();\n\n  if (isFunction(userDef)) {\n    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n\n  if (sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(`Computed property \"${key}\" was assigned to but it has no setter.`, this);\n    };\n  }\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    const watcher = this._computedWatchers && this._computedWatchers[key];\n\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n\n      if (Dep.target) {\n        if (Dep.target.onTrack) {\n          Dep.target.onTrack({\n            effect: Dep.target,\n            target: this,\n            type: \"get\"\n            /* TrackOpTypes.GET */\n            ,\n            key\n          });\n        }\n\n        watcher.depend();\n      }\n\n      return watcher.value;\n    }\n  };\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter() {\n    return fn.call(this, this);\n  };\n}\n\nfunction initMethods(vm, methods) {\n  const props = vm.$options.props;\n\n  for (const key in methods) {\n    {\n      if (typeof methods[key] !== 'function') {\n        warn(`Method \"${key}\" has type \"${typeof methods[key]}\" in the component definition. ` + `Did you reference the function correctly?`, vm);\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(`Method \"${key}\" has already been defined as a prop.`, vm);\n      }\n\n      if (key in vm && isReserved(key)) {\n        warn(`Method \"${key}\" conflicts with an existing Vue instance method. ` + `Avoid defining component methods that start with _ or $.`);\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (const key in watch) {\n    const handler = watch[key];\n\n    if (isArray(handler)) {\n      for (let i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, expOrFn, handler, options) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n\n  return vm.$watch(expOrFn, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  const dataDef = {};\n\n  dataDef.get = function () {\n    return this._data;\n  };\n\n  const propsDef = {};\n\n  propsDef.get = function () {\n    return this._props;\n  };\n\n  {\n    dataDef.set = function () {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n\n    propsDef.set = function () {\n      warn(`$props is readonly.`, this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    const vm = this;\n\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options);\n    }\n\n    options = options || {};\n    options.user = true;\n    const watcher = new Watcher(vm, expOrFn, cb, options);\n\n    if (options.immediate) {\n      const info = `callback for immediate watcher \"${watcher.expression}\"`;\n      pushTarget();\n      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\n      popTarget();\n    }\n\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n\nlet uid = 0;\n\nfunction initMixin$1(Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this; // a uid\n\n    vm._uid = uid++;\n    let startTag, endTag;\n    /* istanbul ignore if */\n\n    if (config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`;\n      endTag = `vue-perf-end:${vm._uid}`;\n      mark(startTag);\n    } // a flag to mark this as a Vue instance without having to do instanceof\n    // check\n\n\n    vm._isVue = true; // avoid instances from being observed\n\n    vm.__v_skip = true; // effect scope\n\n    vm._scope = new EffectScope(true\n    /* detached */\n    );\n    vm._scope._vm = true; // merge options\n\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n\n\n    {\n      initProxy(vm);\n    } // expose real self\n\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook$1(vm, 'beforeCreate', undefined, false\n    /* setContext */\n    );\n    initInjections(vm); // resolve injections before data/props\n\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n\n    callHook$1(vm, 'created');\n    /* istanbul ignore if */\n\n    if (config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(`vue ${vm._name} init`, startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  const opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n  const parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  const vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  let options = Ctor.options;\n\n  if (Ctor.super) {\n    const superOptions = resolveConstructorOptions(Ctor.super);\n    const cachedSuperOptions = Ctor.superOptions;\n\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n      const modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  let modified;\n  const latest = Ctor.options;\n  const sealed = Ctor.sealedOptions;\n\n  for (const key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) modified = {};\n      modified[key] = latest[key];\n    }\n  }\n\n  return modified;\n}\n\nfunction Vue(options) {\n  if (!(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n\n  this._init(options);\n} //@ts-expect-error Vue has function type\n\n\ninitMixin$1(Vue); //@ts-expect-error Vue has function type\n\nstateMixin(Vue); //@ts-expect-error Vue has function type\n\neventsMixin(Vue); //@ts-expect-error Vue has function type\n\nlifecycleMixin(Vue); //@ts-expect-error Vue has function type\n\nrenderMixin(Vue);\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    const installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this;\n    } // additional parameters\n\n\n    const args = toArray(arguments, 1);\n    args.unshift(this);\n\n    if (isFunction(plugin.install)) {\n      plugin.install.apply(plugin, args);\n    } else if (isFunction(plugin)) {\n      plugin.apply(null, args);\n    }\n\n    installedPlugins.push(plugin);\n    return this;\n  };\n}\n\nfunction initMixin(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n\nfunction initExtend(Vue) {\n  /**\r\n   * Each instance constructor, including Vue, has a unique\r\n   * cid. This enables us to create wrapped \"child\r\n   * constructors\" for prototypal inheritance and cache them.\r\n   */\n  Vue.cid = 0;\n  let cid = 1;\n  /**\r\n   * Class inheritance\r\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    const Super = this;\n    const SuperId = Super.cid;\n    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    const name = getComponentName(extendOptions) || getComponentName(Super.options);\n\n    if (name) {\n      validateComponentName(name);\n    }\n\n    const Sub = function VueComponent(options) {\n      this._init(options);\n    };\n\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n\n    if (Sub.options.props) {\n      initProps(Sub);\n    }\n\n    if (Sub.options.computed) {\n      initComputed(Sub);\n    } // allow further extension/mixin/plugin usage\n\n\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use; // create asset registers, so extended classes\n    // can have their private assets too.\n\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    }); // enable recursive self-lookup\n\n    if (name) {\n      Sub.options.components[name] = Sub;\n    } // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n\n\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps(Comp) {\n  const props = Comp.options.props;\n\n  for (const key in props) {\n    proxy(Comp.prototype, `_props`, key);\n  }\n}\n\nfunction initComputed(Comp) {\n  const computed = Comp.options.computed;\n\n  for (const key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\nfunction initAssetRegisters(Vue) {\n  /**\r\n   * Create asset registration methods.\r\n   */\n  ASSET_TYPES.forEach(type => {\n    // @ts-expect-error function is not exact same type\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (type === 'component') {\n          validateComponentName(id);\n        }\n\n        if (type === 'component' && isPlainObject(definition)) {\n          // @ts-expect-error\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n\n        if (type === 'directive' && isFunction(definition)) {\n          definition = {\n            bind: definition,\n            update: definition\n          };\n        }\n\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n\nfunction _getComponentName(opts) {\n  return opts && (getComponentName(opts.Ctor.options) || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (isArray(pattern)) {\n    return pattern.indexOf(name) > -1;\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n\n\n  return false;\n}\n\nfunction pruneCache(keepAliveInstance, filter) {\n  const {\n    cache,\n    keys,\n    _vnode\n  } = keepAliveInstance;\n\n  for (const key in cache) {\n    const entry = cache[key];\n\n    if (entry) {\n      const name = entry.name;\n\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(cache, key, keys, current) {\n  const entry = cache[key];\n\n  if (entry && (!current || entry.tag !== current.tag)) {\n    // @ts-expect-error can be undefined\n    entry.componentInstance.$destroy();\n  }\n\n  cache[key] = null;\n  remove$2(keys, key);\n}\n\nconst patternTypes = [String, RegExp, Array]; // TODO defineComponent\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n  methods: {\n    cacheVNode() {\n      const {\n        cache,\n        keys,\n        vnodeToCache,\n        keyToCache\n      } = this;\n\n      if (vnodeToCache) {\n        const {\n          tag,\n          componentInstance,\n          componentOptions\n        } = vnodeToCache;\n        cache[keyToCache] = {\n          name: _getComponentName(componentOptions),\n          tag,\n          componentInstance\n        };\n        keys.push(keyToCache); // prune oldest entry\n\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n\n        this.vnodeToCache = null;\n      }\n    }\n\n  },\n\n  created() {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed() {\n    for (const key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted() {\n    this.cacheVNode();\n    this.$watch('include', val => {\n      pruneCache(this, name => matches(val, name));\n    });\n    this.$watch('exclude', val => {\n      pruneCache(this, name => !matches(val, name));\n    });\n  },\n\n  updated() {\n    this.cacheVNode();\n  },\n\n  render() {\n    const slot = this.$slots.default;\n    const vnode = getFirstComponentChild(slot);\n    const componentOptions = vnode && vnode.componentOptions;\n\n    if (componentOptions) {\n      // check pattern\n      const name = _getComponentName(componentOptions);\n\n      const {\n        include,\n        exclude\n      } = this;\n\n      if ( // not included\n      include && (!name || !matches(include, name)) || // excluded\n      exclude && name && matches(exclude, name)) {\n        return vnode;\n      }\n\n      const {\n        cache,\n        keys\n      } = this;\n      const key = vnode.key == null ? // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '') : vnode.key;\n\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n        remove$2(keys, key);\n        keys.push(key);\n      } else {\n        // delay setting the cache until update\n        this.vnodeToCache = vnode;\n        this.keyToCache = key;\n      } // @ts-expect-error can vnode.data can be undefined\n\n\n      vnode.data.keepAlive = true;\n    }\n\n    return vnode || slot && slot[0];\n  }\n\n};\nvar builtInComponents = {\n  KeepAlive\n};\n\nfunction initGlobalAPI(Vue) {\n  // config\n  const configDef = {};\n\n  configDef.get = () => config;\n\n  {\n    configDef.set = () => {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n\n  Vue.util = {\n    warn,\n    extend,\n    mergeOptions,\n    defineReactive\n  };\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n  Vue.observable = obj => {\n    observe(obj);\n    return obj;\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(type => {\n    Vue.options[type + 's'] = Object.create(null);\n  }); // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n\n  Vue.options._base = Vue;\n  extend(Vue.options.components, builtInComponents);\n  initUse(Vue);\n  initMixin(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get() {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext;\n  }\n\n}); // expose FunctionalRenderContext for ssr runtime helper installation\n\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\nVue.version = version; // these are reserved for web because they are directly compiled away\n// during template compilation\n\nconst isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\nconst acceptValue = makeMap('input,textarea,option,select,progress');\n\nconst mustUseProp = (tag, type, attr) => {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nconst isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\nconst isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nconst convertEnumeratedValue = (key, value) => {\n  return isFalsyAttrValue(value) || value === 'false' ? 'false' : // allow arbitrary string value for contenteditable\n  key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n};\n\nconst isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,' + 'truespeed,typemustmatch,visible');\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\n\nconst isXlink = name => {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nconst getXlinkProp = name => {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nconst isFalsyAttrValue = val => {\n  return val == null || val === false;\n};\n\nfunction genClassForVnode(vnode) {\n  let data = vnode.data;\n  let parentNode = vnode;\n  let childNode = vnode;\n\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  } // @ts-expect-error parentNode.parent not VNodeWithData\n\n\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n\n  return renderClass(data.staticClass, data.class);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction renderClass(staticClass, dynamicClass) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value);\n  }\n\n  if (isObject(value)) {\n    return stringifyObject(value);\n  }\n\n  if (typeof value === 'string') {\n    return value;\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction stringifyArray(value) {\n  let res = '';\n  let stringified;\n\n  for (let i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) res += ' ';\n      res += stringified;\n    }\n  }\n\n  return res;\n}\n\nfunction stringifyObject(value) {\n  let res = '';\n\n  for (const key in value) {\n    if (value[key]) {\n      if (res) res += ' ';\n      res += key;\n    }\n  }\n\n  return res;\n}\n\nconst namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\nconst isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\n\nconst isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nconst isReservedTag = tag => {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  } // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n\n\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nconst unknownElementCache = Object.create(null);\n\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n\n  if (isReservedTag(tag)) {\n    return false;\n  }\n\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n\n  const el = document.createElement(tag);\n\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\nconst isTextInputType = makeMap('text,number,password,search,email,tel,url');\n/**\r\n * Query an element selector if it's not an element already.\r\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    const selected = document.querySelector(el);\n\n    if (!selected) {\n      warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n\n    return selected;\n  } else {\n    return el;\n  }\n}\n\nfunction createElement(tagName, vnode) {\n  const elm = document.createElement(tagName);\n\n  if (tagName !== 'select') {\n    return elm;\n  } // false or null will remove the attribute but undefined will not\n\n\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope(node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createElement: createElement,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\nvar ref = {\n  create(_, vnode) {\n    registerRef(vnode);\n  },\n\n  update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n\n  destroy(vnode) {\n    registerRef(vnode, true);\n  }\n\n};\n\nfunction registerRef(vnode, isRemoval) {\n  const ref = vnode.data.ref;\n  if (!isDef(ref)) return;\n  const vm = vnode.context;\n  const refValue = vnode.componentInstance || vnode.elm;\n  const value = isRemoval ? null : refValue;\n  const $refsValue = isRemoval ? undefined : refValue;\n\n  if (isFunction(ref)) {\n    invokeWithErrorHandling(ref, vm, [value], vm, `template ref function`);\n    return;\n  }\n\n  const isFor = vnode.data.refInFor;\n\n  const _isString = typeof ref === 'string' || typeof ref === 'number';\n\n  const _isRef = isRef(ref);\n\n  const refs = vm.$refs;\n\n  if (_isString || _isRef) {\n    if (isFor) {\n      const existing = _isString ? refs[ref] : ref.value;\n\n      if (isRemoval) {\n        isArray(existing) && remove$2(existing, refValue);\n      } else {\n        if (!isArray(existing)) {\n          if (_isString) {\n            refs[ref] = [refValue];\n            setSetupRef(vm, ref, refs[ref]);\n          } else {\n            ref.value = [refValue];\n          }\n        } else if (!existing.includes(refValue)) {\n          existing.push(refValue);\n        }\n      }\n    } else if (_isString) {\n      if (isRemoval && refs[ref] !== refValue) {\n        return;\n      }\n\n      refs[ref] = $refsValue;\n      setSetupRef(vm, ref, value);\n    } else if (_isRef) {\n      if (isRemoval && ref.value !== refValue) {\n        return;\n      }\n\n      ref.value = value;\n    } else {\n      warn(`Invalid template ref type: ${typeof ref}`);\n    }\n  }\n}\n\nfunction setSetupRef({\n  _setupState\n}, key, val) {\n  if (_setupState && hasOwn(_setupState, key)) {\n    if (isRef(_setupState[key])) {\n      _setupState[key].value = val;\n    } else {\n      _setupState[key] = val;\n    }\n  }\n}\n/**\r\n * Virtual DOM patching algorithm based on Snabbdom by\r\n * Simon Friis Vindum (@paldepind)\r\n * Licensed under the MIT License\r\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\r\n *\r\n * modified by Evan You (@yyx990803)\r\n *\r\n * Not type-checking this because this file is perf-critical and the cost\r\n * of making flow understand it is not worth it.\r\n */\n\n\nconst emptyNode = new VNode('', {}, []);\nconst hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));\n}\n\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') return true;\n  let i;\n  const typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  const typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  let i, key;\n  const map = {};\n\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) map[key] = i;\n  }\n\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  let i, j;\n  const cbs = {};\n  const {\n    modules,\n    nodeOps\n  } = backend;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove() {\n      if (--remove.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n\n    remove.listeners = listeners;\n    return remove;\n  }\n\n  function removeNode(el) {\n    const parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement(vnode, inVPre) {\n    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(ignore => {\n      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n    })) && config.isUnknownElement(vnode.tag);\n  }\n\n  let creatingElmInVPre = 0;\n\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    const data = vnode.data;\n    const children = vnode.children;\n    const tag = vnode.tag;\n\n    if (isDef(tag)) {\n      {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n\n        if (isUnknownElement(vnode, creatingElmInVPre)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n      createChildren(vnode, children, insertedVnodeQueue);\n\n      if (isDef(data)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n      }\n\n      insert(parentElm, vnode.elm, refElm);\n\n      if (data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    let i = vnode.data;\n\n    if (isDef(i)) {\n      const isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false\n        /* hydrating */\n        );\n      } // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n\n\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n\n    vnode.elm = vnode.componentInstance.$el;\n\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode); // make sure to invoke the insert hook\n\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    let i; // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n\n    let innerNode = vnode;\n\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    } // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n\n\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (nodeOps.parentNode(ref) === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (isArray(children)) {\n      {\n        checkDuplicateKeys(children);\n      }\n\n      for (let i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (let i = 0; i < cbs.create.length; ++i) {\n      cbs.create[i](emptyNode, vnode);\n    }\n\n    i = vnode.data.hook; // Reuse variable\n\n    if (isDef(i)) {\n      if (isDef(i.create)) i.create(emptyNode, vnode);\n      if (isDef(i.insert)) insertedVnodeQueue.push(vnode);\n    }\n  } // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n\n\n  function setScope(vnode) {\n    let i;\n\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      let ancestor = vnode;\n\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n\n        ancestor = ancestor.parent;\n      }\n    } // for slot content they should also get the scopeId from the host instance.\n\n\n    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    let i, j;\n    const data = vnode.data;\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);\n\n      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);\n    }\n\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      const ch = vnodes[startIdx];\n\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      let i;\n      const listeners = cbs.remove.length + 1;\n\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } // recursively invoke hooks on child component root node\n\n\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n\n    const canMove = !removeOnly;\n    {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys(children) {\n    const seenKeys = {};\n\n    for (let i = 0; i < children.length; i++) {\n      const vnode = children[i];\n      const key = vnode.key;\n\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(`Duplicate keys detected: '${key}'. This may cause an update error.`, vnode.context);\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld(node, oldCh, start, end) {\n    for (let i = start; i < end; i++) {\n      const c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) return i;\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    const elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n\n      return;\n    } // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n\n    let i;\n    const data = vnode.data;\n\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    const oldCh = oldVnode.children;\n    const ch = vnode.children;\n\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);\n\n      if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode);\n    }\n\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n      } else if (isDef(ch)) {\n        {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '');\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode);\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (let i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  let hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n\n  const isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n    let i;\n    const {\n      tag,\n      data,\n      children\n    } = vnode;\n    inVPre = inVPre || data && data.pre;\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true;\n    } // assert node match\n\n\n    {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false;\n      }\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode, true\n      /* hydrating */\n      );\n\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n\n              return false;\n            }\n          } else {\n            // iterate and compare children lists\n            let childrenMatch = true;\n            let childNode = elm.firstChild;\n\n            for (let i = 0; i < children.length; i++) {\n              if (!childNode || !hydrate(childNode, children[i], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break;\n              }\n\n              childNode = childNode.nextSibling;\n            } // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n\n\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n\n              return false;\n            }\n          }\n        }\n      }\n\n      if (isDef(data)) {\n        let fullInvoke = false;\n\n        for (const key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) invokeDestroyHook(oldVnode);\n      return;\n    }\n\n    let isInitialPatch = false;\n    const insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      const isRealElement = isDef(oldVnode.nodeType);\n\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          } // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n\n\n          oldVnode = emptyNodeAt(oldVnode);\n        } // replacing existing element\n\n\n        const oldElm = oldVnode.elm;\n        const parentElm = nodeOps.parentNode(oldElm); // create new node\n\n        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n        if (isDef(vnode.parent)) {\n          let ancestor = vnode.parent;\n          const patchable = isPatchable(vnode);\n\n          while (ancestor) {\n            for (let i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n\n            ancestor.elm = vnode.elm;\n\n            if (patchable) {\n              for (let i = 0; i < cbs.create.length; ++i) {\n                cbs.create[i](emptyNode, ancestor);\n              } // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n\n\n              const insert = ancestor.data.hook.insert;\n\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (let i = 1; i < insert.fns.length; i++) {\n                  insert.fns[i]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n\n            ancestor = ancestor.parent;\n          }\n        } // destroy old node\n\n\n        if (isDef(parentElm)) {\n          removeVnodes([oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    // @ts-expect-error emptyNode is not VNodeWithData\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  const isCreate = oldVnode === emptyNode;\n  const isDestroy = vnode === emptyNode;\n  const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);\n  const newDirs = normalizeDirectives(vnode.data.directives, vnode.context);\n  const dirsWithInsert = [];\n  const dirsWithPostpatch = [];\n  let key, oldDir, dir;\n\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n\n    if (!oldDir) {\n      // new directive, bind\n      callHook(dir, 'bind', vnode, oldVnode);\n\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook(dir, 'update', vnode, oldVnode);\n\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    const callInsert = () => {\n      for (let i = 0; i < dirsWithInsert.length; i++) {\n        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', () => {\n      for (let i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nconst emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives(dirs, vm) {\n  const res = Object.create(null);\n\n  if (!dirs) {\n    // $flow-disable-line\n    return res;\n  }\n\n  let i, dir;\n\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n\n    res[getRawDirName(dir)] = dir;\n\n    if (vm._setupState && vm._setupState.__sfc) {\n      const setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);\n\n      if (typeof setupDef === 'function') {\n        dir.def = {\n          bind: setupDef,\n          update: setupDef\n        };\n      } else {\n        dir.def = setupDef;\n      }\n    }\n\n    dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);\n  } // $flow-disable-line\n\n\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join('.')}`;\n}\n\nfunction callHook(dir, hook, vnode, oldVnode, isDestroy) {\n  const fn = dir.def && dir.def[hook];\n\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, `directive ${dir.name} ${hook} hook`);\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n\nfunction updateAttrs(oldVnode, vnode) {\n  const opts = vnode.componentOptions;\n\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return;\n  }\n\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n\n  let key, cur, old;\n  const elm = vnode.elm;\n  const oldAttrs = oldVnode.data.attrs || {};\n  let attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n\n    if (old !== cur) {\n      setAttr(elm, key, cur, vnode.data.pre);\n    }\n  } // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n  /* istanbul ignore if */\n\n\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value, isInPre) {\n  if (isInPre || el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr(el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n\n    /* istanbul ignore if */\n    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n      const blocker = e => {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n\n      el.addEventListener('input', blocker); // $flow-disable-line\n\n      el.__ieph = true;\n      /* IE placeholder patched */\n    }\n\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\nfunction updateClass(oldVnode, vnode) {\n  const el = vnode.elm;\n  const data = vnode.data;\n  const oldData = oldVnode.data;\n\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  let cls = genClassForVnode(vnode); // handle transition classes\n\n  const transitionClass = el._transitionClasses;\n\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  } // set the class\n\n\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n}; // in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\n\nconst RANGE_TOKEN = '__r';\nconst CHECKBOX_RADIO_TOKEN = '__c'; // normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\n\nfunction normalizeEvents(on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    const event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  } // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n  /* istanbul ignore if */\n\n\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nlet target;\n\nfunction createOnceHandler(event, handler, capture) {\n  const _target = target; // save current target element in closure\n\n  return function onceHandler() {\n    const res = handler.apply(null, arguments);\n\n    if (res !== null) {\n      remove(event, onceHandler, capture, _target);\n    }\n  };\n} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\n\n\nconst useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add(name, handler, capture, passive) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    const attachedTimestamp = currentFlushTimestamp;\n    const original = handler; //@ts-expect-error\n\n    handler = original._wrapper = function (e) {\n      if ( // no bubbling, should always fire.\n      // this is just a safety net in case event.timeStamp is unreliable in\n      // certain weird environments...\n      e.target === e.currentTarget || // event is fired after handler attachment\n      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n      // #9681 QtWebEngine event.timeStamp is negative value\n      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n      // electron/nw.js app, since event.timeStamp will be using a different\n      // starting reference\n      e.target.ownerDocument !== document) {\n        return original.apply(this, arguments);\n      }\n    };\n  }\n\n  target.addEventListener(name, handler, supportsPassive ? {\n    capture,\n    passive\n  } : capture);\n}\n\nfunction remove(name, handler, capture, _target) {\n  (_target || target).removeEventListener(name, //@ts-expect-error\n  handler._wrapper || handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n\n  const on = vnode.data.on || {};\n  const oldOn = oldVnode.data.on || {}; // vnode is empty when removing all listeners,\n  // and use old vnode dom element\n\n  target = vnode.elm || oldVnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);\n  target = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners,\n  // @ts-expect-error emptyNode has actually data\n  destroy: vnode => updateDOMListeners(vnode, emptyNode)\n};\nlet svgContainer;\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n\n  let key, cur;\n  const elm = vnode.elm;\n  const oldProps = oldVnode.data.domProps || {};\n  let props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key]; // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) vnode.children.length = 0;\n      if (cur === oldProps[key]) continue; // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur; // avoid resetting cursor position when value is the same\n\n      const strCur = isUndef(cur) ? '' : String(cur);\n\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = `<svg>${cur}</svg>`;\n      const svg = svgContainer.firstChild;\n\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if ( // skip the update if old and new VDOM state is the same.\n    // `value` is handled separately because the DOM value may be temporarily\n    // out of sync with VDOM state due to focus, composition and modifiers.\n    // This  #4521 by skipping the unnecessary `checked` update.\n    cur !== oldProps[key]) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\nfunction shouldUpdateValue(elm, checkVal) {\n  return (//@ts-expect-error\n    !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal))\n  );\n}\n\nfunction isNotInFocusAndDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  let notInFocus = true; // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n\n  try {\n    notInFocus = document.activeElement !== elm;\n  } catch (e) {}\n\n  return notInFocus && elm.value !== checkVal;\n}\n\nfunction isDirtyWithModifiers(elm, newVal) {\n  const value = elm.value;\n  const modifiers = elm._vModifiers; // injected by v-model runtime\n\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal);\n    }\n\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim();\n    }\n  }\n\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\nconst parseStyleText = cached(function (cssText) {\n  const res = {};\n  const listDelimiter = /;(?![^(]*\\))/g;\n  const propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      const tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n}); // merge static and dynamic style data on the same vnode\n\nfunction normalizeStyleData(data) {\n  const style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n} // normalize possible array / string values into Object\n\n\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n\n  return bindingStyle;\n}\n/**\r\n * parent component style should be after child's\r\n * so that parent component's style could override it\r\n */\n\n\nfunction getStyle(vnode, checkChild) {\n  const res = {};\n  let styleData;\n\n  if (checkChild) {\n    let childNode = vnode;\n\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  let parentNode = vnode; // @ts-expect-error parentNode.parent not VNodeWithData\n\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n\n  return res;\n}\n\nconst cssVarRE = /^--/;\nconst importantRE = /\\s*!important$/;\n\nconst setProp = (el, name, val) => {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    const normalizedName = normalize(name);\n\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (let i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nconst vendorNames = ['Webkit', 'Moz', 'ms'];\nlet emptyStyle;\nconst normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n\n  if (prop !== 'filter' && prop in emptyStyle) {\n    return prop;\n  }\n\n  const capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n  for (let i = 0; i < vendorNames.length; i++) {\n    const name = vendorNames[i] + capName;\n\n    if (name in emptyStyle) {\n      return name;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  const data = vnode.data;\n  const oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  let cur, name;\n  const el = vnode.elm;\n  const oldStaticStyle = oldData.staticStyle;\n  const oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n  const oldStyle = oldStaticStyle || oldStyleBinding;\n  const style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n  const newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n\n  for (name in newStyle) {\n    cur = newStyle[name];\n\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\nconst whitespaceRE = /\\s+/;\n/**\r\n * Add class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\n\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(c => el.classList.add(c));\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    const cur = ` ${el.getAttribute('class') || ''} `;\n\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n/**\r\n * Remove class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\n\n\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(c => el.classList.remove(c));\n    } else {\n      el.classList.remove(cls);\n    }\n\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    let cur = ` ${el.getAttribute('class') || ''} `;\n    const tar = ' ' + cls + ' ';\n\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n\n    cur = cur.trim();\n\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\nfunction resolveTransition(def) {\n  if (!def) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (typeof def === 'object') {\n    const res = {};\n\n    if (def.css !== false) {\n      extend(res, autoCssTransition(def.name || 'v'));\n    }\n\n    extend(res, def);\n    return res;\n  } else if (typeof def === 'string') {\n    return autoCssTransition(def);\n  }\n}\n\nconst autoCssTransition = cached(name => {\n  return {\n    enterClass: `${name}-enter`,\n    enterToClass: `${name}-enter-to`,\n    enterActiveClass: `${name}-enter-active`,\n    leaveClass: `${name}-leave`,\n    leaveToClass: `${name}-leave-to`,\n    leaveActiveClass: `${name}-leave-active`\n  };\n});\nconst hasTransition = inBrowser && !isIE9;\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation'; // Transition property/event sniffing\n\nlet transitionProp = 'transition';\nlet transitionEndEvent = 'transitionend';\nlet animationProp = 'animation';\nlet animationEndEvent = 'animationend';\n\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n} // binding to window is necessary to make hot reload work in IE in strict mode\n\n\nconst raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n/* istanbul ignore next */\n\n/* istanbul ignore next */\nfn => fn();\n\nfunction nextFrame(fn) {\n  raf(() => {\n    // @ts-expect-error\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  const transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove$2(el._transitionClasses, cls);\n  }\n\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  const {\n    type,\n    timeout,\n    propCount\n  } = getTransitionInfo(el, expectedType);\n  if (!type) return cb();\n  const event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  let ended = 0;\n\n  const end = () => {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n\n  const onEnd = e => {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nconst transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n  const transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  const transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  const animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type;\n  let timeout = 0;\n  let propCount = 0;\n  /* istanbul ignore if */\n\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n\n  const hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map((d, i) => {\n    return toMs(d) + toMs(delays[i]);\n  }));\n} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\n\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n\nfunction enter(vnode, toggleDisplay) {\n  const el = vnode.elm; // call leave callback now\n\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n\n    el._leaveCb();\n  }\n\n  const data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data)) {\n    return;\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  const {\n    css,\n    type,\n    enterClass,\n    enterToClass,\n    enterActiveClass,\n    appearClass,\n    appearToClass,\n    appearActiveClass,\n    beforeEnter,\n    enter,\n    afterEnter,\n    enterCancelled,\n    beforeAppear,\n    appear,\n    afterAppear,\n    appearCancelled,\n    duration\n  } = data; // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n\n  let context = activeInstance;\n  let transitionNode = activeInstance.$vnode;\n\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  const isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  const startClass = isAppear && appearClass ? appearClass : enterClass;\n  const activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  const toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n  const beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  const enterHook = isAppear ? isFunction(appear) ? appear : enter : enter;\n  const afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  const enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n  const explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if (explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  const expectsCSS = css !== false && !isIE9;\n  const userWantsControl = getHookArgumentsLength(enterHook);\n  const cb = el._enterCb = once(() => {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    } // @ts-expect-error\n\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', () => {\n      const parent = el.parentNode;\n      const pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n\n      enterHook && enterHook(el, cb);\n    });\n  } // start enter transition\n\n\n  beforeEnterHook && beforeEnterHook(el);\n\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(() => {\n      removeTransitionClass(el, startClass); // @ts-expect-error\n\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  const el = vnode.elm; // call enter callback now\n\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n\n    el._enterCb();\n  }\n\n  const data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm();\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._leaveCb)) {\n    return;\n  }\n\n  const {\n    css,\n    type,\n    leaveClass,\n    leaveToClass,\n    leaveActiveClass,\n    beforeLeave,\n    leave,\n    afterLeave,\n    leaveCancelled,\n    delayLeave,\n    duration\n  } = data;\n  const expectsCSS = css !== false && !isIE9;\n  const userWantsControl = getHookArgumentsLength(leave);\n  const explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if (isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  const cb = el._leaveCb = once(() => {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    } // @ts-expect-error\n\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    // @ts-expect-error\n    if (cb.cancelled) {\n      return;\n    } // record leaving element\n\n\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n\n    beforeLeave && beforeLeave(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(() => {\n        removeTransitionClass(el, leaveClass); // @ts-expect-error\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    leave && leave(el, cb);\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n} // only used in dev mode\n\n\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(`<transition> explicit ${name} duration is not a valid number - ` + `got ${JSON.stringify(val)}.`, vnode.context);\n  } else if (isNaN(val)) {\n    warn(`<transition> explicit ${name} duration is NaN - ` + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n/**\r\n * Normalize a transition hook's argument length. The hook may be:\r\n * - a merged hook (invoker) with the original in .fns\r\n * - a wrapped component method (check ._length)\r\n * - a plain function (.length)\r\n */\n\n\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  } // @ts-expect-error\n\n\n  const invokerFns = fn.fns;\n\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    // @ts-expect-error\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n\n  remove(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      // @ts-expect-error\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n\n} : {};\nvar platformModules = [attrs, klass, events, domProps, style, transition]; // the directive module should be applied last, after all\n// built-in modules have been applied.\n\nconst modules = platformModules.concat(baseModules);\nconst patch = createPatchFunction({\n  nodeOps,\n  modules\n});\n/**\r\n * Not type checking this file because flow doesn't like attaching\r\n * properties to Elements.\r\n */\n\n/* istanbul ignore if */\n\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', () => {\n    const el = document.activeElement; // @ts-expect-error\n\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nconst directive = {\n  inserted(el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', () => {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n\n      const prevOptions = el._vOptions;\n      const curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n      if (curOptions.some((o, i) => !looseEqual(o, prevOptions[i]))) {\n        // trigger change event if\n        // no matching option found for at least one value\n        const needReset = el.multiple ? binding.value.some(v => hasNoMatchingOption(v, curOptions)) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n\n};\n\nfunction setSelected(el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n\n  if (isIE || isEdge) {\n    setTimeout(() => {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected(el, binding, vm) {\n  const value = binding.value;\n  const isMultiple = el.multiple;\n\n  if (isMultiple && !Array.isArray(value)) {\n    warn(`<select multiple v-model=\"${binding.expression}\"> ` + `expects an Array value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}`, vm);\n    return;\n  }\n\n  let selected, option;\n\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n\n        return;\n      }\n    }\n  }\n\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  return options.every(o => !looseEqual(o, value));\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) return;\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  const e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n} // recursively search for possible transition defined inside the component root\n\n\nfunction locateNode(vnode) {\n  // @ts-expect-error\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind(el, {\n    value\n  }, vnode) {\n    vnode = locateNode(vnode);\n    const transition = vnode.data && vnode.data.transition;\n    const originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n    if (value && transition) {\n      vnode.data.show = true;\n      enter(vnode, () => {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update(el, {\n    value,\n    oldValue\n  }, vnode) {\n    /* istanbul ignore if */\n    if (!value === !oldValue) return;\n    vnode = locateNode(vnode);\n    const transition = vnode.data && vnode.data.transition;\n\n    if (transition) {\n      vnode.data.show = true;\n\n      if (value) {\n        enter(vnode, () => {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, () => {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n\n};\nvar platformDirectives = {\n  model: directive,\n  show\n}; // Provides transition support for a single element/component.\n\nconst transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n}; // in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\n\nfunction getRealChild(vnode) {\n  const compOptions = vnode && vnode.componentOptions;\n\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  const data = {};\n  const options = comp.$options; // props\n\n  for (const key in options.propsData) {\n    data[key] = comp[key];\n  } // events.\n  // extract listeners and pass them directly to the transition methods\n\n\n  const listeners = options._parentListeners;\n\n  for (const key in listeners) {\n    data[camelize(key)] = listeners[key];\n  }\n\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  // @ts-expect-error\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nconst isNotTextNode = c => c.tag || isAsyncPlaceholder(c);\n\nconst isVShowDirective = d => d.name === 'show';\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render(h) {\n    let children = this.$slots.default;\n\n    if (!children) {\n      return;\n    } // filter out text nodes (possible whitespaces)\n\n\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n\n    if (!children.length) {\n      return;\n    } // warn multiple elements\n\n\n    if (children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    const mode = this.mode; // warn invalid mode\n\n    if (mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    const rawChild = children[0]; // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    } // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n    const child = getRealChild(rawChild);\n    /* istanbul ignore if */\n\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    } // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n\n\n    const id = `__transition-${this._uid}-`;\n    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n    const data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    const oldRawChild = this._vnode;\n    const oldChild = getRealChild(oldRawChild); // mark v-show\n    // so that the transition module can hand over the control to the directive\n\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      const oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', () => {\n          this._leaving = false;\n          this.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild;\n        }\n\n        let delayedLeave;\n\n        const performLeave = () => {\n          delayedLeave();\n        };\n\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', leave => {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n\n}; // Provides transition support for list items.\n\nconst props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\ndelete props.mode;\nvar TransitionGroup = {\n  props,\n\n  beforeMount() {\n    const update = this._update;\n\n    this._update = (vnode, hydrating) => {\n      const restoreActiveInstance = setActiveInstance(this); // force removing pass\n\n      this.__patch__(this._vnode, this.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n\n      this._vnode = this.kept;\n      restoreActiveInstance();\n      update.call(this, vnode, hydrating);\n    };\n  },\n\n  render(h) {\n    const tag = this.tag || this.$vnode.data.tag || 'span';\n    const map = Object.create(null);\n    const prevChildren = this.prevChildren = this.children;\n    const rawChildren = this.$slots.default || [];\n    const children = this.children = [];\n    const transitionData = extractTransitionData(this);\n\n    for (let i = 0; i < rawChildren.length; i++) {\n      const c = rawChildren[i];\n\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;\n          (c.data || (c.data = {})).transition = transitionData;\n        } else {\n          const opts = c.componentOptions;\n          const name = opts ? getComponentName(opts.Ctor.options) || opts.tag || '' : c.tag;\n          warn(`<transition-group> children must be keyed: <${name}>`);\n        }\n      }\n    }\n\n    if (prevChildren) {\n      const kept = [];\n      const removed = [];\n\n      for (let i = 0; i < prevChildren.length; i++) {\n        const c = prevChildren[i];\n        c.data.transition = transitionData; // @ts-expect-error .getBoundingClientRect is not typed in Node\n\n        c.data.pos = c.elm.getBoundingClientRect();\n\n        if (map[c.key]) {\n          kept.push(c);\n        } else {\n          removed.push(c);\n        }\n      }\n\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n\n  updated() {\n    const children = this.prevChildren;\n    const moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    } // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n\n\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation); // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n\n    this._reflow = document.body.offsetHeight;\n    children.forEach(c => {\n      if (c.data.moved) {\n        const el = c.elm;\n        const s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (e && e.target !== el) {\n            return;\n          }\n\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      /* istanbul ignore if */\n\n\n      if (this._hasMove) {\n        return this._hasMove;\n      } // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n\n\n      const clone = el.cloneNode();\n\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(cls => {\n          removeClass(clone, cls);\n        });\n      }\n\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      const info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n\n\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  const oldPos = c.data.pos;\n  const newPos = c.data.newPos;\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n\n  if (dx || dy) {\n    c.data.moved = true;\n    const s = c.elm.style;\n    s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition,\n  TransitionGroup\n}; // install platform specific utils\n\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents); // install platform patch function\n\nVue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\nVue.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n}; // devtools global hook\n\n/* istanbul ignore next */\n\n\nif (inBrowser) {\n  setTimeout(() => {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else {\n        // @ts-expect-error\n        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n      }\n    }\n\n    if (config.productionTip !== false && typeof console !== 'undefined') {\n      // @ts-expect-error\n      console[console.info ? 'info' : 'log'](`You are running Vue in development mode.\\n` + `Make sure to turn on production mode when deploying for production.\\n` + `See more tips at https://vuejs.org/guide/deployment.html`);\n    }\n  }, 0);\n}\n\nextend(Vue, vca);\nmodule.exports = Vue;","map":{"version":3,"names":["emptyObject","Object","freeze","isArray","Array","isUndef","v","undefined","isDef","isTrue","isFalse","isPrimitive","value","isFunction","isObject","obj","_toString","prototype","toString","toRawType","call","slice","isPlainObject","isRegExp","isValidArrayIndex","val","n","parseFloat","String","Math","floor","isFinite","isPromise","then","catch","JSON","stringify","toNumber","isNaN","makeMap","str","expectsLowerCase","map","create","list","split","i","length","toLowerCase","isBuiltInTag","isReservedAttribute","remove$2","arr","item","index","indexOf","splice","hasOwnProperty","hasOwn","key","cached","fn","cache","cachedFn","hit","camelizeRE","camelize","replace","_","c","toUpperCase","capitalize","charAt","hyphenateRE","hyphenate","polyfillBind","ctx","boundFn","a","l","arguments","apply","_length","nativeBind","bind","Function","toArray","start","ret","extend","to","_from","toObject","res","noop","b","no","identity","looseEqual","isObjectA","isObjectB","isArrayA","isArrayB","every","e","Date","getTime","keysA","keys","keysB","looseIndexOf","once","called","hasChanged","x","y","SSR_ATTR","ASSET_TYPES","LIFECYCLE_HOOKS","config","optionMergeStrategies","silent","productionTip","devtools","performance","errorHandler","warnHandler","ignoredElements","keyCodes","isReservedTag","isReservedAttr","isUnknownElement","getTagNamespace","parsePlatformTagName","mustUseProp","async","_lifecycleHooks","unicodeRegExp","isReserved","charCodeAt","def","enumerable","defineProperty","writable","configurable","bailRE","RegExp","source","parsePath","path","test","segments","hasProto","inBrowser","window","UA","navigator","userAgent","isIE","isIE9","isEdge","isIOS","isFF","match","nativeWatch","watch","supportsPassive","opts","get","addEventListener","_isServer","isServerRendering","global","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","isNative","Ctor","hasSymbol","Symbol","Reflect","ownKeys","_Set","Set","constructor","set","has","add","clear","currentInstance","getCurrentInstance","proxy","setCurrentInstance","vm","_scope","off","on","VNode","tag","data","children","text","elm","context","componentOptions","asyncFactory","ns","fnContext","fnOptions","fnScopeId","componentInstance","parent","raw","isStatic","isRootInsert","isComment","isCloned","isOnce","asyncMeta","isAsyncPlaceholder","child","createEmptyVNode","node","createTextVNode","cloneVNode","vnode","cloned","uid$2","Dep","id","subs","addSub","sub","push","removeSub","depend","info","target","addDep","onTrack","assign","effect","notify","sort","onTrigger","update","targetStack","pushTarget","popTarget","pop","arrayProto","arrayMethods","methodsToPatch","forEach","method","original","mutator","args","result","ob","__ob__","inserted","observeArray","dep","type","arrayKeys","getOwnPropertyNames","NO_INIITIAL_VALUE","shouldObserve","toggleObserving","mockDep","Observer","shallow","mock","vmCount","__proto__","defineReactive","observe","ssrMockReactivity","isRef","isExtensible","__v_skip","customSetter","property","getOwnPropertyDescriptor","getter","setter","childOb","reactiveGetter","dependArray","reactiveSetter","newVal","newValue","oldValue","warn","isReadonly","max","_isVue","del","reactive","makeReactive","shallowReactive","existingOb","isCollectionType","isReactive","isShallow","__v_isShallow","__v_isReadonly","isProxy","toRaw","observed","markRaw","RefFlag","r","__v_isRef","ref$1","createRef","shallowRef","rawValue","ref","triggerRef","unref","proxyRefs","objectWithRefs","proxyWithRefUnwrap","customRef","factory","toRefs","object","toRef","defaultValue","rawToReadonlyFlag","rawToShallowReadonlyFlag","readonly","createReadonly","existingFlag","existingProxy","getPrototypeOf","defineReadonlyProperty","shallowReadonly","computed","getterOrOptions","debugOptions","onlyGetter","watcher","Watcher","lazy","dirty","evaluate","WATCHER","WATCHER_CB","WATCHER_GETTER","WATCHER_CLEANUP","watchEffect","options","doWatch","watchPostEffect","flush","watchSyncEffect","INITIAL_WATCHER_VALUE","cb","immediate","deep","warnInvalidSource","s","instance","invokeWithErrorHandling","forceTrigger","isMultiSource","some","traverse","_isDestroyed","cleanup","onCleanup","baseGetter","onStop","noRecurse","run","active","post","queueWatcher","_isMounted","buffer","_preWatchers","$once","teardown","activeEffectScope","EffectScope","detached","effects","cleanups","scopes","currentEffectScope","stop","fromParent","last","effectScope","recordEffectScope","scope","getCurrentScope","onScopeDispose","provide","resolveProvided","existing","_provided","parentProvides","$parent","inject","treatDefaultAsFactory","provides","normalizeEvent","name","passive","capture","createFnInvoker","fns","invoker","updateListeners","oldOn","remove","createOnceHandler","cur","old","event","params","mergeVNodeHook","hookKey","hook","oldHook","wrappedHook","merged","extractPropsFromVNodeData","propOptions","props","attrs","altKey","keyInLowerCase","tip","formatComponentName","checkProp","hash","preserve","simpleNormalizeChildren","concat","normalizeChildren","normalizeArrayChildren","isTextNode","nestedIndex","lastIndex","shift","_isVList","renderList","render","iterator","next","done","renderSlot","fallbackRender","bindObject","scopedSlotFn","$scopedSlots","nodes","$slots","slot","$createElement","resolveFilter","resolveAsset","$options","isKeyNotMatch","expect","actual","checkKeyCodes","eventKeyCode","builtInKeyCode","eventKeyName","builtInKeyName","mappedKeyCode","bindObjectProps","asProp","isSync","domProps","camelizedKey","hyphenatedKey","$event","renderStatic","isInFor","_staticTrees","tree","staticRenderFns","_renderProxy","_c","markStatic","markOnce","markStaticNode","bindObjectListeners","ours","resolveScopedSlots","hasDynamicKeys","contentHashKey","$stable","$key","bindDynamicKeys","baseObj","values","prependModifier","symbol","installRenderHelpers","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","_u","_g","_d","_p","resolveSlots","slots","default","isWhitespace","normalizeScopedSlots","ownerVm","scopedSlots","normalSlots","prevScopedSlots","hasNormalSlots","isStable","_normalized","$hasNormal","normalizeScopedSlot","proxyNormalSlot","normalized","initSetup","setup","_setupContext","createSetupContext","setupResult","_props","_setupState","__sfc","_setupProxy","exposeCalled","_attrsProxy","syncSetupProxy","$attrs","listeners","_listenersProxy","$listeners","initSlotsProxy","emit","$emit","expose","exposed","from","prev","changed","defineProxyAttr","_slotsProxy","syncSetupSlots","useSlots","getContext","useAttrs","useListeners","mergeDefaults","defaults","reduce","p","opt","initRender","_vnode","parentVnode","$vnode","_parentVnode","renderContext","_renderChildren","d","createElement$1","parentData","isUpdatingChildComponent","_parentListeners","currentRenderingInstance","renderMixin","Vue","$nextTick","nextTick","_render","handleError","renderError","ensureCtor","comp","base","__esModule","toStringTag","createAsyncPlaceholder","resolveAsyncComponent","baseCtor","error","errorComp","resolved","owner","owners","loading","loadingComp","sync","timerLoading","timerTimeout","$on","forceRender","renderCompleted","$forceUpdate","clearTimeout","resolve","reject","reason","component","delay","setTimeout","timeout","getFirstComponentChild","SIMPLE_NORMALIZE","ALWAYS_NORMALIZE","normalizationType","alwaysNormalize","_createElement","is","nativeOn","pre","createComponent","applyNS","registerDeepBindings","force","style","class","h","err","hooks","errorCaptured","globalHandleError","handler","_handled","logError","console","isUsingMicroTask","callbacks","pending","flushCallbacks","copies","timerFunc","Promise","MutationObserver","counter","observer","textNode","document","createTextNode","characterData","setImmediate","_resolve","useCssModule","mod","useCssVars","el","$el","vars","nodeType","setProperty","defineAsyncComponent","loader","loadingComponent","errorComponent","suspensible","onError","userOnError","pendingRequest","retries","retry","load","thisRequest","Error","userRetry","userFail","createLifeCycle","hookName","formatName","injectHook","mergeLifecycleHook","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onUnmounted","onActivated","onDeactivated","onServerPrefetch","onRenderTracked","onRenderTriggered","injectErrorCapturedHook","onErrorCaptured","version","defineComponent","vca","seenObjects","_traverse","seen","isA","isFrozen","depId","uid$1","expOrFn","isRenderWatcher","_vm","_watcher","user","before","deps","newDeps","depIds","newDepIds","expression","cleanupDeps","tmp","_isBeingDestroyed","mark","measure","perf","clearMarks","clearMeasures","startTag","endTag","initEvents","_events","_hasHookEvent","updateComponentListeners","target$1","add$1","remove$1","$off","createOnceHandler$1","_target","onceHandler","oldListeners","eventsMixin","hookRE","cbs","lowerCaseEvent","activeInstance","setActiveInstance","prevActiveInstance","initLifecycle","abstract","$children","$root","$refs","_inactive","_directInactive","lifecycleMixin","_update","hydrating","prevEl","prevVnode","restoreActiveInstance","__patch__","__vue__","wrapper","$destroy","callHook$1","_data","mountComponent","template","updateComponent","_name","_uid","watcherOptions","preWatchers","updateChildComponent","propsData","renderChildren","newScopedSlots","oldScopedSlots","hasDynamicScopedSlot","needsForceUpdate","prevVNode","prevListeners","propKeys","_propKeys","validateProp","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","setContext","handlers","j","MAX_UPDATE_COUNT","queue","activatedChildren","circular","waiting","flushing","resetSchedulerState","currentFlushTimestamp","getNow","now","createEvent","timeStamp","sortCompareFn","flushSchedulerQueue","activatedQueue","updatedQueue","callActivatedHooks","callUpdatedHooks","queueActivatedComponent","initProvide","provideOption","provided","initInjections","resolveInject","provideKey","provideDefault","FunctionalRenderContext","contextVm","_original","isCompiled","_compiled","needNormalization","injections","_scopeId","createFunctionalComponent","mergeProps","cloneAndMarkFunctionalResult","vnodes","clone","devtoolsMeta","getComponentName","__name","_componentTag","componentVNodeHooks","init","keepAlive","mountedNode","prepatch","createComponentInstanceForVnode","$mount","oldVnode","insert","destroy","hooksToMerge","_base","cid","resolveConstructorOptions","model","transformModel","functional","installComponentHooks","_isComponent","inlineTemplate","toMerge","_merged","mergeHook","f1","f2","prop","callback","generateComponentTrace","hasConsole","classifyRE","classify","msg","trace","includeFile","file","__file","repeat","currentRecursiveSequence","join","strats","defaultStrat","mergeData","toVal","fromVal","mergeDataOrFn","parentVal","childVal","mergedDataFn","mergedInstanceDataFn","instanceData","defaultData","dedupeHooks","mergeAssets","assertObjectType","methods","checkComponents","components","validateComponentName","normalizeProps","normalizeInject","normalizeDirectives$1","dirs","directives","mergeOptions","extends","mixins","mergeField","strat","warnMissing","assets","camelizedId","PascalCaseId","absent","booleanIndex","getTypeIndex","Boolean","stringIndex","getPropDefaultValue","prevShouldObserve","assertProp","getType","required","valid","expectedTypes","assertedType","assertType","expectedType","haveExpectedTypes","t","getInvalidTypeMessage","validator","simpleCheckRE","functionTypeCheckRE","isSameType","len","message","receivedType","isExplicable","isBoolean","styleValue","Number","EXPLICABLE_TYPES","elem","initProxy","allowedGlobals","warnNonPresent","warnReservedPrefix","hasProxy","Proxy","isBuiltInModifier","hasHandler","isAllowed","$data","getHandler","_withStripped","sharedPropertyDefinition","sourceKey","proxyGetter","proxySetter","initState","initProps$1","initMethods","initData","initComputed$1","initWatch","propsOptions","isRoot","getData","computedWatcherOptions","watchers","_computedWatchers","isSSR","userDef","defineComputed","shouldCache","createComputedGetter","createGetterInvoker","computedGetter","createWatcher","$watch","stateMixin","dataDef","propsDef","$set","$delete","unwatchFn","uid","initMixin$1","_init","initInternalComponent","_self","vnodeComponentOptions","super","superOptions","cachedSuperOptions","modifiedOptions","resolveModifiedOptions","extendOptions","modified","latest","sealed","sealedOptions","initUse","use","plugin","installedPlugins","_installedPlugins","unshift","install","initMixin","mixin","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","VueComponent","initProps","initComputed","Comp","initAssetRegisters","definition","_getComponentName","matches","pattern","pruneCache","keepAliveInstance","filter","entry","pruneCacheEntry","current","patternTypes","KeepAlive","include","exclude","cacheVNode","vnodeToCache","keyToCache","parseInt","created","destroyed","mounted","updated","builtInComponents","initGlobalAPI","configDef","util","delete","observable","ssrContext","acceptValue","attr","isEnumeratedAttr","isValidContentEditableValue","convertEnumeratedValue","isFalsyAttrValue","isBooleanAttr","xlinkNS","isXlink","getXlinkProp","genClassForVnode","parentNode","childNode","mergeClassData","renderClass","staticClass","dynamicClass","stringifyClass","stringifyArray","stringifyObject","stringified","namespaceMap","svg","math","isHTMLTag","isSVG","unknownElementCache","createElement","HTMLUnknownElement","HTMLElement","isTextInputType","query","selected","querySelector","tagName","multiple","setAttribute","createElementNS","namespace","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","setStyleScope","scopeId","nodeOps","registerRef","isRemoval","refValue","$refsValue","isFor","refInFor","_isString","_isRef","refs","setSetupRef","includes","emptyNode","sameVnode","sameInputType","typeA","typeB","createKeyToOldIdx","beginIdx","endIdx","createPatchFunction","backend","modules","emptyNodeAt","createRmCb","childElm","removeNode","inVPre","ignore","creatingElmInVPre","createElm","insertedVnodeQueue","parentElm","refElm","nested","ownerArray","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","transition","activate","checkDuplicateKeys","ancestor","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","rm","updateChildren","oldCh","newCh","removeOnly","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","oldKeyToIdx","idxInOld","vnodeToMove","canMove","patchVnode","findIdxInOld","seenKeys","end","hydrate","postpatch","invokeInsertHook","initial","hydrationBailed","isRenderedModule","assertNodeMatch","hasChildNodes","innerHTML","childrenMatch","firstChild","childNodes","fullInvoke","patch","isInitialPatch","isRealElement","hasAttribute","removeAttribute","oldElm","_leaveCb","patchable","updateDirectives","unbindDirectives","isCreate","isDestroy","oldDirs","normalizeDirectives","newDirs","dirsWithInsert","dirsWithPostpatch","oldDir","dir","callHook","oldArg","arg","componentUpdated","callInsert","emptyModifiers","modifiers","getRawDirName","setupDef","rawName","baseModules","updateAttrs","inheritAttrs","oldAttrs","_v_attr_proxy","setAttr","removeAttributeNS","isInPre","baseSetAttr","setAttributeNS","__ieph","blocker","stopImmediatePropagation","removeEventListener","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","klass","RANGE_TOKEN","CHECKBOX_RADIO_TOKEN","normalizeEvents","change","useMicrotaskFix","attachedTimestamp","_wrapper","currentTarget","ownerDocument","updateDOMListeners","events","svgContainer","updateDOMProps","oldProps","_value","strCur","shouldUpdateValue","checkVal","composing","isNotInFocusAndDirty","isDirtyWithModifiers","notInFocus","activeElement","_vModifiers","number","trim","parseStyleText","cssText","listDelimiter","propertyDelimiter","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","getStyle","checkChild","styleData","cssVarRE","importantRE","setProp","normalizedName","normalize","vendorNames","emptyStyle","capName","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","whitespaceRE","addClass","classList","getAttribute","removeClass","tar","resolveTransition","css","autoCssTransition","enterClass","enterToClass","enterActiveClass","leaveClass","leaveToClass","leaveActiveClass","hasTransition","TRANSITION","ANIMATION","transitionProp","transitionEndEvent","animationProp","animationEndEvent","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","raf","requestAnimationFrame","nextFrame","addTransitionClass","transitionClasses","removeTransitionClass","whenTransitionEnds","propCount","getTransitionInfo","ended","onEnd","transformRE","styles","getComputedStyle","transitionDelays","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationDurations","animationTimeout","hasTransform","delays","durations","toMs","enter","toggleDisplay","cancelled","_enterCb","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","transitionNode","isAppear","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","checkDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","beforeLeave","afterLeave","leaveCancelled","delayLeave","explicitLeaveDuration","performLeave","invokerFns","_enter","platformModules","vmodel","trigger","directive","binding","_vOptions","setSelected","getValue","onCompositionStart","onCompositionEnd","prevOptions","curOptions","o","needReset","hasNoMatchingOption","actuallySetSelected","isMultiple","option","selectedIndex","initEvent","dispatchEvent","locateNode","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","getRealChild","compOptions","extractTransitionData","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","isNotTextNode","isVShowDirective","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","beforeMount","kept","prevChildren","rawChildren","transitionData","removed","pos","getBoundingClientRect","hasMove","callPendingCbs","recordPosition","applyTranslation","_reflow","body","offsetHeight","moved","transform","WebkitTransform","transitionDuration","_moveCb","propertyName","_hasMove","cloneNode","newPos","oldPos","dx","left","dy","top","platformComponents","module","exports"],"sources":["D:/vue-tea/node_modules/vue/dist/vue.runtime.common.dev.js"],"sourcesContent":["/*!\n * Vue.js v2.7.10\n * (c) 2014-2022 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\nconst emptyObject = Object.freeze({});\r\nconst isArray = Array.isArray;\r\n// These helpers produce better VM code in JS engines due to their\r\n// explicitness and function inlining.\r\nfunction isUndef(v) {\r\n    return v === undefined || v === null;\r\n}\r\nfunction isDef(v) {\r\n    return v !== undefined && v !== null;\r\n}\r\nfunction isTrue(v) {\r\n    return v === true;\r\n}\r\nfunction isFalse(v) {\r\n    return v === false;\r\n}\r\n/**\r\n * Check if value is primitive.\r\n */\r\nfunction isPrimitive(value) {\r\n    return (typeof value === 'string' ||\r\n        typeof value === 'number' ||\r\n        // $flow-disable-line\r\n        typeof value === 'symbol' ||\r\n        typeof value === 'boolean');\r\n}\r\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * Quick object check - this is primarily used to tell\r\n * objects from primitive values when we know the value\r\n * is a JSON-compliant type.\r\n */\r\nfunction isObject(obj) {\r\n    return obj !== null && typeof obj === 'object';\r\n}\r\n/**\r\n * Get the raw type string of a value, e.g., [object Object].\r\n */\r\nconst _toString = Object.prototype.toString;\r\nfunction toRawType(value) {\r\n    return _toString.call(value).slice(8, -1);\r\n}\r\n/**\r\n * Strict object type check. Only returns true\r\n * for plain JavaScript objects.\r\n */\r\nfunction isPlainObject(obj) {\r\n    return _toString.call(obj) === '[object Object]';\r\n}\r\nfunction isRegExp(v) {\r\n    return _toString.call(v) === '[object RegExp]';\r\n}\r\n/**\r\n * Check if val is a valid array index.\r\n */\r\nfunction isValidArrayIndex(val) {\r\n    const n = parseFloat(String(val));\r\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\r\n}\r\nfunction isPromise(val) {\r\n    return (isDef(val) &&\r\n        typeof val.then === 'function' &&\r\n        typeof val.catch === 'function');\r\n}\r\n/**\r\n * Convert a value to a string that is actually rendered.\r\n */\r\nfunction toString(val) {\r\n    return val == null\r\n        ? ''\r\n        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\r\n            ? JSON.stringify(val, null, 2)\r\n            : String(val);\r\n}\r\n/**\r\n * Convert an input value to a number for persistence.\r\n * If the conversion fails, return original string.\r\n */\r\nfunction toNumber(val) {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n}\r\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => map[val.toLowerCase()] : val => map[val];\r\n}\r\n/**\r\n * Check if a tag is a built-in tag.\r\n */\r\nconst isBuiltInTag = makeMap('slot,component', true);\r\n/**\r\n * Check if an attribute is a reserved attribute.\r\n */\r\nconst isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\r\n/**\r\n * Remove an item from an array.\r\n */\r\nfunction remove$2(arr, item) {\r\n    if (arr.length) {\r\n        const index = arr.indexOf(item);\r\n        if (index > -1) {\r\n            return arr.splice(index, 1);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Check whether an object has the property.\r\n */\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwn(obj, key) {\r\n    return hasOwnProperty.call(obj, key);\r\n}\r\n/**\r\n * Create a cached version of a pure function.\r\n */\r\nfunction cached(fn) {\r\n    const cache = Object.create(null);\r\n    return function cachedFn(str) {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    };\r\n}\r\n/**\r\n * Camelize a hyphen-delimited string.\r\n */\r\nconst camelizeRE = /-(\\w)/g;\r\nconst camelize = cached((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\n/**\r\n * Capitalize a string.\r\n */\r\nconst capitalize = cached((str) => {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n});\r\n/**\r\n * Hyphenate a camelCase string.\r\n */\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\nconst hyphenate = cached((str) => {\r\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\r\n});\r\n/**\r\n * Simple bind polyfill for environments that do not support it,\r\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\r\n * since native bind is now performant enough in most browsers.\r\n * But removing it would mean breaking code that was able to run in\r\n * PhantomJS 1.x, so this must be kept for backward compatibility.\r\n */\r\n/* istanbul ignore next */\r\nfunction polyfillBind(fn, ctx) {\r\n    function boundFn(a) {\r\n        const l = arguments.length;\r\n        return l\r\n            ? l > 1\r\n                ? fn.apply(ctx, arguments)\r\n                : fn.call(ctx, a)\r\n            : fn.call(ctx);\r\n    }\r\n    boundFn._length = fn.length;\r\n    return boundFn;\r\n}\r\nfunction nativeBind(fn, ctx) {\r\n    return fn.bind(ctx);\r\n}\r\n// @ts-expect-error bind cannot be `undefined`\r\nconst bind = Function.prototype.bind ? nativeBind : polyfillBind;\r\n/**\r\n * Convert an Array-like object to a real Array.\r\n */\r\nfunction toArray(list, start) {\r\n    start = start || 0;\r\n    let i = list.length - start;\r\n    const ret = new Array(i);\r\n    while (i--) {\r\n        ret[i] = list[i + start];\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * Mix properties into target object.\r\n */\r\nfunction extend(to, _from) {\r\n    for (const key in _from) {\r\n        to[key] = _from[key];\r\n    }\r\n    return to;\r\n}\r\n/**\r\n * Merge an Array of Objects into a single Object.\r\n */\r\nfunction toObject(arr) {\r\n    const res = {};\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (arr[i]) {\r\n            extend(res, arr[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/* eslint-disable no-unused-vars */\r\n/**\r\n * Perform no operation.\r\n * Stubbing args to make Flow happy without leaving useless transpiled code\r\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\r\n */\r\nfunction noop(a, b, c) { }\r\n/**\r\n * Always return false.\r\n */\r\nconst no = (a, b, c) => false;\r\n/* eslint-enable no-unused-vars */\r\n/**\r\n * Return the same value.\r\n */\r\nconst identity = (_) => _;\r\n/**\r\n * Check if two values are loosely equal - that is,\r\n * if they are plain objects, do they have the same shape?\r\n */\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    const isObjectA = isObject(a);\r\n    const isObjectB = isObject(b);\r\n    if (isObjectA && isObjectB) {\r\n        try {\r\n            const isArrayA = Array.isArray(a);\r\n            const isArrayB = Array.isArray(b);\r\n            if (isArrayA && isArrayB) {\r\n                return (a.length === b.length &&\r\n                    a.every((e, i) => {\r\n                        return looseEqual(e, b[i]);\r\n                    }));\r\n            }\r\n            else if (a instanceof Date && b instanceof Date) {\r\n                return a.getTime() === b.getTime();\r\n            }\r\n            else if (!isArrayA && !isArrayB) {\r\n                const keysA = Object.keys(a);\r\n                const keysB = Object.keys(b);\r\n                return (keysA.length === keysB.length &&\r\n                    keysA.every(key => {\r\n                        return looseEqual(a[key], b[key]);\r\n                    }));\r\n            }\r\n            else {\r\n                /* istanbul ignore next */\r\n                return false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            /* istanbul ignore next */\r\n            return false;\r\n        }\r\n    }\r\n    else if (!isObjectA && !isObjectB) {\r\n        return String(a) === String(b);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Return the first index at which a loosely equal value can be\r\n * found in the array (if value is a plain object, the array must\r\n * contain an object of the same shape), or -1 if it is not present.\r\n */\r\nfunction looseIndexOf(arr, val) {\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (looseEqual(arr[i], val))\r\n            return i;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Ensure a function is called only once.\r\n */\r\nfunction once(fn) {\r\n    let called = false;\r\n    return function () {\r\n        if (!called) {\r\n            called = true;\r\n            fn.apply(this, arguments);\r\n        }\r\n    };\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill\r\nfunction hasChanged(x, y) {\r\n    if (x === y) {\r\n        return x === 0 && 1 / x !== 1 / y;\r\n    }\r\n    else {\r\n        return x === x || y === y;\r\n    }\r\n}\n\nconst SSR_ATTR = 'data-server-rendered';\r\nconst ASSET_TYPES = ['component', 'directive', 'filter'];\r\nconst LIFECYCLE_HOOKS = [\r\n    'beforeCreate',\r\n    'created',\r\n    'beforeMount',\r\n    'mounted',\r\n    'beforeUpdate',\r\n    'updated',\r\n    'beforeDestroy',\r\n    'destroyed',\r\n    'activated',\r\n    'deactivated',\r\n    'errorCaptured',\r\n    'serverPrefetch',\r\n    'renderTracked',\r\n    'renderTriggered'\r\n];\n\nvar config = {\r\n    /**\r\n     * Option merge strategies (used in core/util/options)\r\n     */\r\n    // $flow-disable-line\r\n    optionMergeStrategies: Object.create(null),\r\n    /**\r\n     * Whether to suppress warnings.\r\n     */\r\n    silent: false,\r\n    /**\r\n     * Show production mode tip message on boot?\r\n     */\r\n    productionTip: true,\r\n    /**\r\n     * Whether to enable devtools\r\n     */\r\n    devtools: true,\r\n    /**\r\n     * Whether to record perf\r\n     */\r\n    performance: false,\r\n    /**\r\n     * Error handler for watcher errors\r\n     */\r\n    errorHandler: null,\r\n    /**\r\n     * Warn handler for watcher warns\r\n     */\r\n    warnHandler: null,\r\n    /**\r\n     * Ignore certain custom elements\r\n     */\r\n    ignoredElements: [],\r\n    /**\r\n     * Custom user key aliases for v-on\r\n     */\r\n    // $flow-disable-line\r\n    keyCodes: Object.create(null),\r\n    /**\r\n     * Check if a tag is reserved so that it cannot be registered as a\r\n     * component. This is platform-dependent and may be overwritten.\r\n     */\r\n    isReservedTag: no,\r\n    /**\r\n     * Check if an attribute is reserved so that it cannot be used as a component\r\n     * prop. This is platform-dependent and may be overwritten.\r\n     */\r\n    isReservedAttr: no,\r\n    /**\r\n     * Check if a tag is an unknown element.\r\n     * Platform-dependent.\r\n     */\r\n    isUnknownElement: no,\r\n    /**\r\n     * Get the namespace of an element\r\n     */\r\n    getTagNamespace: noop,\r\n    /**\r\n     * Parse the real tag name for the specific platform.\r\n     */\r\n    parsePlatformTagName: identity,\r\n    /**\r\n     * Check if an attribute must be bound using property, e.g. value\r\n     * Platform-dependent.\r\n     */\r\n    mustUseProp: no,\r\n    /**\r\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\r\n     * This will significantly reduce performance if set to false.\r\n     */\r\n    async: true,\r\n    /**\r\n     * Exposed for legacy reasons\r\n     */\r\n    _lifecycleHooks: LIFECYCLE_HOOKS\r\n};\n\n/**\r\n * unicode letters used for parsing html tags, component names and property paths.\r\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\r\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\r\n */\r\nconst unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\r\n/**\r\n * Check if a string starts with $ or _\r\n */\r\nfunction isReserved(str) {\r\n    const c = (str + '').charCodeAt(0);\r\n    return c === 0x24 || c === 0x5f;\r\n}\r\n/**\r\n * Define a property.\r\n */\r\nfunction def(obj, key, val, enumerable) {\r\n    Object.defineProperty(obj, key, {\r\n        value: val,\r\n        enumerable: !!enumerable,\r\n        writable: true,\r\n        configurable: true\r\n    });\r\n}\r\n/**\r\n * Parse simple path.\r\n */\r\nconst bailRE = new RegExp(`[^${unicodeRegExp.source}.$_\\\\d]`);\r\nfunction parsePath(path) {\r\n    if (bailRE.test(path)) {\r\n        return;\r\n    }\r\n    const segments = path.split('.');\r\n    return function (obj) {\r\n        for (let i = 0; i < segments.length; i++) {\r\n            if (!obj)\r\n                return;\r\n            obj = obj[segments[i]];\r\n        }\r\n        return obj;\r\n    };\r\n}\n\n// can we use __proto__?\r\nconst hasProto = '__proto__' in {};\r\n// Browser environment sniffing\r\nconst inBrowser = typeof window !== 'undefined';\r\nconst UA = inBrowser && window.navigator.userAgent.toLowerCase();\r\nconst isIE = UA && /msie|trident/.test(UA);\r\nconst isIE9 = UA && UA.indexOf('msie 9.0') > 0;\r\nconst isEdge = UA && UA.indexOf('edge/') > 0;\r\nUA && UA.indexOf('android') > 0;\r\nconst isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\r\nUA && /chrome\\/\\d+/.test(UA) && !isEdge;\r\nUA && /phantomjs/.test(UA);\r\nconst isFF = UA && UA.match(/firefox\\/(\\d+)/);\r\n// Firefox has a \"watch\" function on Object.prototype...\r\n// @ts-expect-error firebox support\r\nconst nativeWatch = {}.watch;\r\nlet supportsPassive = false;\r\nif (inBrowser) {\r\n    try {\r\n        const opts = {};\r\n        Object.defineProperty(opts, 'passive', {\r\n            get() {\r\n                /* istanbul ignore next */\r\n                supportsPassive = true;\r\n            }\r\n        }); // https://github.com/facebook/flow/issues/285\r\n        window.addEventListener('test-passive', null, opts);\r\n    }\r\n    catch (e) { }\r\n}\r\n// this needs to be lazy-evaled because vue may be required before\r\n// vue-server-renderer can set VUE_ENV\r\nlet _isServer;\r\nconst isServerRendering = () => {\r\n    if (_isServer === undefined) {\r\n        /* istanbul ignore if */\r\n        if (!inBrowser && typeof global !== 'undefined') {\r\n            // detect presence of vue-server-renderer and avoid\r\n            // Webpack shimming the process\r\n            _isServer =\r\n                global['process'] && global['process'].env.VUE_ENV === 'server';\r\n        }\r\n        else {\r\n            _isServer = false;\r\n        }\r\n    }\r\n    return _isServer;\r\n};\r\n// detect devtools\r\nconst devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\r\n/* istanbul ignore next */\r\nfunction isNative(Ctor) {\r\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\r\n}\r\nconst hasSymbol = typeof Symbol !== 'undefined' &&\r\n    isNative(Symbol) &&\r\n    typeof Reflect !== 'undefined' &&\r\n    isNative(Reflect.ownKeys);\r\nlet _Set; // $flow-disable-line\r\n/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {\r\n    // use native Set when available.\r\n    _Set = Set;\r\n}\r\nelse {\r\n    // a non-standard Set polyfill that only works with primitive keys.\r\n    _Set = class Set {\r\n        constructor() {\r\n            this.set = Object.create(null);\r\n        }\r\n        has(key) {\r\n            return this.set[key] === true;\r\n        }\r\n        add(key) {\r\n            this.set[key] = true;\r\n        }\r\n        clear() {\r\n            this.set = Object.create(null);\r\n        }\r\n    };\r\n}\n\nlet currentInstance = null;\r\n/**\r\n * This is exposed for compatibility with v3 (e.g. some functions in VueUse\r\n * relies on it). Do not use this internally, just use `currentInstance`.\r\n *\r\n * @internal this function needs manual type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\r\nfunction getCurrentInstance() {\r\n    return currentInstance && { proxy: currentInstance };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction setCurrentInstance(vm = null) {\r\n    if (!vm)\r\n        currentInstance && currentInstance._scope.off();\r\n    currentInstance = vm;\r\n    vm && vm._scope.on();\r\n}\n\n/**\r\n * @internal\r\n */\r\nclass VNode {\r\n    constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\r\n        this.tag = tag;\r\n        this.data = data;\r\n        this.children = children;\r\n        this.text = text;\r\n        this.elm = elm;\r\n        this.ns = undefined;\r\n        this.context = context;\r\n        this.fnContext = undefined;\r\n        this.fnOptions = undefined;\r\n        this.fnScopeId = undefined;\r\n        this.key = data && data.key;\r\n        this.componentOptions = componentOptions;\r\n        this.componentInstance = undefined;\r\n        this.parent = undefined;\r\n        this.raw = false;\r\n        this.isStatic = false;\r\n        this.isRootInsert = true;\r\n        this.isComment = false;\r\n        this.isCloned = false;\r\n        this.isOnce = false;\r\n        this.asyncFactory = asyncFactory;\r\n        this.asyncMeta = undefined;\r\n        this.isAsyncPlaceholder = false;\r\n    }\r\n    // DEPRECATED: alias for componentInstance for backwards compat.\r\n    /* istanbul ignore next */\r\n    get child() {\r\n        return this.componentInstance;\r\n    }\r\n}\r\nconst createEmptyVNode = (text = '') => {\r\n    const node = new VNode();\r\n    node.text = text;\r\n    node.isComment = true;\r\n    return node;\r\n};\r\nfunction createTextVNode(val) {\r\n    return new VNode(undefined, undefined, undefined, String(val));\r\n}\r\n// optimized shallow clone\r\n// used for static nodes and slot nodes because they may be reused across\r\n// multiple renders, cloning them avoids errors when DOM manipulations rely\r\n// on their elm reference.\r\nfunction cloneVNode(vnode) {\r\n    const cloned = new VNode(vnode.tag, vnode.data, \r\n    // #7975\r\n    // clone children array to avoid mutating original in case of cloning\r\n    // a child.\r\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\r\n    cloned.ns = vnode.ns;\r\n    cloned.isStatic = vnode.isStatic;\r\n    cloned.key = vnode.key;\r\n    cloned.isComment = vnode.isComment;\r\n    cloned.fnContext = vnode.fnContext;\r\n    cloned.fnOptions = vnode.fnOptions;\r\n    cloned.fnScopeId = vnode.fnScopeId;\r\n    cloned.asyncMeta = vnode.asyncMeta;\r\n    cloned.isCloned = true;\r\n    return cloned;\r\n}\n\nlet uid$2 = 0;\r\n/**\r\n * A dep is an observable that can have multiple\r\n * directives subscribing to it.\r\n * @internal\r\n */\r\nclass Dep {\r\n    constructor() {\r\n        this.id = uid$2++;\r\n        this.subs = [];\r\n    }\r\n    addSub(sub) {\r\n        this.subs.push(sub);\r\n    }\r\n    removeSub(sub) {\r\n        remove$2(this.subs, sub);\r\n    }\r\n    depend(info) {\r\n        if (Dep.target) {\r\n            Dep.target.addDep(this);\r\n            if (info && Dep.target.onTrack) {\r\n                Dep.target.onTrack(Object.assign({ effect: Dep.target }, info));\r\n            }\r\n        }\r\n    }\r\n    notify(info) {\r\n        // stabilize the subscriber list first\r\n        const subs = this.subs.slice();\r\n        if (!config.async) {\r\n            // subs aren't sorted in scheduler if not running async\r\n            // we need to sort them now to make sure they fire in correct\r\n            // order\r\n            subs.sort((a, b) => a.id - b.id);\r\n        }\r\n        for (let i = 0, l = subs.length; i < l; i++) {\r\n            if (info) {\r\n                const sub = subs[i];\r\n                sub.onTrigger &&\r\n                    sub.onTrigger(Object.assign({ effect: subs[i] }, info));\r\n            }\r\n            subs[i].update();\r\n        }\r\n    }\r\n}\r\n// The current target watcher being evaluated.\r\n// This is globally unique because only one watcher\r\n// can be evaluated at a time.\r\nDep.target = null;\r\nconst targetStack = [];\r\nfunction pushTarget(target) {\r\n    targetStack.push(target);\r\n    Dep.target = target;\r\n}\r\nfunction popTarget() {\r\n    targetStack.pop();\r\n    Dep.target = targetStack[targetStack.length - 1];\r\n}\n\n/*\r\n * not type checking this file because flow doesn't play well with\r\n * dynamically accessing methods on Array prototype\r\n */\r\nconst arrayProto = Array.prototype;\r\nconst arrayMethods = Object.create(arrayProto);\r\nconst methodsToPatch = [\r\n    'push',\r\n    'pop',\r\n    'shift',\r\n    'unshift',\r\n    'splice',\r\n    'sort',\r\n    'reverse'\r\n];\r\n/**\r\n * Intercept mutating methods and emit events\r\n */\r\nmethodsToPatch.forEach(function (method) {\r\n    // cache original method\r\n    const original = arrayProto[method];\r\n    def(arrayMethods, method, function mutator(...args) {\r\n        const result = original.apply(this, args);\r\n        const ob = this.__ob__;\r\n        let inserted;\r\n        switch (method) {\r\n            case 'push':\r\n            case 'unshift':\r\n                inserted = args;\r\n                break;\r\n            case 'splice':\r\n                inserted = args.slice(2);\r\n                break;\r\n        }\r\n        if (inserted)\r\n            ob.observeArray(inserted);\r\n        // notify change\r\n        {\r\n            ob.dep.notify({\r\n                type: \"array mutation\" /* TriggerOpTypes.ARRAY_MUTATION */,\r\n                target: this,\r\n                key: method\r\n            });\r\n        }\r\n        return result;\r\n    });\r\n});\n\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods);\r\nconst NO_INIITIAL_VALUE = {};\r\n/**\r\n * In some cases we may want to disable observation inside a component's\r\n * update computation.\r\n */\r\nlet shouldObserve = true;\r\nfunction toggleObserving(value) {\r\n    shouldObserve = value;\r\n}\r\n// ssr mock dep\r\nconst mockDep = {\r\n    notify: noop,\r\n    depend: noop,\r\n    addSub: noop,\r\n    removeSub: noop\r\n};\r\n/**\r\n * Observer class that is attached to each observed\r\n * object. Once attached, the observer converts the target\r\n * object's property keys into getter/setters that\r\n * collect dependencies and dispatch updates.\r\n */\r\nclass Observer {\r\n    constructor(value, shallow = false, mock = false) {\r\n        this.value = value;\r\n        this.shallow = shallow;\r\n        this.mock = mock;\r\n        // this.value = value\r\n        this.dep = mock ? mockDep : new Dep();\r\n        this.vmCount = 0;\r\n        def(value, '__ob__', this);\r\n        if (isArray(value)) {\r\n            if (!mock) {\r\n                if (hasProto) {\r\n                    value.__proto__ = arrayMethods;\r\n                    /* eslint-enable no-proto */\r\n                }\r\n                else {\r\n                    for (let i = 0, l = arrayKeys.length; i < l; i++) {\r\n                        const key = arrayKeys[i];\r\n                        def(value, key, arrayMethods[key]);\r\n                    }\r\n                }\r\n            }\r\n            if (!shallow) {\r\n                this.observeArray(value);\r\n            }\r\n        }\r\n        else {\r\n            /**\r\n             * Walk through all properties and convert them into\r\n             * getter/setters. This method should only be called when\r\n             * value type is Object.\r\n             */\r\n            const keys = Object.keys(value);\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key = keys[i];\r\n                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Observe a list of Array items.\r\n     */\r\n    observeArray(value) {\r\n        for (let i = 0, l = value.length; i < l; i++) {\r\n            observe(value[i], false, this.mock);\r\n        }\r\n    }\r\n}\r\n// helpers\r\n/**\r\n * Attempt to create an observer instance for a value,\r\n * returns the new observer if successfully observed,\r\n * or the existing observer if the value already has one.\r\n */\r\nfunction observe(value, shallow, ssrMockReactivity) {\r\n    if (!isObject(value) || isRef(value) || value instanceof VNode) {\r\n        return;\r\n    }\r\n    let ob;\r\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\r\n        ob = value.__ob__;\r\n    }\r\n    else if (shouldObserve &&\r\n        (ssrMockReactivity || !isServerRendering()) &&\r\n        (isArray(value) || isPlainObject(value)) &&\r\n        Object.isExtensible(value) &&\r\n        !value.__v_skip /* ReactiveFlags.SKIP */) {\r\n        ob = new Observer(value, shallow, ssrMockReactivity);\r\n    }\r\n    return ob;\r\n}\r\n/**\r\n * Define a reactive property on an Object.\r\n */\r\nfunction defineReactive(obj, key, val, customSetter, shallow, mock) {\r\n    const dep = new Dep();\r\n    const property = Object.getOwnPropertyDescriptor(obj, key);\r\n    if (property && property.configurable === false) {\r\n        return;\r\n    }\r\n    // cater for pre-defined getter/setters\r\n    const getter = property && property.get;\r\n    const setter = property && property.set;\r\n    if ((!getter || setter) &&\r\n        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {\r\n        val = obj[key];\r\n    }\r\n    let childOb = !shallow && observe(val, false, mock);\r\n    Object.defineProperty(obj, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function reactiveGetter() {\r\n            const value = getter ? getter.call(obj) : val;\r\n            if (Dep.target) {\r\n                {\r\n                    dep.depend({\r\n                        target: obj,\r\n                        type: \"get\" /* TrackOpTypes.GET */,\r\n                        key\r\n                    });\r\n                }\r\n                if (childOb) {\r\n                    childOb.dep.depend();\r\n                    if (isArray(value)) {\r\n                        dependArray(value);\r\n                    }\r\n                }\r\n            }\r\n            return isRef(value) && !shallow ? value.value : value;\r\n        },\r\n        set: function reactiveSetter(newVal) {\r\n            const value = getter ? getter.call(obj) : val;\r\n            if (!hasChanged(value, newVal)) {\r\n                return;\r\n            }\r\n            if (customSetter) {\r\n                customSetter();\r\n            }\r\n            if (setter) {\r\n                setter.call(obj, newVal);\r\n            }\r\n            else if (getter) {\r\n                // #7981: for accessor properties without setter\r\n                return;\r\n            }\r\n            else if (!shallow && isRef(value) && !isRef(newVal)) {\r\n                value.value = newVal;\r\n                return;\r\n            }\r\n            else {\r\n                val = newVal;\r\n            }\r\n            childOb = !shallow && observe(newVal, false, mock);\r\n            {\r\n                dep.notify({\r\n                    type: \"set\" /* TriggerOpTypes.SET */,\r\n                    target: obj,\r\n                    key,\r\n                    newValue: newVal,\r\n                    oldValue: value\r\n                });\r\n            }\r\n        }\r\n    });\r\n    return dep;\r\n}\r\nfunction set(target, key, val) {\r\n    if ((isUndef(target) || isPrimitive(target))) {\r\n        warn(`Cannot set reactive property on undefined, null, or primitive value: ${target}`);\r\n    }\r\n    if (isReadonly(target)) {\r\n        warn(`Set operation on key \"${key}\" failed: target is readonly.`);\r\n        return;\r\n    }\r\n    const ob = target.__ob__;\r\n    if (isArray(target) && isValidArrayIndex(key)) {\r\n        target.length = Math.max(target.length, key);\r\n        target.splice(key, 1, val);\r\n        // when mocking for SSR, array methods are not hijacked\r\n        if (ob && !ob.shallow && ob.mock) {\r\n            observe(val, false, true);\r\n        }\r\n        return val;\r\n    }\r\n    if (key in target && !(key in Object.prototype)) {\r\n        target[key] = val;\r\n        return val;\r\n    }\r\n    if (target._isVue || (ob && ob.vmCount)) {\r\n        warn('Avoid adding reactive properties to a Vue instance or its root $data ' +\r\n                'at runtime - declare it upfront in the data option.');\r\n        return val;\r\n    }\r\n    if (!ob) {\r\n        target[key] = val;\r\n        return val;\r\n    }\r\n    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);\r\n    {\r\n        ob.dep.notify({\r\n            type: \"add\" /* TriggerOpTypes.ADD */,\r\n            target: target,\r\n            key,\r\n            newValue: val,\r\n            oldValue: undefined\r\n        });\r\n    }\r\n    return val;\r\n}\r\nfunction del(target, key) {\r\n    if ((isUndef(target) || isPrimitive(target))) {\r\n        warn(`Cannot delete reactive property on undefined, null, or primitive value: ${target}`);\r\n    }\r\n    if (isArray(target) && isValidArrayIndex(key)) {\r\n        target.splice(key, 1);\r\n        return;\r\n    }\r\n    const ob = target.__ob__;\r\n    if (target._isVue || (ob && ob.vmCount)) {\r\n        warn('Avoid deleting properties on a Vue instance or its root $data ' +\r\n                '- just set it to null.');\r\n        return;\r\n    }\r\n    if (isReadonly(target)) {\r\n        warn(`Delete operation on key \"${key}\" failed: target is readonly.`);\r\n        return;\r\n    }\r\n    if (!hasOwn(target, key)) {\r\n        return;\r\n    }\r\n    delete target[key];\r\n    if (!ob) {\r\n        return;\r\n    }\r\n    {\r\n        ob.dep.notify({\r\n            type: \"delete\" /* TriggerOpTypes.DELETE */,\r\n            target: target,\r\n            key\r\n        });\r\n    }\r\n}\r\n/**\r\n * Collect dependencies on array elements when the array is touched, since\r\n * we cannot intercept array element access like property getters.\r\n */\r\nfunction dependArray(value) {\r\n    for (let e, i = 0, l = value.length; i < l; i++) {\r\n        e = value[i];\r\n        if (e && e.__ob__) {\r\n            e.__ob__.dep.depend();\r\n        }\r\n        if (isArray(e)) {\r\n            dependArray(e);\r\n        }\r\n    }\r\n}\n\nfunction reactive(target) {\r\n    makeReactive(target, false);\r\n    return target;\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    makeReactive(target, true);\r\n    def(target, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\r\n    return target;\r\n}\r\nfunction makeReactive(target, shallow) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (!isReadonly(target)) {\r\n        {\r\n            if (isArray(target)) {\r\n                warn(`Avoid using Array as root value for ${shallow ? `shallowReactive()` : `reactive()`} as it cannot be tracked in watch() or watchEffect(). Use ${shallow ? `shallowRef()` : `ref()`} instead. This is a Vue-2-only limitation.`);\r\n            }\r\n            const existingOb = target && target.__ob__;\r\n            if (existingOb && existingOb.shallow !== shallow) {\r\n                warn(`Target is already a ${existingOb.shallow ? `` : `non-`}shallow reactive object, and cannot be converted to ${shallow ? `` : `non-`}shallow.`);\r\n            }\r\n        }\r\n        const ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);\r\n        if (!ob) {\r\n            if (target == null || isPrimitive(target)) {\r\n                warn(`value cannot be made reactive: ${String(target)}`);\r\n            }\r\n            if (isCollectionType(target)) {\r\n                warn(`Vue 2 does not support reactive collection types such as Map or Set.`);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\r\n    }\r\n    return !!(value && value.__ob__);\r\n}\r\nfunction isShallow(value) {\r\n    return !!(value && value.__v_isShallow);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value.__v_isReadonly);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\r\n    return value;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction isCollectionType(value) {\r\n    const type = toRawType(value);\r\n    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');\r\n}\n\n/**\r\n * @internal\r\n */\r\nconst RefFlag = `__v_isRef`;\r\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\r\nfunction ref$1(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    const ref = {};\r\n    def(ref, RefFlag, true);\r\n    def(ref, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, shallow);\r\n    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));\r\n    return ref;\r\n}\r\nfunction triggerRef(ref) {\r\n    if (!ref.dep) {\r\n        warn(`received object is not a triggerable ref.`);\r\n    }\r\n    {\r\n        ref.dep &&\r\n            ref.dep.notify({\r\n                type: \"set\" /* TriggerOpTypes.SET */,\r\n                target: ref,\r\n                key: 'value'\r\n            });\r\n    }\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nfunction proxyRefs(objectWithRefs) {\r\n    if (isReactive(objectWithRefs)) {\r\n        return objectWithRefs;\r\n    }\r\n    const proxy = {};\r\n    const keys = Object.keys(objectWithRefs);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);\r\n    }\r\n    return proxy;\r\n}\r\nfunction proxyWithRefUnwrap(target, source, key) {\r\n    Object.defineProperty(target, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => {\r\n            const val = source[key];\r\n            if (isRef(val)) {\r\n                return val.value;\r\n            }\r\n            else {\r\n                const ob = val && val.__ob__;\r\n                if (ob)\r\n                    ob.dep.depend();\r\n                return val;\r\n            }\r\n        },\r\n        set: value => {\r\n            const oldValue = source[key];\r\n            if (isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n            }\r\n            else {\r\n                source[key] = value;\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction customRef(factory) {\r\n    const dep = new Dep();\r\n    const { get, set } = factory(() => {\r\n        {\r\n            dep.depend({\r\n                target: ref,\r\n                type: \"get\" /* TrackOpTypes.GET */,\r\n                key: 'value'\r\n            });\r\n        }\r\n    }, () => {\r\n        {\r\n            dep.notify({\r\n                target: ref,\r\n                type: \"set\" /* TriggerOpTypes.SET */,\r\n                key: 'value'\r\n            });\r\n        }\r\n    });\r\n    const ref = {\r\n        get value() {\r\n            return get();\r\n        },\r\n        set value(newVal) {\r\n            set(newVal);\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    return ref;\r\n}\r\nfunction toRefs(object) {\r\n    if (!isReactive(object)) {\r\n        warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    const val = object[key];\r\n    if (isRef(val)) {\r\n        return val;\r\n    }\r\n    const ref = {\r\n        get value() {\r\n            const val = object[key];\r\n            return val === undefined ? defaultValue : val;\r\n        },\r\n        set value(newVal) {\r\n            object[key] = newVal;\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    return ref;\r\n}\n\nconst rawToReadonlyFlag = `__v_rawToReadonly`;\r\nconst rawToShallowReadonlyFlag = `__v_rawToShallowReadonly`;\r\nfunction readonly(target) {\r\n    return createReadonly(target, false);\r\n}\r\nfunction createReadonly(target, shallow) {\r\n    if (!isPlainObject(target)) {\r\n        {\r\n            if (isArray(target)) {\r\n                warn(`Vue 2 does not support readonly arrays.`);\r\n            }\r\n            else if (isCollectionType(target)) {\r\n                warn(`Vue 2 does not support readonly collection types such as Map or Set.`);\r\n            }\r\n            else {\r\n                warn(`value cannot be made readonly: ${typeof target}`);\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    // already a readonly object\r\n    if (isReadonly(target)) {\r\n        return target;\r\n    }\r\n    // already has a readonly proxy\r\n    const existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;\r\n    const existingProxy = target[existingFlag];\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    const proxy = Object.create(Object.getPrototypeOf(target));\r\n    def(target, existingFlag, proxy);\r\n    def(proxy, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, true);\r\n    def(proxy, \"__v_raw\" /* ReactiveFlags.RAW */, target);\r\n    if (isRef(target)) {\r\n        def(proxy, RefFlag, true);\r\n    }\r\n    if (shallow || isShallow(target)) {\r\n        def(proxy, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\r\n    }\r\n    const keys = Object.keys(target);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        defineReadonlyProperty(proxy, target, keys[i], shallow);\r\n    }\r\n    return proxy;\r\n}\r\nfunction defineReadonlyProperty(proxy, target, key, shallow) {\r\n    Object.defineProperty(proxy, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get() {\r\n            const val = target[key];\r\n            return shallow || !isPlainObject(val) ? val : readonly(val);\r\n        },\r\n        set() {\r\n            warn(`Set operation on key \"${key}\" failed: target is readonly.`);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReadonly(target, true);\r\n}\n\nfunction computed(getterOrOptions, debugOptions) {\r\n    let getter;\r\n    let setter;\r\n    const onlyGetter = isFunction(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter = () => {\r\n                warn('Write operation failed: computed value is readonly');\r\n            }\r\n            ;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    const watcher = isServerRendering()\r\n        ? null\r\n        : new Watcher(currentInstance, getter, noop, { lazy: true });\r\n    if (watcher && debugOptions) {\r\n        watcher.onTrack = debugOptions.onTrack;\r\n        watcher.onTrigger = debugOptions.onTrigger;\r\n    }\r\n    const ref = {\r\n        // some libs rely on the presence effect for checking computed refs\r\n        // from normal refs, but the implementation doesn't matter\r\n        effect: watcher,\r\n        get value() {\r\n            if (watcher) {\r\n                if (watcher.dirty) {\r\n                    watcher.evaluate();\r\n                }\r\n                if (Dep.target) {\r\n                    if (Dep.target.onTrack) {\r\n                        Dep.target.onTrack({\r\n                            effect: Dep.target,\r\n                            target: ref,\r\n                            type: \"get\" /* TrackOpTypes.GET */,\r\n                            key: 'value'\r\n                        });\r\n                    }\r\n                    watcher.depend();\r\n                }\r\n                return watcher.value;\r\n            }\r\n            else {\r\n                return getter();\r\n            }\r\n        },\r\n        set value(newVal) {\r\n            setter(newVal);\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    def(ref, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, onlyGetter);\r\n    return ref;\r\n}\n\nconst WATCHER = `watcher`;\r\nconst WATCHER_CB = `${WATCHER} callback`;\r\nconst WATCHER_GETTER = `${WATCHER} getter`;\r\nconst WATCHER_CLEANUP = `${WATCHER} cleanup`;\r\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\nfunction watchPostEffect(effect, options) {\r\n    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'post' }) ));\r\n}\r\nfunction watchSyncEffect(effect, options) {\r\n    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'sync' }) ));\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if (typeof cb !== 'function') {\r\n        warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\r\n            `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\r\n            `supports \\`watch(source, cb, options?) signature.`);\r\n    }\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, { immediate, deep, flush = 'pre', onTrack, onTrigger } = emptyObject) {\r\n    if (!cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: ${s}. A watch source can only be a getter/effect ` +\r\n            `function, a ref, a reactive object, or an array of these types.`);\r\n    };\r\n    const instance = currentInstance;\r\n    const call = (fn, type, args = null) => invokeWithErrorHandling(fn, null, args, instance, type);\r\n    let getter;\r\n    let forceTrigger = false;\r\n    let isMultiSource = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = isShallow(source);\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => {\r\n            source.__ob__.dep.depend();\r\n            return source;\r\n        };\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        isMultiSource = true;\r\n        forceTrigger = source.some(s => isReactive(s) || isShallow(s));\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return call(s, WATCHER_GETTER);\r\n            }\r\n            else {\r\n                warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => call(source, WATCHER_GETTER);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance._isDestroyed) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return call(source, WATCHER, [onCleanup]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = noop;\r\n        warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    let onCleanup = (fn) => {\r\n        cleanup = watcher.onStop = () => {\r\n            call(fn, WATCHER_CLEANUP);\r\n        };\r\n    };\r\n    // in SSR there is no need to setup an actual effect, and it should be noop\r\n    // unless it's eager\r\n    if (isServerRendering()) {\r\n        // we will also not call the invalidate callback (+ runner is not set up)\r\n        onCleanup = noop;\r\n        if (!cb) {\r\n            getter();\r\n        }\r\n        else if (immediate) {\r\n            call(cb, WATCHER_CB, [\r\n                getter(),\r\n                isMultiSource ? [] : undefined,\r\n                onCleanup\r\n            ]);\r\n        }\r\n        return noop;\r\n    }\r\n    const watcher = new Watcher(currentInstance, getter, noop, {\r\n        lazy: true\r\n    });\r\n    watcher.noRecurse = !cb;\r\n    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\r\n    // overwrite default run\r\n    watcher.run = () => {\r\n        if (!watcher.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = watcher.get();\r\n            if (deep ||\r\n                forceTrigger ||\r\n                (isMultiSource\r\n                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))\r\n                    : hasChanged(newValue, oldValue))) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                call(cb, WATCHER_CB, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onCleanup\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            watcher.get();\r\n        }\r\n    };\r\n    if (flush === 'sync') {\r\n        watcher.update = watcher.run;\r\n    }\r\n    else if (flush === 'post') {\r\n        watcher.post = true;\r\n        watcher.update = () => queueWatcher(watcher);\r\n    }\r\n    else {\r\n        // pre\r\n        watcher.update = () => {\r\n            if (instance && instance === currentInstance && !instance._isMounted) {\r\n                // pre-watcher triggered before\r\n                const buffer = instance._preWatchers || (instance._preWatchers = []);\r\n                if (buffer.indexOf(watcher) < 0)\r\n                    buffer.push(watcher);\r\n            }\r\n            else {\r\n                queueWatcher(watcher);\r\n            }\r\n        };\r\n    }\r\n    {\r\n        watcher.onTrack = onTrack;\r\n        watcher.onTrigger = onTrigger;\r\n    }\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            watcher.run();\r\n        }\r\n        else {\r\n            oldValue = watcher.get();\r\n        }\r\n    }\r\n    else if (flush === 'post' && instance) {\r\n        instance.$once('hook:mounted', () => watcher.get());\r\n    }\r\n    else {\r\n        watcher.get();\r\n    }\r\n    return () => {\r\n        watcher.teardown();\r\n    };\r\n}\n\nlet activeEffectScope;\r\nclass EffectScope {\r\n    constructor(detached = false) {\r\n        /**\r\n         * @internal\r\n         */\r\n        this.active = true;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.effects = [];\r\n        /**\r\n         * @internal\r\n         */\r\n        this.cleanups = [];\r\n        if (!detached && activeEffectScope) {\r\n            this.parent = activeEffectScope;\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    run(fn) {\r\n        if (this.active) {\r\n            const currentEffectScope = activeEffectScope;\r\n            try {\r\n                activeEffectScope = this;\r\n                return fn();\r\n            }\r\n            finally {\r\n                activeEffectScope = currentEffectScope;\r\n            }\r\n        }\r\n        else {\r\n            warn(`cannot run an inactive effect scope.`);\r\n        }\r\n    }\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    on() {\r\n        activeEffectScope = this;\r\n    }\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    off() {\r\n        activeEffectScope = this.parent;\r\n    }\r\n    stop(fromParent) {\r\n        if (this.active) {\r\n            let i, l;\r\n            for (i = 0, l = this.effects.length; i < l; i++) {\r\n                this.effects[i].teardown();\r\n            }\r\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n                this.cleanups[i]();\r\n            }\r\n            if (this.scopes) {\r\n                for (i = 0, l = this.scopes.length; i < l; i++) {\r\n                    this.scopes[i].stop(true);\r\n                }\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                const last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction recordEffectScope(effect, scope = activeEffectScope) {\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else {\r\n        warn(`onScopeDispose() is called when there is no active effect scope` +\r\n            ` to be associated with.`);\r\n    }\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        {\r\n            warn(`provide() can only be used inside setup().`);\r\n        }\r\n    }\r\n    else {\r\n        // TS doesn't allow symbol as index type\r\n        resolveProvided(currentInstance)[key] = value;\r\n    }\r\n}\r\nfunction resolveProvided(vm) {\r\n    // by default an instance inherits its parent's provides object\r\n    // but when it needs to provide values of its own, it creates its\r\n    // own provides object using parent provides object as prototype.\r\n    // this way in `inject` we can simply look up injections from direct\r\n    // parent and let the prototype chain do the work.\r\n    const existing = vm._provided;\r\n    const parentProvides = vm.$parent && vm.$parent._provided;\r\n    if (parentProvides === existing) {\r\n        return (vm._provided = Object.create(parentProvides));\r\n    }\r\n    else {\r\n        return existing;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    const instance = currentInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext's `provides` if the instance is at root\r\n        const provides = instance.$parent && instance.$parent._provided;\r\n        if (provides && key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && isFunction(defaultValue)\r\n                ? defaultValue.call(instance)\r\n                : defaultValue;\r\n        }\r\n        else {\r\n            warn(`injection \"${String(key)}\" not found.`);\r\n        }\r\n    }\r\n    else {\r\n        warn(`inject() can only be used inside setup() or functional components.`);\r\n    }\r\n}\n\nconst normalizeEvent = cached((name) => {\r\n    const passive = name.charAt(0) === '&';\r\n    name = passive ? name.slice(1) : name;\r\n    const once = name.charAt(0) === '~'; // Prefixed last, checked first\r\n    name = once ? name.slice(1) : name;\r\n    const capture = name.charAt(0) === '!';\r\n    name = capture ? name.slice(1) : name;\r\n    return {\r\n        name,\r\n        once,\r\n        capture,\r\n        passive\r\n    };\r\n});\r\nfunction createFnInvoker(fns, vm) {\r\n    function invoker() {\r\n        const fns = invoker.fns;\r\n        if (isArray(fns)) {\r\n            const cloned = fns.slice();\r\n            for (let i = 0; i < cloned.length; i++) {\r\n                invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`);\r\n            }\r\n        }\r\n        else {\r\n            // return handler return value for single handlers\r\n            return invokeWithErrorHandling(fns, null, arguments, vm, `v-on handler`);\r\n        }\r\n    }\r\n    invoker.fns = fns;\r\n    return invoker;\r\n}\r\nfunction updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {\r\n    let name, cur, old, event;\r\n    for (name in on) {\r\n        cur = on[name];\r\n        old = oldOn[name];\r\n        event = normalizeEvent(name);\r\n        if (isUndef(cur)) {\r\n            warn(`Invalid handler for event \"${event.name}\": got ` + String(cur), vm);\r\n        }\r\n        else if (isUndef(old)) {\r\n            if (isUndef(cur.fns)) {\r\n                cur = on[name] = createFnInvoker(cur, vm);\r\n            }\r\n            if (isTrue(event.once)) {\r\n                cur = on[name] = createOnceHandler(event.name, cur, event.capture);\r\n            }\r\n            add(event.name, cur, event.capture, event.passive, event.params);\r\n        }\r\n        else if (cur !== old) {\r\n            old.fns = cur;\r\n            on[name] = old;\r\n        }\r\n    }\r\n    for (name in oldOn) {\r\n        if (isUndef(on[name])) {\r\n            event = normalizeEvent(name);\r\n            remove(event.name, oldOn[name], event.capture);\r\n        }\r\n    }\r\n}\n\nfunction mergeVNodeHook(def, hookKey, hook) {\r\n    if (def instanceof VNode) {\r\n        def = def.data.hook || (def.data.hook = {});\r\n    }\r\n    let invoker;\r\n    const oldHook = def[hookKey];\r\n    function wrappedHook() {\r\n        hook.apply(this, arguments);\r\n        // important: remove merged hook to ensure it's called only once\r\n        // and prevent memory leak\r\n        remove$2(invoker.fns, wrappedHook);\r\n    }\r\n    if (isUndef(oldHook)) {\r\n        // no existing hook\r\n        invoker = createFnInvoker([wrappedHook]);\r\n    }\r\n    else {\r\n        /* istanbul ignore if */\r\n        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\r\n            // already a merged invoker\r\n            invoker = oldHook;\r\n            invoker.fns.push(wrappedHook);\r\n        }\r\n        else {\r\n            // existing plain hook\r\n            invoker = createFnInvoker([oldHook, wrappedHook]);\r\n        }\r\n    }\r\n    invoker.merged = true;\r\n    def[hookKey] = invoker;\r\n}\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\r\n    // we are only extracting raw values here.\r\n    // validation and default values are handled in the child\r\n    // component itself.\r\n    const propOptions = Ctor.options.props;\r\n    if (isUndef(propOptions)) {\r\n        return;\r\n    }\r\n    const res = {};\r\n    const { attrs, props } = data;\r\n    if (isDef(attrs) || isDef(props)) {\r\n        for (const key in propOptions) {\r\n            const altKey = hyphenate(key);\r\n            {\r\n                const keyInLowerCase = key.toLowerCase();\r\n                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\r\n                    tip(`Prop \"${keyInLowerCase}\" is passed to component ` +\r\n                        `${formatComponentName(\r\n                        // @ts-expect-error tag is string\r\n                        tag || Ctor)}, but the declared prop name is` +\r\n                        ` \"${key}\". ` +\r\n                        `Note that HTML attributes are case-insensitive and camelCased ` +\r\n                        `props need to use their kebab-case equivalents when using in-DOM ` +\r\n                        `templates. You should probably use \"${altKey}\" instead of \"${key}\".`);\r\n                }\r\n            }\r\n            checkProp(res, props, key, altKey, true) ||\r\n                checkProp(res, attrs, key, altKey, false);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction checkProp(res, hash, key, altKey, preserve) {\r\n    if (isDef(hash)) {\r\n        if (hasOwn(hash, key)) {\r\n            res[key] = hash[key];\r\n            if (!preserve) {\r\n                delete hash[key];\r\n            }\r\n            return true;\r\n        }\r\n        else if (hasOwn(hash, altKey)) {\r\n            res[key] = hash[altKey];\r\n            if (!preserve) {\r\n                delete hash[altKey];\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n// The template compiler attempts to minimize the need for normalization by\r\n// statically analyzing the template at compile time.\r\n//\r\n// For plain HTML markup, normalization can be completely skipped because the\r\n// generated render function is guaranteed to return Array<VNode>. There are\r\n// two cases where extra normalization is needed:\r\n// 1. When the children contains components - because a functional component\r\n// may return an Array instead of a single root. In this case, just a simple\r\n// normalization is needed - if any child is an Array, we flatten the whole\r\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\r\n// because functional components already normalize their own children.\r\nfunction simpleNormalizeChildren(children) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        if (isArray(children[i])) {\r\n            return Array.prototype.concat.apply([], children);\r\n        }\r\n    }\r\n    return children;\r\n}\r\n// 2. When the children contains constructs that always generated nested Arrays,\r\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\r\n// with hand-written render functions / JSX. In such cases a full normalization\r\n// is needed to cater to all possible types of children values.\r\nfunction normalizeChildren(children) {\r\n    return isPrimitive(children)\r\n        ? [createTextVNode(children)]\r\n        : isArray(children)\r\n            ? normalizeArrayChildren(children)\r\n            : undefined;\r\n}\r\nfunction isTextNode(node) {\r\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\r\n}\r\nfunction normalizeArrayChildren(children, nestedIndex) {\r\n    const res = [];\r\n    let i, c, lastIndex, last;\r\n    for (i = 0; i < children.length; i++) {\r\n        c = children[i];\r\n        if (isUndef(c) || typeof c === 'boolean')\r\n            continue;\r\n        lastIndex = res.length - 1;\r\n        last = res[lastIndex];\r\n        //  nested\r\n        if (isArray(c)) {\r\n            if (c.length > 0) {\r\n                c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`);\r\n                // merge adjacent text nodes\r\n                if (isTextNode(c[0]) && isTextNode(last)) {\r\n                    res[lastIndex] = createTextVNode(last.text + c[0].text);\r\n                    c.shift();\r\n                }\r\n                res.push.apply(res, c);\r\n            }\r\n        }\r\n        else if (isPrimitive(c)) {\r\n            if (isTextNode(last)) {\r\n                // merge adjacent text nodes\r\n                // this is necessary for SSR hydration because text nodes are\r\n                // essentially merged when rendered to HTML strings\r\n                res[lastIndex] = createTextVNode(last.text + c);\r\n            }\r\n            else if (c !== '') {\r\n                // convert primitive to vnode\r\n                res.push(createTextVNode(c));\r\n            }\r\n        }\r\n        else {\r\n            if (isTextNode(c) && isTextNode(last)) {\r\n                // merge adjacent text nodes\r\n                res[lastIndex] = createTextVNode(last.text + c.text);\r\n            }\r\n            else {\r\n                // default key for nested array children (likely generated by v-for)\r\n                if (isTrue(children._isVList) &&\r\n                    isDef(c.tag) &&\r\n                    isUndef(c.key) &&\r\n                    isDef(nestedIndex)) {\r\n                    c.key = `__vlist${nestedIndex}_${i}__`;\r\n                }\r\n                res.push(c);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\n\n/**\r\n * Runtime helper for rendering v-for lists.\r\n */\r\nfunction renderList(val, render) {\r\n    let ret = null, i, l, keys, key;\r\n    if (isArray(val) || typeof val === 'string') {\r\n        ret = new Array(val.length);\r\n        for (i = 0, l = val.length; i < l; i++) {\r\n            ret[i] = render(val[i], i);\r\n        }\r\n    }\r\n    else if (typeof val === 'number') {\r\n        ret = new Array(val);\r\n        for (i = 0; i < val; i++) {\r\n            ret[i] = render(i + 1, i);\r\n        }\r\n    }\r\n    else if (isObject(val)) {\r\n        if (hasSymbol && val[Symbol.iterator]) {\r\n            ret = [];\r\n            const iterator = val[Symbol.iterator]();\r\n            let result = iterator.next();\r\n            while (!result.done) {\r\n                ret.push(render(result.value, ret.length));\r\n                result = iterator.next();\r\n            }\r\n        }\r\n        else {\r\n            keys = Object.keys(val);\r\n            ret = new Array(keys.length);\r\n            for (i = 0, l = keys.length; i < l; i++) {\r\n                key = keys[i];\r\n                ret[i] = render(val[key], key, i);\r\n            }\r\n        }\r\n    }\r\n    if (!isDef(ret)) {\r\n        ret = [];\r\n    }\r\n    ret._isVList = true;\r\n    return ret;\r\n}\n\n/**\r\n * Runtime helper for rendering <slot>\r\n */\r\nfunction renderSlot(name, fallbackRender, props, bindObject) {\r\n    const scopedSlotFn = this.$scopedSlots[name];\r\n    let nodes;\r\n    if (scopedSlotFn) {\r\n        // scoped slot\r\n        props = props || {};\r\n        if (bindObject) {\r\n            if (!isObject(bindObject)) {\r\n                warn('slot v-bind without argument expects an Object', this);\r\n            }\r\n            props = extend(extend({}, bindObject), props);\r\n        }\r\n        nodes =\r\n            scopedSlotFn(props) ||\r\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\r\n    }\r\n    else {\r\n        nodes =\r\n            this.$slots[name] ||\r\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\r\n    }\r\n    const target = props && props.slot;\r\n    if (target) {\r\n        return this.$createElement('template', { slot: target }, nodes);\r\n    }\r\n    else {\r\n        return nodes;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for resolving filters\r\n */\r\nfunction resolveFilter(id) {\r\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\r\n}\n\nfunction isKeyNotMatch(expect, actual) {\r\n    if (isArray(expect)) {\r\n        return expect.indexOf(actual) === -1;\r\n    }\r\n    else {\r\n        return expect !== actual;\r\n    }\r\n}\r\n/**\r\n * Runtime helper for checking keyCodes from config.\r\n * exposed as Vue.prototype._k\r\n * passing in eventKeyName as last argument separately for backwards compat\r\n */\r\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\r\n    const mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\r\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\r\n        return isKeyNotMatch(builtInKeyName, eventKeyName);\r\n    }\r\n    else if (mappedKeyCode) {\r\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode);\r\n    }\r\n    else if (eventKeyName) {\r\n        return hyphenate(eventKeyName) !== key;\r\n    }\r\n    return eventKeyCode === undefined;\r\n}\n\n/**\r\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\r\n */\r\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\r\n    if (value) {\r\n        if (!isObject(value)) {\r\n            warn('v-bind without argument expects an Object or Array value', this);\r\n        }\r\n        else {\r\n            if (isArray(value)) {\r\n                value = toObject(value);\r\n            }\r\n            let hash;\r\n            for (const key in value) {\r\n                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\r\n                    hash = data;\r\n                }\r\n                else {\r\n                    const type = data.attrs && data.attrs.type;\r\n                    hash =\r\n                        asProp || config.mustUseProp(tag, type, key)\r\n                            ? data.domProps || (data.domProps = {})\r\n                            : data.attrs || (data.attrs = {});\r\n                }\r\n                const camelizedKey = camelize(key);\r\n                const hyphenatedKey = hyphenate(key);\r\n                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\r\n                    hash[key] = value[key];\r\n                    if (isSync) {\r\n                        const on = data.on || (data.on = {});\r\n                        on[`update:${key}`] = function ($event) {\r\n                            value[key] = $event;\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\n\n/**\r\n * Runtime helper for rendering static trees.\r\n */\r\nfunction renderStatic(index, isInFor) {\r\n    const cached = this._staticTrees || (this._staticTrees = []);\r\n    let tree = cached[index];\r\n    // if has already-rendered static tree and not inside v-for,\r\n    // we can reuse the same tree.\r\n    if (tree && !isInFor) {\r\n        return tree;\r\n    }\r\n    // otherwise, render a fresh tree.\r\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates\r\n    );\r\n    markStatic(tree, `__static__${index}`, false);\r\n    return tree;\r\n}\r\n/**\r\n * Runtime helper for v-once.\r\n * Effectively it means marking the node as static with a unique key.\r\n */\r\nfunction markOnce(tree, index, key) {\r\n    markStatic(tree, `__once__${index}${key ? `_${key}` : ``}`, true);\r\n    return tree;\r\n}\r\nfunction markStatic(tree, key, isOnce) {\r\n    if (isArray(tree)) {\r\n        for (let i = 0; i < tree.length; i++) {\r\n            if (tree[i] && typeof tree[i] !== 'string') {\r\n                markStaticNode(tree[i], `${key}_${i}`, isOnce);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        markStaticNode(tree, key, isOnce);\r\n    }\r\n}\r\nfunction markStaticNode(node, key, isOnce) {\r\n    node.isStatic = true;\r\n    node.key = key;\r\n    node.isOnce = isOnce;\r\n}\n\nfunction bindObjectListeners(data, value) {\r\n    if (value) {\r\n        if (!isPlainObject(value)) {\r\n            warn('v-on without argument expects an Object value', this);\r\n        }\r\n        else {\r\n            const on = (data.on = data.on ? extend({}, data.on) : {});\r\n            for (const key in value) {\r\n                const existing = on[key];\r\n                const ours = value[key];\r\n                on[key] = existing ? [].concat(existing, ours) : ours;\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\n\nfunction resolveScopedSlots(fns, res, \r\n// the following are added in 2.6\r\nhasDynamicKeys, contentHashKey) {\r\n    res = res || { $stable: !hasDynamicKeys };\r\n    for (let i = 0; i < fns.length; i++) {\r\n        const slot = fns[i];\r\n        if (isArray(slot)) {\r\n            resolveScopedSlots(slot, res, hasDynamicKeys);\r\n        }\r\n        else if (slot) {\r\n            // marker for reverse proxying v-slot without scope on this.$slots\r\n            // @ts-expect-error\r\n            if (slot.proxy) {\r\n                // @ts-expect-error\r\n                slot.fn.proxy = true;\r\n            }\r\n            res[slot.key] = slot.fn;\r\n        }\r\n    }\r\n    if (contentHashKey) {\r\n        res.$key = contentHashKey;\r\n    }\r\n    return res;\r\n}\n\n// helper to process dynamic keys for dynamic arguments in v-bind and v-on.\r\nfunction bindDynamicKeys(baseObj, values) {\r\n    for (let i = 0; i < values.length; i += 2) {\r\n        const key = values[i];\r\n        if (typeof key === 'string' && key) {\r\n            baseObj[values[i]] = values[i + 1];\r\n        }\r\n        else if (key !== '' && key !== null) {\r\n            // null is a special value for explicitly removing a binding\r\n            warn(`Invalid value for dynamic directive argument (expected string or null): ${key}`, this);\r\n        }\r\n    }\r\n    return baseObj;\r\n}\r\n// helper to dynamically append modifier runtime markers to event names.\r\n// ensure only append when value is already string, otherwise it will be cast\r\n// to string and cause the type check to miss.\r\nfunction prependModifier(value, symbol) {\r\n    return typeof value === 'string' ? symbol + value : value;\r\n}\n\nfunction installRenderHelpers(target) {\r\n    target._o = markOnce;\r\n    target._n = toNumber;\r\n    target._s = toString;\r\n    target._l = renderList;\r\n    target._t = renderSlot;\r\n    target._q = looseEqual;\r\n    target._i = looseIndexOf;\r\n    target._m = renderStatic;\r\n    target._f = resolveFilter;\r\n    target._k = checkKeyCodes;\r\n    target._b = bindObjectProps;\r\n    target._v = createTextVNode;\r\n    target._e = createEmptyVNode;\r\n    target._u = resolveScopedSlots;\r\n    target._g = bindObjectListeners;\r\n    target._d = bindDynamicKeys;\r\n    target._p = prependModifier;\r\n}\n\n/**\r\n * Runtime helper for resolving raw children VNodes into a slot object.\r\n */\r\nfunction resolveSlots(children, context) {\r\n    if (!children || !children.length) {\r\n        return {};\r\n    }\r\n    const slots = {};\r\n    for (let i = 0, l = children.length; i < l; i++) {\r\n        const child = children[i];\r\n        const data = child.data;\r\n        // remove slot attribute if the node is resolved as a Vue slot node\r\n        if (data && data.attrs && data.attrs.slot) {\r\n            delete data.attrs.slot;\r\n        }\r\n        // named slots should only be respected if the vnode was rendered in the\r\n        // same context.\r\n        if ((child.context === context || child.fnContext === context) &&\r\n            data &&\r\n            data.slot != null) {\r\n            const name = data.slot;\r\n            const slot = slots[name] || (slots[name] = []);\r\n            if (child.tag === 'template') {\r\n                slot.push.apply(slot, child.children || []);\r\n            }\r\n            else {\r\n                slot.push(child);\r\n            }\r\n        }\r\n        else {\r\n            (slots.default || (slots.default = [])).push(child);\r\n        }\r\n    }\r\n    // ignore slots that contains only whitespace\r\n    for (const name in slots) {\r\n        if (slots[name].every(isWhitespace)) {\r\n            delete slots[name];\r\n        }\r\n    }\r\n    return slots;\r\n}\r\nfunction isWhitespace(node) {\r\n    return (node.isComment && !node.asyncFactory) || node.text === ' ';\r\n}\n\nfunction isAsyncPlaceholder(node) {\r\n    // @ts-expect-error not really boolean type\r\n    return node.isComment && node.asyncFactory;\r\n}\n\nfunction normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {\r\n    let res;\r\n    const hasNormalSlots = Object.keys(normalSlots).length > 0;\r\n    const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;\r\n    const key = scopedSlots && scopedSlots.$key;\r\n    if (!scopedSlots) {\r\n        res = {};\r\n    }\r\n    else if (scopedSlots._normalized) {\r\n        // fast path 1: child component re-render only, parent did not change\r\n        return scopedSlots._normalized;\r\n    }\r\n    else if (isStable &&\r\n        prevScopedSlots &&\r\n        prevScopedSlots !== emptyObject &&\r\n        key === prevScopedSlots.$key &&\r\n        !hasNormalSlots &&\r\n        !prevScopedSlots.$hasNormal) {\r\n        // fast path 2: stable scoped slots w/ no normal slots to proxy,\r\n        // only need to normalize once\r\n        return prevScopedSlots;\r\n    }\r\n    else {\r\n        res = {};\r\n        for (const key in scopedSlots) {\r\n            if (scopedSlots[key] && key[0] !== '$') {\r\n                res[key] = normalizeScopedSlot(ownerVm, normalSlots, key, scopedSlots[key]);\r\n            }\r\n        }\r\n    }\r\n    // expose normal slots on scopedSlots\r\n    for (const key in normalSlots) {\r\n        if (!(key in res)) {\r\n            res[key] = proxyNormalSlot(normalSlots, key);\r\n        }\r\n    }\r\n    // avoriaz seems to mock a non-extensible $scopedSlots object\r\n    // and when that is passed down this would cause an error\r\n    if (scopedSlots && Object.isExtensible(scopedSlots)) {\r\n        scopedSlots._normalized = res;\r\n    }\r\n    def(res, '$stable', isStable);\r\n    def(res, '$key', key);\r\n    def(res, '$hasNormal', hasNormalSlots);\r\n    return res;\r\n}\r\nfunction normalizeScopedSlot(vm, normalSlots, key, fn) {\r\n    const normalized = function () {\r\n        const cur = currentInstance;\r\n        setCurrentInstance(vm);\r\n        let res = arguments.length ? fn.apply(null, arguments) : fn({});\r\n        res =\r\n            res && typeof res === 'object' && !isArray(res)\r\n                ? [res] // single vnode\r\n                : normalizeChildren(res);\r\n        const vnode = res && res[0];\r\n        setCurrentInstance(cur);\r\n        return res &&\r\n            (!vnode ||\r\n                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391\r\n            ? undefined\r\n            : res;\r\n    };\r\n    // this is a slot using the new v-slot syntax without scope. although it is\r\n    // compiled as a scoped slot, render fn users would expect it to be present\r\n    // on this.$slots because the usage is semantically a normal slot.\r\n    if (fn.proxy) {\r\n        Object.defineProperty(normalSlots, key, {\r\n            get: normalized,\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n    return normalized;\r\n}\r\nfunction proxyNormalSlot(slots, key) {\r\n    return () => slots[key];\r\n}\n\nfunction initSetup(vm) {\r\n    const options = vm.$options;\r\n    const setup = options.setup;\r\n    if (setup) {\r\n        const ctx = (vm._setupContext = createSetupContext(vm));\r\n        setCurrentInstance(vm);\r\n        pushTarget();\r\n        const setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, `setup`);\r\n        popTarget();\r\n        setCurrentInstance();\r\n        if (isFunction(setupResult)) {\r\n            // render function\r\n            // @ts-ignore\r\n            options.render = setupResult;\r\n        }\r\n        else if (isObject(setupResult)) {\r\n            // bindings\r\n            if (setupResult instanceof VNode) {\r\n                warn(`setup() should not return VNodes directly - ` +\r\n                    `return a render function instead.`);\r\n            }\r\n            vm._setupState = setupResult;\r\n            // __sfc indicates compiled bindings from <script setup>\r\n            if (!setupResult.__sfc) {\r\n                for (const key in setupResult) {\r\n                    if (!isReserved(key)) {\r\n                        proxyWithRefUnwrap(vm, setupResult, key);\r\n                    }\r\n                    else {\r\n                        warn(`Avoid using variables that start with _ or $ in setup().`);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // exposed for compiled render fn\r\n                const proxy = (vm._setupProxy = {});\r\n                for (const key in setupResult) {\r\n                    if (key !== '__sfc') {\r\n                        proxyWithRefUnwrap(proxy, setupResult, key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (setupResult !== undefined) {\r\n            warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\r\n        }\r\n    }\r\n}\r\nfunction createSetupContext(vm) {\r\n    let exposeCalled = false;\r\n    return {\r\n        get attrs() {\r\n            if (!vm._attrsProxy) {\r\n                const proxy = (vm._attrsProxy = {});\r\n                def(proxy, '_v_attr_proxy', true);\r\n                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');\r\n            }\r\n            return vm._attrsProxy;\r\n        },\r\n        get listeners() {\r\n            if (!vm._listenersProxy) {\r\n                const proxy = (vm._listenersProxy = {});\r\n                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');\r\n            }\r\n            return vm._listenersProxy;\r\n        },\r\n        get slots() {\r\n            return initSlotsProxy(vm);\r\n        },\r\n        emit: bind(vm.$emit, vm),\r\n        expose(exposed) {\r\n            {\r\n                if (exposeCalled) {\r\n                    warn(`expose() should be called only once per setup().`, vm);\r\n                }\r\n                exposeCalled = true;\r\n            }\r\n            if (exposed) {\r\n                Object.keys(exposed).forEach(key => proxyWithRefUnwrap(vm, exposed, key));\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction syncSetupProxy(to, from, prev, instance, type) {\r\n    let changed = false;\r\n    for (const key in from) {\r\n        if (!(key in to)) {\r\n            changed = true;\r\n            defineProxyAttr(to, key, instance, type);\r\n        }\r\n        else if (from[key] !== prev[key]) {\r\n            changed = true;\r\n        }\r\n    }\r\n    for (const key in to) {\r\n        if (!(key in from)) {\r\n            changed = true;\r\n            delete to[key];\r\n        }\r\n    }\r\n    return changed;\r\n}\r\nfunction defineProxyAttr(proxy, key, instance, type) {\r\n    Object.defineProperty(proxy, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get() {\r\n            return instance[type][key];\r\n        }\r\n    });\r\n}\r\nfunction initSlotsProxy(vm) {\r\n    if (!vm._slotsProxy) {\r\n        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);\r\n    }\r\n    return vm._slotsProxy;\r\n}\r\nfunction syncSetupSlots(to, from) {\r\n    for (const key in from) {\r\n        to[key] = from[key];\r\n    }\r\n    for (const key in to) {\r\n        if (!(key in from)) {\r\n            delete to[key];\r\n        }\r\n    }\r\n}\r\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useSlots() {\r\n    return getContext().slots;\r\n}\r\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useAttrs() {\r\n    return getContext().attrs;\r\n}\r\n/**\r\n * Vue 2 only\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useListeners() {\r\n    return getContext().listeners;\r\n}\r\nfunction getContext() {\r\n    if (!currentInstance) {\r\n        warn(`useContext() called without active instance.`);\r\n    }\r\n    const vm = currentInstance;\r\n    return vm._setupContext || (vm._setupContext = createSetupContext(vm));\r\n}\r\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\r\nfunction mergeDefaults(raw, defaults) {\r\n    const props = isArray(raw)\r\n        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})\r\n        : raw;\r\n    for (const key in defaults) {\r\n        const opt = props[key];\r\n        if (opt) {\r\n            if (isArray(opt) || isFunction(opt)) {\r\n                props[key] = { type: opt, default: defaults[key] };\r\n            }\r\n            else {\r\n                opt.default = defaults[key];\r\n            }\r\n        }\r\n        else if (opt === null) {\r\n            props[key] = { default: defaults[key] };\r\n        }\r\n        else {\r\n            warn(`props default key \"${key}\" has no corresponding declaration.`);\r\n        }\r\n    }\r\n    return props;\r\n}\n\nfunction initRender(vm) {\r\n    vm._vnode = null; // the root of the child tree\r\n    vm._staticTrees = null; // v-once cached trees\r\n    const options = vm.$options;\r\n    const parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree\r\n    const renderContext = parentVnode && parentVnode.context;\r\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\r\n    vm.$scopedSlots = parentVnode\r\n        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)\r\n        : emptyObject;\r\n    // bind the createElement fn to this instance\r\n    // so that we get proper render context inside it.\r\n    // args order: tag, data, children, normalizationType, alwaysNormalize\r\n    // internal version is used by render functions compiled from templates\r\n    // @ts-expect-error\r\n    vm._c = (a, b, c, d) => createElement$1(vm, a, b, c, d, false);\r\n    // normalization is always applied for the public version, used in\r\n    // user-written render functions.\r\n    // @ts-expect-error\r\n    vm.$createElement = (a, b, c, d) => createElement$1(vm, a, b, c, d, true);\r\n    // $attrs & $listeners are exposed for easier HOC creation.\r\n    // they need to be reactive so that HOCs using them are always updated\r\n    const parentData = parentVnode && parentVnode.data;\r\n    /* istanbul ignore else */\r\n    {\r\n        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, () => {\r\n            !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm);\r\n        }, true);\r\n        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {\r\n            !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm);\r\n        }, true);\r\n    }\r\n}\r\nlet currentRenderingInstance = null;\r\nfunction renderMixin(Vue) {\r\n    // install runtime convenience helpers\r\n    installRenderHelpers(Vue.prototype);\r\n    Vue.prototype.$nextTick = function (fn) {\r\n        return nextTick(fn, this);\r\n    };\r\n    Vue.prototype._render = function () {\r\n        const vm = this;\r\n        const { render, _parentVnode } = vm.$options;\r\n        if (_parentVnode && vm._isMounted) {\r\n            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\r\n            if (vm._slotsProxy) {\r\n                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);\r\n            }\r\n        }\r\n        // set parent vnode. this allows render functions to have access\r\n        // to the data on the placeholder node.\r\n        vm.$vnode = _parentVnode;\r\n        // render self\r\n        let vnode;\r\n        try {\r\n            // There's no need to maintain a stack because all render fns are called\r\n            // separately from one another. Nested component's render fns are called\r\n            // when parent component is patched.\r\n            setCurrentInstance(vm);\r\n            currentRenderingInstance = vm;\r\n            vnode = render.call(vm._renderProxy, vm.$createElement);\r\n        }\r\n        catch (e) {\r\n            handleError(e, vm, `render`);\r\n            // return error render result,\r\n            // or previous vnode to prevent render error causing blank component\r\n            /* istanbul ignore else */\r\n            if (vm.$options.renderError) {\r\n                try {\r\n                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\r\n                }\r\n                catch (e) {\r\n                    handleError(e, vm, `renderError`);\r\n                    vnode = vm._vnode;\r\n                }\r\n            }\r\n            else {\r\n                vnode = vm._vnode;\r\n            }\r\n        }\r\n        finally {\r\n            currentRenderingInstance = null;\r\n            setCurrentInstance();\r\n        }\r\n        // if the returned array contains only a single node, allow it\r\n        if (isArray(vnode) && vnode.length === 1) {\r\n            vnode = vnode[0];\r\n        }\r\n        // return empty vnode in case the render function errored out\r\n        if (!(vnode instanceof VNode)) {\r\n            if (isArray(vnode)) {\r\n                warn('Multiple root nodes returned from render function. Render function ' +\r\n                    'should return a single root node.', vm);\r\n            }\r\n            vnode = createEmptyVNode();\r\n        }\r\n        // set parent\r\n        vnode.parent = _parentVnode;\r\n        return vnode;\r\n    };\r\n}\n\nfunction ensureCtor(comp, base) {\r\n    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {\r\n        comp = comp.default;\r\n    }\r\n    return isObject(comp) ? base.extend(comp) : comp;\r\n}\r\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\r\n    const node = createEmptyVNode();\r\n    node.asyncFactory = factory;\r\n    node.asyncMeta = { data, context, children, tag };\r\n    return node;\r\n}\r\nfunction resolveAsyncComponent(factory, baseCtor) {\r\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\r\n        return factory.errorComp;\r\n    }\r\n    if (isDef(factory.resolved)) {\r\n        return factory.resolved;\r\n    }\r\n    const owner = currentRenderingInstance;\r\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\r\n        // already pending\r\n        factory.owners.push(owner);\r\n    }\r\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\r\n        return factory.loadingComp;\r\n    }\r\n    if (owner && !isDef(factory.owners)) {\r\n        const owners = (factory.owners = [owner]);\r\n        let sync = true;\r\n        let timerLoading = null;\r\n        let timerTimeout = null;\r\n        owner.$on('hook:destroyed', () => remove$2(owners, owner));\r\n        const forceRender = (renderCompleted) => {\r\n            for (let i = 0, l = owners.length; i < l; i++) {\r\n                owners[i].$forceUpdate();\r\n            }\r\n            if (renderCompleted) {\r\n                owners.length = 0;\r\n                if (timerLoading !== null) {\r\n                    clearTimeout(timerLoading);\r\n                    timerLoading = null;\r\n                }\r\n                if (timerTimeout !== null) {\r\n                    clearTimeout(timerTimeout);\r\n                    timerTimeout = null;\r\n                }\r\n            }\r\n        };\r\n        const resolve = once((res) => {\r\n            // cache resolved\r\n            factory.resolved = ensureCtor(res, baseCtor);\r\n            // invoke callbacks only if this is not a synchronous resolve\r\n            // (async resolves are shimmed as synchronous during SSR)\r\n            if (!sync) {\r\n                forceRender(true);\r\n            }\r\n            else {\r\n                owners.length = 0;\r\n            }\r\n        });\r\n        const reject = once(reason => {\r\n            warn(`Failed to resolve async component: ${String(factory)}` +\r\n                    (reason ? `\\nReason: ${reason}` : ''));\r\n            if (isDef(factory.errorComp)) {\r\n                factory.error = true;\r\n                forceRender(true);\r\n            }\r\n        });\r\n        const res = factory(resolve, reject);\r\n        if (isObject(res)) {\r\n            if (isPromise(res)) {\r\n                // () => Promise\r\n                if (isUndef(factory.resolved)) {\r\n                    res.then(resolve, reject);\r\n                }\r\n            }\r\n            else if (isPromise(res.component)) {\r\n                res.component.then(resolve, reject);\r\n                if (isDef(res.error)) {\r\n                    factory.errorComp = ensureCtor(res.error, baseCtor);\r\n                }\r\n                if (isDef(res.loading)) {\r\n                    factory.loadingComp = ensureCtor(res.loading, baseCtor);\r\n                    if (res.delay === 0) {\r\n                        factory.loading = true;\r\n                    }\r\n                    else {\r\n                        // @ts-expect-error NodeJS timeout type\r\n                        timerLoading = setTimeout(() => {\r\n                            timerLoading = null;\r\n                            if (isUndef(factory.resolved) && isUndef(factory.error)) {\r\n                                factory.loading = true;\r\n                                forceRender(false);\r\n                            }\r\n                        }, res.delay || 200);\r\n                    }\r\n                }\r\n                if (isDef(res.timeout)) {\r\n                    // @ts-expect-error NodeJS timeout type\r\n                    timerTimeout = setTimeout(() => {\r\n                        timerTimeout = null;\r\n                        if (isUndef(factory.resolved)) {\r\n                            reject(`timeout (${res.timeout}ms)` );\r\n                        }\r\n                    }, res.timeout);\r\n                }\r\n            }\r\n        }\r\n        sync = false;\r\n        // return in case resolved synchronously\r\n        return factory.loading ? factory.loadingComp : factory.resolved;\r\n    }\r\n}\n\nfunction getFirstComponentChild(children) {\r\n    if (isArray(children)) {\r\n        for (let i = 0; i < children.length; i++) {\r\n            const c = children[i];\r\n            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\r\n                return c;\r\n            }\r\n        }\r\n    }\r\n}\n\nconst SIMPLE_NORMALIZE = 1;\r\nconst ALWAYS_NORMALIZE = 2;\r\n// wrapper function for providing a more flexible interface\r\n// without getting yelled at by flow\r\nfunction createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {\r\n    if (isArray(data) || isPrimitive(data)) {\r\n        normalizationType = children;\r\n        children = data;\r\n        data = undefined;\r\n    }\r\n    if (isTrue(alwaysNormalize)) {\r\n        normalizationType = ALWAYS_NORMALIZE;\r\n    }\r\n    return _createElement(context, tag, data, children, normalizationType);\r\n}\r\nfunction _createElement(context, tag, data, children, normalizationType) {\r\n    if (isDef(data) && isDef(data.__ob__)) {\r\n        warn(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` + 'Always create fresh vnode data objects in each render!', context);\r\n        return createEmptyVNode();\r\n    }\r\n    // object syntax in v-bind\r\n    if (isDef(data) && isDef(data.is)) {\r\n        tag = data.is;\r\n    }\r\n    if (!tag) {\r\n        // in case of component :is set to falsy value\r\n        return createEmptyVNode();\r\n    }\r\n    // warn against non-primitive key\r\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\r\n        warn('Avoid using non-primitive value as key, ' +\r\n            'use string/number value instead.', context);\r\n    }\r\n    // support single function children as default scoped slot\r\n    if (isArray(children) && isFunction(children[0])) {\r\n        data = data || {};\r\n        data.scopedSlots = { default: children[0] };\r\n        children.length = 0;\r\n    }\r\n    if (normalizationType === ALWAYS_NORMALIZE) {\r\n        children = normalizeChildren(children);\r\n    }\r\n    else if (normalizationType === SIMPLE_NORMALIZE) {\r\n        children = simpleNormalizeChildren(children);\r\n    }\r\n    let vnode, ns;\r\n    if (typeof tag === 'string') {\r\n        let Ctor;\r\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\r\n        if (config.isReservedTag(tag)) {\r\n            // platform built-in elements\r\n            if (isDef(data) &&\r\n                isDef(data.nativeOn) &&\r\n                data.tag !== 'component') {\r\n                warn(`The .native modifier for v-on is only valid on components but it was used on <${tag}>.`, context);\r\n            }\r\n            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\r\n        }\r\n        else if ((!data || !data.pre) &&\r\n            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {\r\n            // component\r\n            vnode = createComponent(Ctor, data, context, children, tag);\r\n        }\r\n        else {\r\n            // unknown or unlisted namespaced elements\r\n            // check at runtime because it may get assigned a namespace when its\r\n            // parent normalizes children\r\n            vnode = new VNode(tag, data, children, undefined, undefined, context);\r\n        }\r\n    }\r\n    else {\r\n        // direct component options / constructor\r\n        vnode = createComponent(tag, data, context, children);\r\n    }\r\n    if (isArray(vnode)) {\r\n        return vnode;\r\n    }\r\n    else if (isDef(vnode)) {\r\n        if (isDef(ns))\r\n            applyNS(vnode, ns);\r\n        if (isDef(data))\r\n            registerDeepBindings(data);\r\n        return vnode;\r\n    }\r\n    else {\r\n        return createEmptyVNode();\r\n    }\r\n}\r\nfunction applyNS(vnode, ns, force) {\r\n    vnode.ns = ns;\r\n    if (vnode.tag === 'foreignObject') {\r\n        // use default namespace inside foreignObject\r\n        ns = undefined;\r\n        force = true;\r\n    }\r\n    if (isDef(vnode.children)) {\r\n        for (let i = 0, l = vnode.children.length; i < l; i++) {\r\n            const child = vnode.children[i];\r\n            if (isDef(child.tag) &&\r\n                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\r\n                applyNS(child, ns, force);\r\n            }\r\n        }\r\n    }\r\n}\r\n// ref #5318\r\n// necessary to ensure parent re-render when deep bindings like :style and\r\n// :class are used on slot nodes\r\nfunction registerDeepBindings(data) {\r\n    if (isObject(data.style)) {\r\n        traverse(data.style);\r\n    }\r\n    if (isObject(data.class)) {\r\n        traverse(data.class);\r\n    }\r\n}\n\n/**\r\n * @internal this function needs manual public type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\r\nfunction h(type, props, children) {\r\n    if (!currentInstance) {\r\n        warn(`globally imported h() can only be invoked when there is an active ` +\r\n                `component instance, e.g. synchronously in a component's render or setup function.`);\r\n    }\r\n    return createElement$1(currentInstance, type, props, children, 2, true);\r\n}\n\nfunction handleError(err, vm, info) {\r\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\r\n    // See: https://github.com/vuejs/vuex/issues/1505\r\n    pushTarget();\r\n    try {\r\n        if (vm) {\r\n            let cur = vm;\r\n            while ((cur = cur.$parent)) {\r\n                const hooks = cur.$options.errorCaptured;\r\n                if (hooks) {\r\n                    for (let i = 0; i < hooks.length; i++) {\r\n                        try {\r\n                            const capture = hooks[i].call(cur, err, vm, info) === false;\r\n                            if (capture)\r\n                                return;\r\n                        }\r\n                        catch (e) {\r\n                            globalHandleError(e, cur, 'errorCaptured hook');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        globalHandleError(err, vm, info);\r\n    }\r\n    finally {\r\n        popTarget();\r\n    }\r\n}\r\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\r\n    let res;\r\n    try {\r\n        res = args ? handler.apply(context, args) : handler.call(context);\r\n        if (res && !res._isVue && isPromise(res) && !res._handled) {\r\n            res.catch(e => handleError(e, vm, info + ` (Promise/async)`));\r\n            res._handled = true;\r\n        }\r\n    }\r\n    catch (e) {\r\n        handleError(e, vm, info);\r\n    }\r\n    return res;\r\n}\r\nfunction globalHandleError(err, vm, info) {\r\n    if (config.errorHandler) {\r\n        try {\r\n            return config.errorHandler.call(null, err, vm, info);\r\n        }\r\n        catch (e) {\r\n            // if the user intentionally throws the original error in the handler,\r\n            // do not log it twice\r\n            if (e !== err) {\r\n                logError(e, null, 'config.errorHandler');\r\n            }\r\n        }\r\n    }\r\n    logError(err, vm, info);\r\n}\r\nfunction logError(err, vm, info) {\r\n    {\r\n        warn(`Error in ${info}: \"${err.toString()}\"`, vm);\r\n    }\r\n    /* istanbul ignore else */\r\n    if (inBrowser && typeof console !== 'undefined') {\r\n        console.error(err);\r\n    }\r\n    else {\r\n        throw err;\r\n    }\r\n}\n\n/* globals MutationObserver */\r\nlet isUsingMicroTask = false;\r\nconst callbacks = [];\r\nlet pending = false;\r\nfunction flushCallbacks() {\r\n    pending = false;\r\n    const copies = callbacks.slice(0);\r\n    callbacks.length = 0;\r\n    for (let i = 0; i < copies.length; i++) {\r\n        copies[i]();\r\n    }\r\n}\r\n// Here we have async deferring wrappers using microtasks.\r\n// In 2.5 we used (macro) tasks (in combination with microtasks).\r\n// However, it has subtle problems when state is changed right before repaint\r\n// (e.g. #6813, out-in transitions).\r\n// Also, using (macro) tasks in event handler would cause some weird behaviors\r\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\r\n// So we now use microtasks everywhere, again.\r\n// A major drawback of this tradeoff is that there are some scenarios\r\n// where microtasks have too high a priority and fire in between supposedly\r\n// sequential events (e.g. #4521, #6690, which have workarounds)\r\n// or even between bubbling of the same event (#6566).\r\nlet timerFunc;\r\n// The nextTick behavior leverages the microtask queue, which can be accessed\r\n// via either native Promise.then or MutationObserver.\r\n// MutationObserver has wider support, however it is seriously bugged in\r\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\r\n// completely stops working after triggering a few times... so, if native\r\n// Promise is available, we will use it:\r\n/* istanbul ignore next, $flow-disable-line */\r\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\r\n    const p = Promise.resolve();\r\n    timerFunc = () => {\r\n        p.then(flushCallbacks);\r\n        // In problematic UIWebViews, Promise.then doesn't completely break, but\r\n        // it can get stuck in a weird state where callbacks are pushed into the\r\n        // microtask queue but the queue isn't being flushed, until the browser\r\n        // needs to do some other work, e.g. handle a timer. Therefore we can\r\n        // \"force\" the microtask queue to be flushed by adding an empty timer.\r\n        if (isIOS)\r\n            setTimeout(noop);\r\n    };\r\n    isUsingMicroTask = true;\r\n}\r\nelse if (!isIE &&\r\n    typeof MutationObserver !== 'undefined' &&\r\n    (isNative(MutationObserver) ||\r\n        // PhantomJS and iOS 7.x\r\n        MutationObserver.toString() === '[object MutationObserverConstructor]')) {\r\n    // Use MutationObserver where native Promise is not available,\r\n    // e.g. PhantomJS, iOS7, Android 4.4\r\n    // (#6466 MutationObserver is unreliable in IE11)\r\n    let counter = 1;\r\n    const observer = new MutationObserver(flushCallbacks);\r\n    const textNode = document.createTextNode(String(counter));\r\n    observer.observe(textNode, {\r\n        characterData: true\r\n    });\r\n    timerFunc = () => {\r\n        counter = (counter + 1) % 2;\r\n        textNode.data = String(counter);\r\n    };\r\n    isUsingMicroTask = true;\r\n}\r\nelse if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\r\n    // Fallback to setImmediate.\r\n    // Technically it leverages the (macro) task queue,\r\n    // but it is still a better choice than setTimeout.\r\n    timerFunc = () => {\r\n        setImmediate(flushCallbacks);\r\n    };\r\n}\r\nelse {\r\n    // Fallback to setTimeout.\r\n    timerFunc = () => {\r\n        setTimeout(flushCallbacks, 0);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction nextTick(cb, ctx) {\r\n    let _resolve;\r\n    callbacks.push(() => {\r\n        if (cb) {\r\n            try {\r\n                cb.call(ctx);\r\n            }\r\n            catch (e) {\r\n                handleError(e, ctx, 'nextTick');\r\n            }\r\n        }\r\n        else if (_resolve) {\r\n            _resolve(ctx);\r\n        }\r\n    });\r\n    if (!pending) {\r\n        pending = true;\r\n        timerFunc();\r\n    }\r\n    // $flow-disable-line\r\n    if (!cb && typeof Promise !== 'undefined') {\r\n        return new Promise(resolve => {\r\n            _resolve = resolve;\r\n        });\r\n    }\r\n}\n\nfunction useCssModule(name = '$style') {\r\n    /* istanbul ignore else */\r\n    {\r\n        if (!currentInstance) {\r\n            warn(`useCssModule must be called inside setup()`);\r\n            return emptyObject;\r\n        }\r\n        const mod = currentInstance[name];\r\n        if (!mod) {\r\n            warn(`Current instance does not have CSS module named \"${name}\".`);\r\n            return emptyObject;\r\n        }\r\n        return mod;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    if (!inBrowser && !false)\r\n        return;\r\n    const instance = currentInstance;\r\n    if (!instance) {\r\n        warn(`useCssVars is called without current active component instance.`);\r\n        return;\r\n    }\r\n    watchPostEffect(() => {\r\n        const el = instance.$el;\r\n        const vars = getter(instance, instance._setupProxy);\r\n        if (el && el.nodeType === 1) {\r\n            const style = el.style;\r\n            for (const key in vars) {\r\n                style.setProperty(`--${key}`, vars[key]);\r\n            }\r\n        }\r\n    });\r\n}\n\n/**\r\n * v3-compatible async component API.\r\n * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts\r\n * because it relies on existing manual types\r\n */\r\nfunction defineAsyncComponent(source) {\r\n    if (isFunction(source)) {\r\n        source = { loader: source };\r\n    }\r\n    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\r\n    suspensible = false, // in Vue 3 default is true\r\n    onError: userOnError } = source;\r\n    if (suspensible) {\r\n        warn(`The suspensiblbe option for async components is not supported in Vue2. It is ignored.`);\r\n    }\r\n    let pendingRequest = null;\r\n    let retries = 0;\r\n    const retry = () => {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    const load = () => {\r\n        let thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest =\r\n                loader()\r\n                    .catch(err => {\r\n                    err = err instanceof Error ? err : new Error(String(err));\r\n                    if (userOnError) {\r\n                        return new Promise((resolve, reject) => {\r\n                            const userRetry = () => resolve(retry());\r\n                            const userFail = () => reject(err);\r\n                            userOnError(err, userRetry, userFail, retries + 1);\r\n                        });\r\n                    }\r\n                    else {\r\n                        throw err;\r\n                    }\r\n                })\r\n                    .then((comp) => {\r\n                    if (thisRequest !== pendingRequest && pendingRequest) {\r\n                        return pendingRequest;\r\n                    }\r\n                    if (!comp) {\r\n                        warn(`Async component loader resolved to undefined. ` +\r\n                            `If you are using retry(), make sure to return its return value.`);\r\n                    }\r\n                    // interop module default\r\n                    if (comp &&\r\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                        comp = comp.default;\r\n                    }\r\n                    if (comp && !isObject(comp) && !isFunction(comp)) {\r\n                        throw new Error(`Invalid async component load result: ${comp}`);\r\n                    }\r\n                    return comp;\r\n                })));\r\n    };\r\n    return () => {\r\n        const component = load();\r\n        return {\r\n            component,\r\n            delay,\r\n            timeout,\r\n            error: errorComponent,\r\n            loading: loadingComponent\r\n        };\r\n    };\r\n}\n\nfunction createLifeCycle(hookName) {\r\n    return (fn, target = currentInstance) => {\r\n        if (!target) {\r\n            warn(`${formatName(hookName)} is called when there is no active component instance to be ` +\r\n                    `associated with. ` +\r\n                    `Lifecycle injection APIs can only be used during execution of setup().`);\r\n            return;\r\n        }\r\n        return injectHook(target, hookName, fn);\r\n    };\r\n}\r\nfunction formatName(name) {\r\n    if (name === 'beforeDestroy') {\r\n        name = 'beforeUnmount';\r\n    }\r\n    else if (name === 'destroyed') {\r\n        name = 'unmounted';\r\n    }\r\n    return `on${name[0].toUpperCase() + name.slice(1)}`;\r\n}\r\nfunction injectHook(instance, hookName, fn) {\r\n    const options = instance.$options;\r\n    options[hookName] = mergeLifecycleHook(options[hookName], fn);\r\n}\r\nconst onBeforeMount = createLifeCycle('beforeMount');\r\nconst onMounted = createLifeCycle('mounted');\r\nconst onBeforeUpdate = createLifeCycle('beforeUpdate');\r\nconst onUpdated = createLifeCycle('updated');\r\nconst onBeforeUnmount = createLifeCycle('beforeDestroy');\r\nconst onUnmounted = createLifeCycle('destroyed');\r\nconst onActivated = createLifeCycle('activated');\r\nconst onDeactivated = createLifeCycle('deactivated');\r\nconst onServerPrefetch = createLifeCycle('serverPrefetch');\r\nconst onRenderTracked = createLifeCycle('renderTracked');\r\nconst onRenderTriggered = createLifeCycle('renderTriggered');\r\nconst injectErrorCapturedHook = createLifeCycle('errorCaptured');\r\nfunction onErrorCaptured(hook, target = currentInstance) {\r\n    injectErrorCapturedHook(hook, target);\r\n}\n\n/**\r\n * Note: also update dist/vue.runtime.mjs when adding new exports to this file.\r\n */\r\nconst version = '2.7.10';\r\n/**\r\n * @internal type is manually declared in <root>/types/v3-define-component.d.ts\r\n */\r\nfunction defineComponent(options) {\r\n    return options;\r\n}\n\nvar vca = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  version: version,\n  defineComponent: defineComponent,\n  ref: ref$1,\n  shallowRef: shallowRef,\n  isRef: isRef,\n  toRef: toRef,\n  toRefs: toRefs,\n  unref: unref,\n  proxyRefs: proxyRefs,\n  customRef: customRef,\n  triggerRef: triggerRef,\n  reactive: reactive,\n  isReactive: isReactive,\n  isReadonly: isReadonly,\n  isShallow: isShallow,\n  isProxy: isProxy,\n  shallowReactive: shallowReactive,\n  markRaw: markRaw,\n  toRaw: toRaw,\n  readonly: readonly,\n  shallowReadonly: shallowReadonly,\n  computed: computed,\n  watch: watch,\n  watchEffect: watchEffect,\n  watchPostEffect: watchPostEffect,\n  watchSyncEffect: watchSyncEffect,\n  EffectScope: EffectScope,\n  effectScope: effectScope,\n  onScopeDispose: onScopeDispose,\n  getCurrentScope: getCurrentScope,\n  provide: provide,\n  inject: inject,\n  h: h,\n  getCurrentInstance: getCurrentInstance,\n  useSlots: useSlots,\n  useAttrs: useAttrs,\n  useListeners: useListeners,\n  mergeDefaults: mergeDefaults,\n  nextTick: nextTick,\n  set: set,\n  del: del,\n  useCssModule: useCssModule,\n  useCssVars: useCssVars,\n  defineAsyncComponent: defineAsyncComponent,\n  onBeforeMount: onBeforeMount,\n  onMounted: onMounted,\n  onBeforeUpdate: onBeforeUpdate,\n  onUpdated: onUpdated,\n  onBeforeUnmount: onBeforeUnmount,\n  onUnmounted: onUnmounted,\n  onActivated: onActivated,\n  onDeactivated: onDeactivated,\n  onServerPrefetch: onServerPrefetch,\n  onRenderTracked: onRenderTracked,\n  onRenderTriggered: onRenderTriggered,\n  onErrorCaptured: onErrorCaptured\n});\n\nconst seenObjects = new _Set();\r\n/**\r\n * Recursively traverse an object to evoke all converted\r\n * getters, so that every nested property inside the object\r\n * is collected as a \"deep\" dependency.\r\n */\r\nfunction traverse(val) {\r\n    _traverse(val, seenObjects);\r\n    seenObjects.clear();\r\n    return val;\r\n}\r\nfunction _traverse(val, seen) {\r\n    let i, keys;\r\n    const isA = isArray(val);\r\n    if ((!isA && !isObject(val)) ||\r\n        Object.isFrozen(val) ||\r\n        val instanceof VNode) {\r\n        return;\r\n    }\r\n    if (val.__ob__) {\r\n        const depId = val.__ob__.dep.id;\r\n        if (seen.has(depId)) {\r\n            return;\r\n        }\r\n        seen.add(depId);\r\n    }\r\n    if (isA) {\r\n        i = val.length;\r\n        while (i--)\r\n            _traverse(val[i], seen);\r\n    }\r\n    else if (isRef(val)) {\r\n        _traverse(val.value, seen);\r\n    }\r\n    else {\r\n        keys = Object.keys(val);\r\n        i = keys.length;\r\n        while (i--)\r\n            _traverse(val[keys[i]], seen);\r\n    }\r\n}\n\nlet uid$1 = 0;\r\n/**\r\n * A watcher parses an expression, collects dependencies,\r\n * and fires callback when the expression value changes.\r\n * This is used for both the $watch() api and directives.\r\n * @internal\r\n */\r\nclass Watcher {\r\n    constructor(vm, expOrFn, cb, options, isRenderWatcher) {\r\n        recordEffectScope(this, \r\n        // if the active effect scope is manually created (not a component scope),\r\n        // prioritize it\r\n        activeEffectScope && !activeEffectScope._vm\r\n            ? activeEffectScope\r\n            : vm\r\n                ? vm._scope\r\n                : undefined);\r\n        if ((this.vm = vm) && isRenderWatcher) {\r\n            vm._watcher = this;\r\n        }\r\n        // options\r\n        if (options) {\r\n            this.deep = !!options.deep;\r\n            this.user = !!options.user;\r\n            this.lazy = !!options.lazy;\r\n            this.sync = !!options.sync;\r\n            this.before = options.before;\r\n            {\r\n                this.onTrack = options.onTrack;\r\n                this.onTrigger = options.onTrigger;\r\n            }\r\n        }\r\n        else {\r\n            this.deep = this.user = this.lazy = this.sync = false;\r\n        }\r\n        this.cb = cb;\r\n        this.id = ++uid$1; // uid for batching\r\n        this.active = true;\r\n        this.post = false;\r\n        this.dirty = this.lazy; // for lazy watchers\r\n        this.deps = [];\r\n        this.newDeps = [];\r\n        this.depIds = new _Set();\r\n        this.newDepIds = new _Set();\r\n        this.expression = expOrFn.toString() ;\r\n        // parse expression for getter\r\n        if (isFunction(expOrFn)) {\r\n            this.getter = expOrFn;\r\n        }\r\n        else {\r\n            this.getter = parsePath(expOrFn);\r\n            if (!this.getter) {\r\n                this.getter = noop;\r\n                warn(`Failed watching path: \"${expOrFn}\" ` +\r\n                        'Watcher only accepts simple dot-delimited paths. ' +\r\n                        'For full control, use a function instead.', vm);\r\n            }\r\n        }\r\n        this.value = this.lazy ? undefined : this.get();\r\n    }\r\n    /**\r\n     * Evaluate the getter, and re-collect dependencies.\r\n     */\r\n    get() {\r\n        pushTarget(this);\r\n        let value;\r\n        const vm = this.vm;\r\n        try {\r\n            value = this.getter.call(vm, vm);\r\n        }\r\n        catch (e) {\r\n            if (this.user) {\r\n                handleError(e, vm, `getter for watcher \"${this.expression}\"`);\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        finally {\r\n            // \"touch\" every property so they are all tracked as\r\n            // dependencies for deep watching\r\n            if (this.deep) {\r\n                traverse(value);\r\n            }\r\n            popTarget();\r\n            this.cleanupDeps();\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Add a dependency to this directive.\r\n     */\r\n    addDep(dep) {\r\n        const id = dep.id;\r\n        if (!this.newDepIds.has(id)) {\r\n            this.newDepIds.add(id);\r\n            this.newDeps.push(dep);\r\n            if (!this.depIds.has(id)) {\r\n                dep.addSub(this);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Clean up for dependency collection.\r\n     */\r\n    cleanupDeps() {\r\n        let i = this.deps.length;\r\n        while (i--) {\r\n            const dep = this.deps[i];\r\n            if (!this.newDepIds.has(dep.id)) {\r\n                dep.removeSub(this);\r\n            }\r\n        }\r\n        let tmp = this.depIds;\r\n        this.depIds = this.newDepIds;\r\n        this.newDepIds = tmp;\r\n        this.newDepIds.clear();\r\n        tmp = this.deps;\r\n        this.deps = this.newDeps;\r\n        this.newDeps = tmp;\r\n        this.newDeps.length = 0;\r\n    }\r\n    /**\r\n     * Subscriber interface.\r\n     * Will be called when a dependency changes.\r\n     */\r\n    update() {\r\n        /* istanbul ignore else */\r\n        if (this.lazy) {\r\n            this.dirty = true;\r\n        }\r\n        else if (this.sync) {\r\n            this.run();\r\n        }\r\n        else {\r\n            queueWatcher(this);\r\n        }\r\n    }\r\n    /**\r\n     * Scheduler job interface.\r\n     * Will be called by the scheduler.\r\n     */\r\n    run() {\r\n        if (this.active) {\r\n            const value = this.get();\r\n            if (value !== this.value ||\r\n                // Deep watchers and watchers on Object/Arrays should fire even\r\n                // when the value is the same, because the value may\r\n                // have mutated.\r\n                isObject(value) ||\r\n                this.deep) {\r\n                // set new value\r\n                const oldValue = this.value;\r\n                this.value = value;\r\n                if (this.user) {\r\n                    const info = `callback for watcher \"${this.expression}\"`;\r\n                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\r\n                }\r\n                else {\r\n                    this.cb.call(this.vm, value, oldValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Evaluate the value of the watcher.\r\n     * This only gets called for lazy watchers.\r\n     */\r\n    evaluate() {\r\n        this.value = this.get();\r\n        this.dirty = false;\r\n    }\r\n    /**\r\n     * Depend on all deps collected by this watcher.\r\n     */\r\n    depend() {\r\n        let i = this.deps.length;\r\n        while (i--) {\r\n            this.deps[i].depend();\r\n        }\r\n    }\r\n    /**\r\n     * Remove self from all dependencies' subscriber list.\r\n     */\r\n    teardown() {\r\n        if (this.vm && !this.vm._isBeingDestroyed) {\r\n            remove$2(this.vm._scope.effects, this);\r\n        }\r\n        if (this.active) {\r\n            let i = this.deps.length;\r\n            while (i--) {\r\n                this.deps[i].removeSub(this);\r\n            }\r\n            this.active = false;\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n        }\r\n    }\r\n}\n\nlet mark;\r\nlet measure;\r\n{\r\n    const perf = inBrowser && window.performance;\r\n    /* istanbul ignore if */\r\n    if (perf &&\r\n        // @ts-ignore\r\n        perf.mark &&\r\n        // @ts-ignore\r\n        perf.measure &&\r\n        // @ts-ignore\r\n        perf.clearMarks &&\r\n        // @ts-ignore\r\n        perf.clearMeasures) {\r\n        mark = tag => perf.mark(tag);\r\n        measure = (name, startTag, endTag) => {\r\n            perf.measure(name, startTag, endTag);\r\n            perf.clearMarks(startTag);\r\n            perf.clearMarks(endTag);\r\n            // perf.clearMeasures(name)\r\n        };\r\n    }\r\n}\n\nfunction initEvents(vm) {\r\n    vm._events = Object.create(null);\r\n    vm._hasHookEvent = false;\r\n    // init parent attached events\r\n    const listeners = vm.$options._parentListeners;\r\n    if (listeners) {\r\n        updateComponentListeners(vm, listeners);\r\n    }\r\n}\r\nlet target$1;\r\nfunction add$1(event, fn) {\r\n    target$1.$on(event, fn);\r\n}\r\nfunction remove$1(event, fn) {\r\n    target$1.$off(event, fn);\r\n}\r\nfunction createOnceHandler$1(event, fn) {\r\n    const _target = target$1;\r\n    return function onceHandler() {\r\n        const res = fn.apply(null, arguments);\r\n        if (res !== null) {\r\n            _target.$off(event, onceHandler);\r\n        }\r\n    };\r\n}\r\nfunction updateComponentListeners(vm, listeners, oldListeners) {\r\n    target$1 = vm;\r\n    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);\r\n    target$1 = undefined;\r\n}\r\nfunction eventsMixin(Vue) {\r\n    const hookRE = /^hook:/;\r\n    Vue.prototype.$on = function (event, fn) {\r\n        const vm = this;\r\n        if (isArray(event)) {\r\n            for (let i = 0, l = event.length; i < l; i++) {\r\n                vm.$on(event[i], fn);\r\n            }\r\n        }\r\n        else {\r\n            (vm._events[event] || (vm._events[event] = [])).push(fn);\r\n            // optimize hook:event cost by using a boolean flag marked at registration\r\n            // instead of a hash lookup\r\n            if (hookRE.test(event)) {\r\n                vm._hasHookEvent = true;\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n    Vue.prototype.$once = function (event, fn) {\r\n        const vm = this;\r\n        function on() {\r\n            vm.$off(event, on);\r\n            fn.apply(vm, arguments);\r\n        }\r\n        on.fn = fn;\r\n        vm.$on(event, on);\r\n        return vm;\r\n    };\r\n    Vue.prototype.$off = function (event, fn) {\r\n        const vm = this;\r\n        // all\r\n        if (!arguments.length) {\r\n            vm._events = Object.create(null);\r\n            return vm;\r\n        }\r\n        // array of events\r\n        if (isArray(event)) {\r\n            for (let i = 0, l = event.length; i < l; i++) {\r\n                vm.$off(event[i], fn);\r\n            }\r\n            return vm;\r\n        }\r\n        // specific event\r\n        const cbs = vm._events[event];\r\n        if (!cbs) {\r\n            return vm;\r\n        }\r\n        if (!fn) {\r\n            vm._events[event] = null;\r\n            return vm;\r\n        }\r\n        // specific handler\r\n        let cb;\r\n        let i = cbs.length;\r\n        while (i--) {\r\n            cb = cbs[i];\r\n            if (cb === fn || cb.fn === fn) {\r\n                cbs.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n    Vue.prototype.$emit = function (event) {\r\n        const vm = this;\r\n        {\r\n            const lowerCaseEvent = event.toLowerCase();\r\n            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\r\n                tip(`Event \"${lowerCaseEvent}\" is emitted in component ` +\r\n                    `${formatComponentName(vm)} but the handler is registered for \"${event}\". ` +\r\n                    `Note that HTML attributes are case-insensitive and you cannot use ` +\r\n                    `v-on to listen to camelCase events when using in-DOM templates. ` +\r\n                    `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`);\r\n            }\r\n        }\r\n        let cbs = vm._events[event];\r\n        if (cbs) {\r\n            cbs = cbs.length > 1 ? toArray(cbs) : cbs;\r\n            const args = toArray(arguments, 1);\r\n            const info = `event handler for \"${event}\"`;\r\n            for (let i = 0, l = cbs.length; i < l; i++) {\r\n                invokeWithErrorHandling(cbs[i], vm, args, vm, info);\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n}\n\nlet activeInstance = null;\r\nlet isUpdatingChildComponent = false;\r\nfunction setActiveInstance(vm) {\r\n    const prevActiveInstance = activeInstance;\r\n    activeInstance = vm;\r\n    return () => {\r\n        activeInstance = prevActiveInstance;\r\n    };\r\n}\r\nfunction initLifecycle(vm) {\r\n    const options = vm.$options;\r\n    // locate first non-abstract parent\r\n    let parent = options.parent;\r\n    if (parent && !options.abstract) {\r\n        while (parent.$options.abstract && parent.$parent) {\r\n            parent = parent.$parent;\r\n        }\r\n        parent.$children.push(vm);\r\n    }\r\n    vm.$parent = parent;\r\n    vm.$root = parent ? parent.$root : vm;\r\n    vm.$children = [];\r\n    vm.$refs = {};\r\n    vm._provided = parent ? parent._provided : Object.create(null);\r\n    vm._watcher = null;\r\n    vm._inactive = null;\r\n    vm._directInactive = false;\r\n    vm._isMounted = false;\r\n    vm._isDestroyed = false;\r\n    vm._isBeingDestroyed = false;\r\n}\r\nfunction lifecycleMixin(Vue) {\r\n    Vue.prototype._update = function (vnode, hydrating) {\r\n        const vm = this;\r\n        const prevEl = vm.$el;\r\n        const prevVnode = vm._vnode;\r\n        const restoreActiveInstance = setActiveInstance(vm);\r\n        vm._vnode = vnode;\r\n        // Vue.prototype.__patch__ is injected in entry points\r\n        // based on the rendering backend used.\r\n        if (!prevVnode) {\r\n            // initial render\r\n            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\r\n        }\r\n        else {\r\n            // updates\r\n            vm.$el = vm.__patch__(prevVnode, vnode);\r\n        }\r\n        restoreActiveInstance();\r\n        // update __vue__ reference\r\n        if (prevEl) {\r\n            prevEl.__vue__ = null;\r\n        }\r\n        if (vm.$el) {\r\n            vm.$el.__vue__ = vm;\r\n        }\r\n        // if parent is an HOC, update its $el as well\r\n        let wrapper = vm;\r\n        while (wrapper &&\r\n            wrapper.$vnode &&\r\n            wrapper.$parent &&\r\n            wrapper.$vnode === wrapper.$parent._vnode) {\r\n            wrapper.$parent.$el = wrapper.$el;\r\n            wrapper = wrapper.$parent;\r\n        }\r\n        // updated hook is called by the scheduler to ensure that children are\r\n        // updated in a parent's updated hook.\r\n    };\r\n    Vue.prototype.$forceUpdate = function () {\r\n        const vm = this;\r\n        if (vm._watcher) {\r\n            vm._watcher.update();\r\n        }\r\n    };\r\n    Vue.prototype.$destroy = function () {\r\n        const vm = this;\r\n        if (vm._isBeingDestroyed) {\r\n            return;\r\n        }\r\n        callHook$1(vm, 'beforeDestroy');\r\n        vm._isBeingDestroyed = true;\r\n        // remove self from parent\r\n        const parent = vm.$parent;\r\n        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\r\n            remove$2(parent.$children, vm);\r\n        }\r\n        // teardown scope. this includes both the render watcher and other\r\n        // watchers created\r\n        vm._scope.stop();\r\n        // remove reference from data ob\r\n        // frozen object may not have observer.\r\n        if (vm._data.__ob__) {\r\n            vm._data.__ob__.vmCount--;\r\n        }\r\n        // call the last hook...\r\n        vm._isDestroyed = true;\r\n        // invoke destroy hooks on current rendered tree\r\n        vm.__patch__(vm._vnode, null);\r\n        // fire destroyed hook\r\n        callHook$1(vm, 'destroyed');\r\n        // turn off all instance listeners.\r\n        vm.$off();\r\n        // remove __vue__ reference\r\n        if (vm.$el) {\r\n            vm.$el.__vue__ = null;\r\n        }\r\n        // release circular reference (#6759)\r\n        if (vm.$vnode) {\r\n            vm.$vnode.parent = null;\r\n        }\r\n    };\r\n}\r\nfunction mountComponent(vm, el, hydrating) {\r\n    vm.$el = el;\r\n    if (!vm.$options.render) {\r\n        // @ts-expect-error invalid type\r\n        vm.$options.render = createEmptyVNode;\r\n        {\r\n            /* istanbul ignore if */\r\n            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\r\n                vm.$options.el ||\r\n                el) {\r\n                warn('You are using the runtime-only build of Vue where the template ' +\r\n                    'compiler is not available. Either pre-compile the templates into ' +\r\n                    'render functions, or use the compiler-included build.', vm);\r\n            }\r\n            else {\r\n                warn('Failed to mount component: template or render function not defined.', vm);\r\n            }\r\n        }\r\n    }\r\n    callHook$1(vm, 'beforeMount');\r\n    let updateComponent;\r\n    /* istanbul ignore if */\r\n    if (config.performance && mark) {\r\n        updateComponent = () => {\r\n            const name = vm._name;\r\n            const id = vm._uid;\r\n            const startTag = `vue-perf-start:${id}`;\r\n            const endTag = `vue-perf-end:${id}`;\r\n            mark(startTag);\r\n            const vnode = vm._render();\r\n            mark(endTag);\r\n            measure(`vue ${name} render`, startTag, endTag);\r\n            mark(startTag);\r\n            vm._update(vnode, hydrating);\r\n            mark(endTag);\r\n            measure(`vue ${name} patch`, startTag, endTag);\r\n        };\r\n    }\r\n    else {\r\n        updateComponent = () => {\r\n            vm._update(vm._render(), hydrating);\r\n        };\r\n    }\r\n    const watcherOptions = {\r\n        before() {\r\n            if (vm._isMounted && !vm._isDestroyed) {\r\n                callHook$1(vm, 'beforeUpdate');\r\n            }\r\n        }\r\n    };\r\n    {\r\n        watcherOptions.onTrack = e => callHook$1(vm, 'renderTracked', [e]);\r\n        watcherOptions.onTrigger = e => callHook$1(vm, 'renderTriggered', [e]);\r\n    }\r\n    // we set this to vm._watcher inside the watcher's constructor\r\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\r\n    // component's mounted hook), which relies on vm._watcher being already defined\r\n    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);\r\n    hydrating = false;\r\n    // flush buffer for flush: \"pre\" watchers queued in setup()\r\n    const preWatchers = vm._preWatchers;\r\n    if (preWatchers) {\r\n        for (let i = 0; i < preWatchers.length; i++) {\r\n            preWatchers[i].run();\r\n        }\r\n    }\r\n    // manually mounted instance, call mounted on self\r\n    // mounted is called for render-created child components in its inserted hook\r\n    if (vm.$vnode == null) {\r\n        vm._isMounted = true;\r\n        callHook$1(vm, 'mounted');\r\n    }\r\n    return vm;\r\n}\r\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\r\n    {\r\n        isUpdatingChildComponent = true;\r\n    }\r\n    // determine whether component has slot children\r\n    // we need to do this before overwriting $options._renderChildren.\r\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\r\n    // dynamic slot names). Static scoped slots compiled from template has the\r\n    // \"$stable\" marker.\r\n    const newScopedSlots = parentVnode.data.scopedSlots;\r\n    const oldScopedSlots = vm.$scopedSlots;\r\n    const hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||\r\n        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\r\n        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||\r\n        (!newScopedSlots && vm.$scopedSlots.$key));\r\n    // Any static slot children from the parent may have changed during parent's\r\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\r\n    // update is necessary to ensure correctness.\r\n    let needsForceUpdate = !!(renderChildren || // has new static slots\r\n        vm.$options._renderChildren || // has old static slots\r\n        hasDynamicScopedSlot);\r\n    const prevVNode = vm.$vnode;\r\n    vm.$options._parentVnode = parentVnode;\r\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\r\n    if (vm._vnode) {\r\n        // update child tree's parent\r\n        vm._vnode.parent = parentVnode;\r\n    }\r\n    vm.$options._renderChildren = renderChildren;\r\n    // update $attrs and $listeners hash\r\n    // these are also reactive so they may trigger child update if the child\r\n    // used them during render\r\n    const attrs = parentVnode.data.attrs || emptyObject;\r\n    if (vm._attrsProxy) {\r\n        // force update if attrs are accessed and has changed since it may be\r\n        // passed to a child component.\r\n        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {\r\n            needsForceUpdate = true;\r\n        }\r\n    }\r\n    vm.$attrs = attrs;\r\n    // update listeners\r\n    listeners = listeners || emptyObject;\r\n    const prevListeners = vm.$options._parentListeners;\r\n    if (vm._listenersProxy) {\r\n        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');\r\n    }\r\n    vm.$listeners = vm.$options._parentListeners = listeners;\r\n    updateComponentListeners(vm, listeners, prevListeners);\r\n    // update props\r\n    if (propsData && vm.$options.props) {\r\n        toggleObserving(false);\r\n        const props = vm._props;\r\n        const propKeys = vm.$options._propKeys || [];\r\n        for (let i = 0; i < propKeys.length; i++) {\r\n            const key = propKeys[i];\r\n            const propOptions = vm.$options.props; // wtf flow?\r\n            props[key] = validateProp(key, propOptions, propsData, vm);\r\n        }\r\n        toggleObserving(true);\r\n        // keep a copy of raw propsData\r\n        vm.$options.propsData = propsData;\r\n    }\r\n    // resolve slots + force update if has children\r\n    if (needsForceUpdate) {\r\n        vm.$slots = resolveSlots(renderChildren, parentVnode.context);\r\n        vm.$forceUpdate();\r\n    }\r\n    {\r\n        isUpdatingChildComponent = false;\r\n    }\r\n}\r\nfunction isInInactiveTree(vm) {\r\n    while (vm && (vm = vm.$parent)) {\r\n        if (vm._inactive)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction activateChildComponent(vm, direct) {\r\n    if (direct) {\r\n        vm._directInactive = false;\r\n        if (isInInactiveTree(vm)) {\r\n            return;\r\n        }\r\n    }\r\n    else if (vm._directInactive) {\r\n        return;\r\n    }\r\n    if (vm._inactive || vm._inactive === null) {\r\n        vm._inactive = false;\r\n        for (let i = 0; i < vm.$children.length; i++) {\r\n            activateChildComponent(vm.$children[i]);\r\n        }\r\n        callHook$1(vm, 'activated');\r\n    }\r\n}\r\nfunction deactivateChildComponent(vm, direct) {\r\n    if (direct) {\r\n        vm._directInactive = true;\r\n        if (isInInactiveTree(vm)) {\r\n            return;\r\n        }\r\n    }\r\n    if (!vm._inactive) {\r\n        vm._inactive = true;\r\n        for (let i = 0; i < vm.$children.length; i++) {\r\n            deactivateChildComponent(vm.$children[i]);\r\n        }\r\n        callHook$1(vm, 'deactivated');\r\n    }\r\n}\r\nfunction callHook$1(vm, hook, args, setContext = true) {\r\n    // #7573 disable dep collection when invoking lifecycle hooks\r\n    pushTarget();\r\n    const prev = currentInstance;\r\n    setContext && setCurrentInstance(vm);\r\n    const handlers = vm.$options[hook];\r\n    const info = `${hook} hook`;\r\n    if (handlers) {\r\n        for (let i = 0, j = handlers.length; i < j; i++) {\r\n            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);\r\n        }\r\n    }\r\n    if (vm._hasHookEvent) {\r\n        vm.$emit('hook:' + hook);\r\n    }\r\n    setContext && setCurrentInstance(prev);\r\n    popTarget();\r\n}\n\nconst MAX_UPDATE_COUNT = 100;\r\nconst queue = [];\r\nconst activatedChildren = [];\r\nlet has = {};\r\nlet circular = {};\r\nlet waiting = false;\r\nlet flushing = false;\r\nlet index = 0;\r\n/**\r\n * Reset the scheduler's state.\r\n */\r\nfunction resetSchedulerState() {\r\n    index = queue.length = activatedChildren.length = 0;\r\n    has = {};\r\n    {\r\n        circular = {};\r\n    }\r\n    waiting = flushing = false;\r\n}\r\n// Async edge case #6566 requires saving the timestamp when event listeners are\r\n// attached. However, calling performance.now() has a perf overhead especially\r\n// if the page has thousands of event listeners. Instead, we take a timestamp\r\n// every time the scheduler flushes and use that for all event listeners\r\n// attached during that flush.\r\nlet currentFlushTimestamp = 0;\r\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nlet getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\n// All IE versions use low-res event timestamps, and have problematic clock\r\n// implementations (#9632)\r\nif (inBrowser && !isIE) {\r\n    const performance = window.performance;\r\n    if (performance &&\r\n        typeof performance.now === 'function' &&\r\n        getNow() > document.createEvent('Event').timeStamp) {\r\n        // if the event timestamp, although evaluated AFTER the Date.now(), is\r\n        // smaller than it, it means the event is using a hi-res timestamp,\r\n        // and we need to use the hi-res version for event listener timestamps as\r\n        // well.\r\n        getNow = () => performance.now();\r\n    }\r\n}\r\nconst sortCompareFn = (a, b) => {\r\n    if (a.post) {\r\n        if (!b.post)\r\n            return 1;\r\n    }\r\n    else if (b.post) {\r\n        return -1;\r\n    }\r\n    return a.id - b.id;\r\n};\r\n/**\r\n * Flush both queues and run the watchers.\r\n */\r\nfunction flushSchedulerQueue() {\r\n    currentFlushTimestamp = getNow();\r\n    flushing = true;\r\n    let watcher, id;\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child)\r\n    // 2. A component's user watchers are run before its render watcher (because\r\n    //    user watchers are created before the render watcher)\r\n    // 3. If a component is destroyed during a parent component's watcher run,\r\n    //    its watchers can be skipped.\r\n    queue.sort(sortCompareFn);\r\n    // do not cache length because more watchers might be pushed\r\n    // as we run existing watchers\r\n    for (index = 0; index < queue.length; index++) {\r\n        watcher = queue[index];\r\n        if (watcher.before) {\r\n            watcher.before();\r\n        }\r\n        id = watcher.id;\r\n        has[id] = null;\r\n        watcher.run();\r\n        // in dev build, check and stop circular updates.\r\n        if (has[id] != null) {\r\n            circular[id] = (circular[id] || 0) + 1;\r\n            if (circular[id] > MAX_UPDATE_COUNT) {\r\n                warn('You may have an infinite update loop ' +\r\n                    (watcher.user\r\n                        ? `in watcher with expression \"${watcher.expression}\"`\r\n                        : `in a component render function.`), watcher.vm);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // keep copies of post queues before resetting state\r\n    const activatedQueue = activatedChildren.slice();\r\n    const updatedQueue = queue.slice();\r\n    resetSchedulerState();\r\n    // call component updated and activated hooks\r\n    callActivatedHooks(activatedQueue);\r\n    callUpdatedHooks(updatedQueue);\r\n    // devtool hook\r\n    /* istanbul ignore if */\r\n    if (devtools && config.devtools) {\r\n        devtools.emit('flush');\r\n    }\r\n}\r\nfunction callUpdatedHooks(queue) {\r\n    let i = queue.length;\r\n    while (i--) {\r\n        const watcher = queue[i];\r\n        const vm = watcher.vm;\r\n        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\r\n            callHook$1(vm, 'updated');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Queue a kept-alive component that was activated during patch.\r\n * The queue will be processed after the entire tree has been patched.\r\n */\r\nfunction queueActivatedComponent(vm) {\r\n    // setting _inactive to false here so that a render function can\r\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\r\n    vm._inactive = false;\r\n    activatedChildren.push(vm);\r\n}\r\nfunction callActivatedHooks(queue) {\r\n    for (let i = 0; i < queue.length; i++) {\r\n        queue[i]._inactive = true;\r\n        activateChildComponent(queue[i], true /* true */);\r\n    }\r\n}\r\n/**\r\n * Push a watcher into the watcher queue.\r\n * Jobs with duplicate IDs will be skipped unless it's\r\n * pushed when the queue is being flushed.\r\n */\r\nfunction queueWatcher(watcher) {\r\n    const id = watcher.id;\r\n    if (has[id] != null) {\r\n        return;\r\n    }\r\n    if (watcher === Dep.target && watcher.noRecurse) {\r\n        return;\r\n    }\r\n    has[id] = true;\r\n    if (!flushing) {\r\n        queue.push(watcher);\r\n    }\r\n    else {\r\n        // if already flushing, splice the watcher based on its id\r\n        // if already past its id, it will be run next immediately.\r\n        let i = queue.length - 1;\r\n        while (i > index && queue[i].id > watcher.id) {\r\n            i--;\r\n        }\r\n        queue.splice(i + 1, 0, watcher);\r\n    }\r\n    // queue the flush\r\n    if (!waiting) {\r\n        waiting = true;\r\n        if (!config.async) {\r\n            flushSchedulerQueue();\r\n            return;\r\n        }\r\n        nextTick(flushSchedulerQueue);\r\n    }\r\n}\n\nfunction initProvide(vm) {\r\n    const provideOption = vm.$options.provide;\r\n    if (provideOption) {\r\n        const provided = isFunction(provideOption)\r\n            ? provideOption.call(vm)\r\n            : provideOption;\r\n        if (!isObject(provided)) {\r\n            return;\r\n        }\r\n        const source = resolveProvided(vm);\r\n        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to\r\n        // iterate the keys ourselves.\r\n        const keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            const key = keys[i];\r\n            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));\r\n        }\r\n    }\r\n}\r\nfunction initInjections(vm) {\r\n    const result = resolveInject(vm.$options.inject, vm);\r\n    if (result) {\r\n        toggleObserving(false);\r\n        Object.keys(result).forEach(key => {\r\n            /* istanbul ignore else */\r\n            {\r\n                defineReactive(vm, key, result[key], () => {\r\n                    warn(`Avoid mutating an injected value directly since the changes will be ` +\r\n                        `overwritten whenever the provided component re-renders. ` +\r\n                        `injection being mutated: \"${key}\"`, vm);\r\n                });\r\n            }\r\n        });\r\n        toggleObserving(true);\r\n    }\r\n}\r\nfunction resolveInject(inject, vm) {\r\n    if (inject) {\r\n        // inject is :any because flow is not smart enough to figure out cached\r\n        const result = Object.create(null);\r\n        const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            const key = keys[i];\r\n            // #6574 in case the inject object is observed...\r\n            if (key === '__ob__')\r\n                continue;\r\n            const provideKey = inject[key].from;\r\n            if (provideKey in vm._provided) {\r\n                result[key] = vm._provided[provideKey];\r\n            }\r\n            else if ('default' in inject[key]) {\r\n                const provideDefault = inject[key].default;\r\n                result[key] = isFunction(provideDefault)\r\n                    ? provideDefault.call(vm)\r\n                    : provideDefault;\r\n            }\r\n            else {\r\n                warn(`Injection \"${key}\" not found`, vm);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\r\n    const options = Ctor.options;\r\n    // ensure the createElement function in functional components\r\n    // gets a unique context - this is necessary for correct named slot check\r\n    let contextVm;\r\n    if (hasOwn(parent, '_uid')) {\r\n        contextVm = Object.create(parent);\r\n        contextVm._original = parent;\r\n    }\r\n    else {\r\n        // the context vm passed in is a functional context as well.\r\n        // in this case we want to make sure we are able to get a hold to the\r\n        // real context instance.\r\n        contextVm = parent;\r\n        // @ts-ignore\r\n        parent = parent._original;\r\n    }\r\n    const isCompiled = isTrue(options._compiled);\r\n    const needNormalization = !isCompiled;\r\n    this.data = data;\r\n    this.props = props;\r\n    this.children = children;\r\n    this.parent = parent;\r\n    this.listeners = data.on || emptyObject;\r\n    this.injections = resolveInject(options.inject, parent);\r\n    this.slots = () => {\r\n        if (!this.$slots) {\r\n            normalizeScopedSlots(parent, data.scopedSlots, (this.$slots = resolveSlots(children, parent)));\r\n        }\r\n        return this.$slots;\r\n    };\r\n    Object.defineProperty(this, 'scopedSlots', {\r\n        enumerable: true,\r\n        get() {\r\n            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());\r\n        }\r\n    });\r\n    // support for compiled functional template\r\n    if (isCompiled) {\r\n        // exposing $options for renderStatic()\r\n        this.$options = options;\r\n        // pre-resolve slots for renderSlot()\r\n        this.$slots = this.slots();\r\n        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);\r\n    }\r\n    if (options._scopeId) {\r\n        this._c = (a, b, c, d) => {\r\n            const vnode = createElement$1(contextVm, a, b, c, d, needNormalization);\r\n            if (vnode && !isArray(vnode)) {\r\n                vnode.fnScopeId = options._scopeId;\r\n                vnode.fnContext = parent;\r\n            }\r\n            return vnode;\r\n        };\r\n    }\r\n    else {\r\n        this._c = (a, b, c, d) => createElement$1(contextVm, a, b, c, d, needNormalization);\r\n    }\r\n}\r\ninstallRenderHelpers(FunctionalRenderContext.prototype);\r\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\r\n    const options = Ctor.options;\r\n    const props = {};\r\n    const propOptions = options.props;\r\n    if (isDef(propOptions)) {\r\n        for (const key in propOptions) {\r\n            props[key] = validateProp(key, propOptions, propsData || emptyObject);\r\n        }\r\n    }\r\n    else {\r\n        if (isDef(data.attrs))\r\n            mergeProps(props, data.attrs);\r\n        if (isDef(data.props))\r\n            mergeProps(props, data.props);\r\n    }\r\n    const renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\r\n    const vnode = options.render.call(null, renderContext._c, renderContext);\r\n    if (vnode instanceof VNode) {\r\n        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\r\n    }\r\n    else if (isArray(vnode)) {\r\n        const vnodes = normalizeChildren(vnode) || [];\r\n        const res = new Array(vnodes.length);\r\n        for (let i = 0; i < vnodes.length; i++) {\r\n            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\r\n        }\r\n        return res;\r\n    }\r\n}\r\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\r\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\r\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\r\n    // that should not be matched to match.\r\n    const clone = cloneVNode(vnode);\r\n    clone.fnContext = contextVm;\r\n    clone.fnOptions = options;\r\n    {\r\n        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =\r\n            renderContext;\r\n    }\r\n    if (data.slot) {\r\n        (clone.data || (clone.data = {})).slot = data.slot;\r\n    }\r\n    return clone;\r\n}\r\nfunction mergeProps(to, from) {\r\n    for (const key in from) {\r\n        to[camelize(key)] = from[key];\r\n    }\r\n}\n\nfunction getComponentName(options) {\r\n    return options.name || options.__name || options._componentTag;\r\n}\r\n// inline hooks to be invoked on component VNodes during patch\r\nconst componentVNodeHooks = {\r\n    init(vnode, hydrating) {\r\n        if (vnode.componentInstance &&\r\n            !vnode.componentInstance._isDestroyed &&\r\n            vnode.data.keepAlive) {\r\n            // kept-alive components, treat as a patch\r\n            const mountedNode = vnode; // work around flow\r\n            componentVNodeHooks.prepatch(mountedNode, mountedNode);\r\n        }\r\n        else {\r\n            const child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));\r\n            child.$mount(hydrating ? vnode.elm : undefined, hydrating);\r\n        }\r\n    },\r\n    prepatch(oldVnode, vnode) {\r\n        const options = vnode.componentOptions;\r\n        const child = (vnode.componentInstance = oldVnode.componentInstance);\r\n        updateChildComponent(child, options.propsData, // updated props\r\n        options.listeners, // updated listeners\r\n        vnode, // new parent vnode\r\n        options.children // new children\r\n        );\r\n    },\r\n    insert(vnode) {\r\n        const { context, componentInstance } = vnode;\r\n        if (!componentInstance._isMounted) {\r\n            componentInstance._isMounted = true;\r\n            callHook$1(componentInstance, 'mounted');\r\n        }\r\n        if (vnode.data.keepAlive) {\r\n            if (context._isMounted) {\r\n                // vue-router#1212\r\n                // During updates, a kept-alive component's child components may\r\n                // change, so directly walking the tree here may call activated hooks\r\n                // on incorrect children. Instead we push them into a queue which will\r\n                // be processed after the whole patch process ended.\r\n                queueActivatedComponent(componentInstance);\r\n            }\r\n            else {\r\n                activateChildComponent(componentInstance, true /* direct */);\r\n            }\r\n        }\r\n    },\r\n    destroy(vnode) {\r\n        const { componentInstance } = vnode;\r\n        if (!componentInstance._isDestroyed) {\r\n            if (!vnode.data.keepAlive) {\r\n                componentInstance.$destroy();\r\n            }\r\n            else {\r\n                deactivateChildComponent(componentInstance, true /* direct */);\r\n            }\r\n        }\r\n    }\r\n};\r\nconst hooksToMerge = Object.keys(componentVNodeHooks);\r\nfunction createComponent(Ctor, data, context, children, tag) {\r\n    if (isUndef(Ctor)) {\r\n        return;\r\n    }\r\n    const baseCtor = context.$options._base;\r\n    // plain options object: turn it into a constructor\r\n    if (isObject(Ctor)) {\r\n        Ctor = baseCtor.extend(Ctor);\r\n    }\r\n    // if at this stage it's not a constructor or an async component factory,\r\n    // reject.\r\n    if (typeof Ctor !== 'function') {\r\n        {\r\n            warn(`Invalid Component definition: ${String(Ctor)}`, context);\r\n        }\r\n        return;\r\n    }\r\n    // async component\r\n    let asyncFactory;\r\n    // @ts-expect-error\r\n    if (isUndef(Ctor.cid)) {\r\n        asyncFactory = Ctor;\r\n        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\r\n        if (Ctor === undefined) {\r\n            // return a placeholder node for async component, which is rendered\r\n            // as a comment node but preserves all the raw information for the node.\r\n            // the information will be used for async server-rendering and hydration.\r\n            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\r\n        }\r\n    }\r\n    data = data || {};\r\n    // resolve constructor options in case global mixins are applied after\r\n    // component constructor creation\r\n    resolveConstructorOptions(Ctor);\r\n    // transform component v-model data into props & events\r\n    if (isDef(data.model)) {\r\n        // @ts-expect-error\r\n        transformModel(Ctor.options, data);\r\n    }\r\n    // extract props\r\n    // @ts-expect-error\r\n    const propsData = extractPropsFromVNodeData(data, Ctor, tag);\r\n    // functional component\r\n    // @ts-expect-error\r\n    if (isTrue(Ctor.options.functional)) {\r\n        return createFunctionalComponent(Ctor, propsData, data, context, children);\r\n    }\r\n    // extract listeners, since these needs to be treated as\r\n    // child component listeners instead of DOM listeners\r\n    const listeners = data.on;\r\n    // replace with listeners with .native modifier\r\n    // so it gets processed during parent component patch.\r\n    data.on = data.nativeOn;\r\n    // @ts-expect-error\r\n    if (isTrue(Ctor.options.abstract)) {\r\n        // abstract components do not keep anything\r\n        // other than props & listeners & slot\r\n        // work around flow\r\n        const slot = data.slot;\r\n        data = {};\r\n        if (slot) {\r\n            data.slot = slot;\r\n        }\r\n    }\r\n    // install component management hooks onto the placeholder node\r\n    installComponentHooks(data);\r\n    // return a placeholder vnode\r\n    // @ts-expect-error\r\n    const name = getComponentName(Ctor.options) || tag;\r\n    const vnode = new VNode(\r\n    // @ts-expect-error\r\n    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, \r\n    // @ts-expect-error\r\n    { Ctor, propsData, listeners, tag, children }, asyncFactory);\r\n    return vnode;\r\n}\r\nfunction createComponentInstanceForVnode(\r\n// we know it's MountedComponentVNode but flow doesn't\r\nvnode, \r\n// activeInstance in lifecycle state\r\nparent) {\r\n    const options = {\r\n        _isComponent: true,\r\n        _parentVnode: vnode,\r\n        parent\r\n    };\r\n    // check inline-template render functions\r\n    const inlineTemplate = vnode.data.inlineTemplate;\r\n    if (isDef(inlineTemplate)) {\r\n        options.render = inlineTemplate.render;\r\n        options.staticRenderFns = inlineTemplate.staticRenderFns;\r\n    }\r\n    return new vnode.componentOptions.Ctor(options);\r\n}\r\nfunction installComponentHooks(data) {\r\n    const hooks = data.hook || (data.hook = {});\r\n    for (let i = 0; i < hooksToMerge.length; i++) {\r\n        const key = hooksToMerge[i];\r\n        const existing = hooks[key];\r\n        const toMerge = componentVNodeHooks[key];\r\n        // @ts-expect-error\r\n        if (existing !== toMerge && !(existing && existing._merged)) {\r\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;\r\n        }\r\n    }\r\n}\r\nfunction mergeHook(f1, f2) {\r\n    const merged = (a, b) => {\r\n        // flow complains about extra args which is why we use any\r\n        f1(a, b);\r\n        f2(a, b);\r\n    };\r\n    merged._merged = true;\r\n    return merged;\r\n}\r\n// transform component v-model info (value and callback) into\r\n// prop and event handler respectively.\r\nfunction transformModel(options, data) {\r\n    const prop = (options.model && options.model.prop) || 'value';\r\n    const event = (options.model && options.model.event) || 'input';\r\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\r\n    const on = data.on || (data.on = {});\r\n    const existing = on[event];\r\n    const callback = data.model.callback;\r\n    if (isDef(existing)) {\r\n        if (isArray(existing)\r\n            ? existing.indexOf(callback) === -1\r\n            : existing !== callback) {\r\n            on[event] = [callback].concat(existing);\r\n        }\r\n    }\r\n    else {\r\n        on[event] = callback;\r\n    }\r\n}\n\nlet warn = noop;\r\nlet tip = noop;\r\nlet generateComponentTrace; // work around flow check\r\nlet formatComponentName;\r\n{\r\n    const hasConsole = typeof console !== 'undefined';\r\n    const classifyRE = /(?:^|[-_])(\\w)/g;\r\n    const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n    warn = (msg, vm = currentInstance) => {\r\n        const trace = vm ? generateComponentTrace(vm) : '';\r\n        if (config.warnHandler) {\r\n            config.warnHandler.call(null, msg, vm, trace);\r\n        }\r\n        else if (hasConsole && !config.silent) {\r\n            console.error(`[Vue warn]: ${msg}${trace}`);\r\n        }\r\n    };\r\n    tip = (msg, vm) => {\r\n        if (hasConsole && !config.silent) {\r\n            console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ''));\r\n        }\r\n    };\r\n    formatComponentName = (vm, includeFile) => {\r\n        if (vm.$root === vm) {\r\n            return '<Root>';\r\n        }\r\n        const options = isFunction(vm) && vm.cid != null\r\n            ? vm.options\r\n            : vm._isVue\r\n                ? vm.$options || vm.constructor.options\r\n                : vm;\r\n        let name = getComponentName(options);\r\n        const file = options.__file;\r\n        if (!name && file) {\r\n            const match = file.match(/([^/\\\\]+)\\.vue$/);\r\n            name = match && match[1];\r\n        }\r\n        return ((name ? `<${classify(name)}>` : `<Anonymous>`) +\r\n            (file && includeFile !== false ? ` at ${file}` : ''));\r\n    };\r\n    const repeat = (str, n) => {\r\n        let res = '';\r\n        while (n) {\r\n            if (n % 2 === 1)\r\n                res += str;\r\n            if (n > 1)\r\n                str += str;\r\n            n >>= 1;\r\n        }\r\n        return res;\r\n    };\r\n    generateComponentTrace = (vm) => {\r\n        if (vm._isVue && vm.$parent) {\r\n            const tree = [];\r\n            let currentRecursiveSequence = 0;\r\n            while (vm) {\r\n                if (tree.length > 0) {\r\n                    const last = tree[tree.length - 1];\r\n                    if (last.constructor === vm.constructor) {\r\n                        currentRecursiveSequence++;\r\n                        vm = vm.$parent;\r\n                        continue;\r\n                    }\r\n                    else if (currentRecursiveSequence > 0) {\r\n                        tree[tree.length - 1] = [last, currentRecursiveSequence];\r\n                        currentRecursiveSequence = 0;\r\n                    }\r\n                }\r\n                tree.push(vm);\r\n                vm = vm.$parent;\r\n            }\r\n            return ('\\n\\nfound in\\n\\n' +\r\n                tree\r\n                    .map((vm, i) => `${i === 0 ? '---> ' : repeat(' ', 5 + i * 2)}${isArray(vm)\r\n                    ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`\r\n                    : formatComponentName(vm)}`)\r\n                    .join('\\n'));\r\n        }\r\n        else {\r\n            return `\\n\\n(found in ${formatComponentName(vm)})`;\r\n        }\r\n    };\r\n}\n\n/**\r\n * Option overwriting strategies are functions that handle\r\n * how to merge a parent option value and a child option\r\n * value into the final value.\r\n */\r\nconst strats = config.optionMergeStrategies;\r\n/**\r\n * Options with restrictions\r\n */\r\n{\r\n    strats.el = strats.propsData = function (parent, child, vm, key) {\r\n        if (!vm) {\r\n            warn(`option \"${key}\" can only be used during instance ` +\r\n                'creation with the `new` keyword.');\r\n        }\r\n        return defaultStrat(parent, child);\r\n    };\r\n}\r\n/**\r\n * Helper that recursively merges two data objects together.\r\n */\r\nfunction mergeData(to, from) {\r\n    if (!from)\r\n        return to;\r\n    let key, toVal, fromVal;\r\n    const keys = hasSymbol\r\n        ? Reflect.ownKeys(from)\r\n        : Object.keys(from);\r\n    for (let i = 0; i < keys.length; i++) {\r\n        key = keys[i];\r\n        // in case the object is already observed...\r\n        if (key === '__ob__')\r\n            continue;\r\n        toVal = to[key];\r\n        fromVal = from[key];\r\n        if (!hasOwn(to, key)) {\r\n            set(to, key, fromVal);\r\n        }\r\n        else if (toVal !== fromVal &&\r\n            isPlainObject(toVal) &&\r\n            isPlainObject(fromVal)) {\r\n            mergeData(toVal, fromVal);\r\n        }\r\n    }\r\n    return to;\r\n}\r\n/**\r\n * Data\r\n */\r\nfunction mergeDataOrFn(parentVal, childVal, vm) {\r\n    if (!vm) {\r\n        // in a Vue.extend merge, both should be functions\r\n        if (!childVal) {\r\n            return parentVal;\r\n        }\r\n        if (!parentVal) {\r\n            return childVal;\r\n        }\r\n        // when parentVal & childVal are both present,\r\n        // we need to return a function that returns the\r\n        // merged result of both functions... no need to\r\n        // check if parentVal is a function here because\r\n        // it has to be a function to pass previous merges.\r\n        return function mergedDataFn() {\r\n            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);\r\n        };\r\n    }\r\n    else {\r\n        return function mergedInstanceDataFn() {\r\n            // instance merge\r\n            const instanceData = isFunction(childVal)\r\n                ? childVal.call(vm, vm)\r\n                : childVal;\r\n            const defaultData = isFunction(parentVal)\r\n                ? parentVal.call(vm, vm)\r\n                : parentVal;\r\n            if (instanceData) {\r\n                return mergeData(instanceData, defaultData);\r\n            }\r\n            else {\r\n                return defaultData;\r\n            }\r\n        };\r\n    }\r\n}\r\nstrats.data = function (parentVal, childVal, vm) {\r\n    if (!vm) {\r\n        if (childVal && typeof childVal !== 'function') {\r\n            warn('The \"data\" option should be a function ' +\r\n                    'that returns a per-instance value in component ' +\r\n                    'definitions.', vm);\r\n            return parentVal;\r\n        }\r\n        return mergeDataOrFn(parentVal, childVal);\r\n    }\r\n    return mergeDataOrFn(parentVal, childVal, vm);\r\n};\r\n/**\r\n * Hooks and props are merged as arrays.\r\n */\r\nfunction mergeLifecycleHook(parentVal, childVal) {\r\n    const res = childVal\r\n        ? parentVal\r\n            ? parentVal.concat(childVal)\r\n            : isArray(childVal)\r\n                ? childVal\r\n                : [childVal]\r\n        : parentVal;\r\n    return res ? dedupeHooks(res) : res;\r\n}\r\nfunction dedupeHooks(hooks) {\r\n    const res = [];\r\n    for (let i = 0; i < hooks.length; i++) {\r\n        if (res.indexOf(hooks[i]) === -1) {\r\n            res.push(hooks[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nLIFECYCLE_HOOKS.forEach(hook => {\r\n    strats[hook] = mergeLifecycleHook;\r\n});\r\n/**\r\n * Assets\r\n *\r\n * When a vm is present (instance creation), we need to do\r\n * a three-way merge between constructor options, instance\r\n * options and parent options.\r\n */\r\nfunction mergeAssets(parentVal, childVal, vm, key) {\r\n    const res = Object.create(parentVal || null);\r\n    if (childVal) {\r\n        assertObjectType(key, childVal, vm);\r\n        return extend(res, childVal);\r\n    }\r\n    else {\r\n        return res;\r\n    }\r\n}\r\nASSET_TYPES.forEach(function (type) {\r\n    strats[type + 's'] = mergeAssets;\r\n});\r\n/**\r\n * Watchers.\r\n *\r\n * Watchers hashes should not overwrite one\r\n * another, so we merge them as arrays.\r\n */\r\nstrats.watch = function (parentVal, childVal, vm, key) {\r\n    // work around Firefox's Object.prototype.watch...\r\n    //@ts-expect-error work around\r\n    if (parentVal === nativeWatch)\r\n        parentVal = undefined;\r\n    //@ts-expect-error work around\r\n    if (childVal === nativeWatch)\r\n        childVal = undefined;\r\n    /* istanbul ignore if */\r\n    if (!childVal)\r\n        return Object.create(parentVal || null);\r\n    {\r\n        assertObjectType(key, childVal, vm);\r\n    }\r\n    if (!parentVal)\r\n        return childVal;\r\n    const ret = {};\r\n    extend(ret, parentVal);\r\n    for (const key in childVal) {\r\n        let parent = ret[key];\r\n        const child = childVal[key];\r\n        if (parent && !isArray(parent)) {\r\n            parent = [parent];\r\n        }\r\n        ret[key] = parent ? parent.concat(child) : isArray(child) ? child : [child];\r\n    }\r\n    return ret;\r\n};\r\n/**\r\n * Other object hashes.\r\n */\r\nstrats.props =\r\n    strats.methods =\r\n        strats.inject =\r\n            strats.computed =\r\n                function (parentVal, childVal, vm, key) {\r\n                    if (childVal && true) {\r\n                        assertObjectType(key, childVal, vm);\r\n                    }\r\n                    if (!parentVal)\r\n                        return childVal;\r\n                    const ret = Object.create(null);\r\n                    extend(ret, parentVal);\r\n                    if (childVal)\r\n                        extend(ret, childVal);\r\n                    return ret;\r\n                };\r\nstrats.provide = mergeDataOrFn;\r\n/**\r\n * Default strategy.\r\n */\r\nconst defaultStrat = function (parentVal, childVal) {\r\n    return childVal === undefined ? parentVal : childVal;\r\n};\r\n/**\r\n * Validate component names\r\n */\r\nfunction checkComponents(options) {\r\n    for (const key in options.components) {\r\n        validateComponentName(key);\r\n    }\r\n}\r\nfunction validateComponentName(name) {\r\n    if (!new RegExp(`^[a-zA-Z][\\\\-\\\\.0-9_${unicodeRegExp.source}]*$`).test(name)) {\r\n        warn('Invalid component name: \"' +\r\n            name +\r\n            '\". Component names ' +\r\n            'should conform to valid custom element name in html5 specification.');\r\n    }\r\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\r\n        warn('Do not use built-in or reserved HTML elements as component ' +\r\n            'id: ' +\r\n            name);\r\n    }\r\n}\r\n/**\r\n * Ensure all props option syntax are normalized into the\r\n * Object-based format.\r\n */\r\nfunction normalizeProps(options, vm) {\r\n    const props = options.props;\r\n    if (!props)\r\n        return;\r\n    const res = {};\r\n    let i, val, name;\r\n    if (isArray(props)) {\r\n        i = props.length;\r\n        while (i--) {\r\n            val = props[i];\r\n            if (typeof val === 'string') {\r\n                name = camelize(val);\r\n                res[name] = { type: null };\r\n            }\r\n            else {\r\n                warn('props must be strings when using array syntax.');\r\n            }\r\n        }\r\n    }\r\n    else if (isPlainObject(props)) {\r\n        for (const key in props) {\r\n            val = props[key];\r\n            name = camelize(key);\r\n            res[name] = isPlainObject(val) ? val : { type: val };\r\n        }\r\n    }\r\n    else {\r\n        warn(`Invalid value for option \"props\": expected an Array or an Object, ` +\r\n            `but got ${toRawType(props)}.`, vm);\r\n    }\r\n    options.props = res;\r\n}\r\n/**\r\n * Normalize all injections into Object-based format\r\n */\r\nfunction normalizeInject(options, vm) {\r\n    const inject = options.inject;\r\n    if (!inject)\r\n        return;\r\n    const normalized = (options.inject = {});\r\n    if (isArray(inject)) {\r\n        for (let i = 0; i < inject.length; i++) {\r\n            normalized[inject[i]] = { from: inject[i] };\r\n        }\r\n    }\r\n    else if (isPlainObject(inject)) {\r\n        for (const key in inject) {\r\n            const val = inject[key];\r\n            normalized[key] = isPlainObject(val)\r\n                ? extend({ from: key }, val)\r\n                : { from: val };\r\n        }\r\n    }\r\n    else {\r\n        warn(`Invalid value for option \"inject\": expected an Array or an Object, ` +\r\n            `but got ${toRawType(inject)}.`, vm);\r\n    }\r\n}\r\n/**\r\n * Normalize raw function directives into object format.\r\n */\r\nfunction normalizeDirectives$1(options) {\r\n    const dirs = options.directives;\r\n    if (dirs) {\r\n        for (const key in dirs) {\r\n            const def = dirs[key];\r\n            if (isFunction(def)) {\r\n                dirs[key] = { bind: def, update: def };\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction assertObjectType(name, value, vm) {\r\n    if (!isPlainObject(value)) {\r\n        warn(`Invalid value for option \"${name}\": expected an Object, ` +\r\n            `but got ${toRawType(value)}.`, vm);\r\n    }\r\n}\r\n/**\r\n * Merge two option objects into a new one.\r\n * Core utility used in both instantiation and inheritance.\r\n */\r\nfunction mergeOptions(parent, child, vm) {\r\n    {\r\n        checkComponents(child);\r\n    }\r\n    if (isFunction(child)) {\r\n        // @ts-expect-error\r\n        child = child.options;\r\n    }\r\n    normalizeProps(child, vm);\r\n    normalizeInject(child, vm);\r\n    normalizeDirectives$1(child);\r\n    // Apply extends and mixins on the child options,\r\n    // but only if it is a raw options object that isn't\r\n    // the result of another mergeOptions call.\r\n    // Only merged options has the _base property.\r\n    if (!child._base) {\r\n        if (child.extends) {\r\n            parent = mergeOptions(parent, child.extends, vm);\r\n        }\r\n        if (child.mixins) {\r\n            for (let i = 0, l = child.mixins.length; i < l; i++) {\r\n                parent = mergeOptions(parent, child.mixins[i], vm);\r\n            }\r\n        }\r\n    }\r\n    const options = {};\r\n    let key;\r\n    for (key in parent) {\r\n        mergeField(key);\r\n    }\r\n    for (key in child) {\r\n        if (!hasOwn(parent, key)) {\r\n            mergeField(key);\r\n        }\r\n    }\r\n    function mergeField(key) {\r\n        const strat = strats[key] || defaultStrat;\r\n        options[key] = strat(parent[key], child[key], vm, key);\r\n    }\r\n    return options;\r\n}\r\n/**\r\n * Resolve an asset.\r\n * This function is used because child instances need access\r\n * to assets defined in its ancestor chain.\r\n */\r\nfunction resolveAsset(options, type, id, warnMissing) {\r\n    /* istanbul ignore if */\r\n    if (typeof id !== 'string') {\r\n        return;\r\n    }\r\n    const assets = options[type];\r\n    // check local registration variations first\r\n    if (hasOwn(assets, id))\r\n        return assets[id];\r\n    const camelizedId = camelize(id);\r\n    if (hasOwn(assets, camelizedId))\r\n        return assets[camelizedId];\r\n    const PascalCaseId = capitalize(camelizedId);\r\n    if (hasOwn(assets, PascalCaseId))\r\n        return assets[PascalCaseId];\r\n    // fallback to prototype chain\r\n    const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\r\n    if (warnMissing && !res) {\r\n        warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);\r\n    }\r\n    return res;\r\n}\n\nfunction validateProp(key, propOptions, propsData, vm) {\r\n    const prop = propOptions[key];\r\n    const absent = !hasOwn(propsData, key);\r\n    let value = propsData[key];\r\n    // boolean casting\r\n    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n    if (booleanIndex > -1) {\r\n        if (absent && !hasOwn(prop, 'default')) {\r\n            value = false;\r\n        }\r\n        else if (value === '' || value === hyphenate(key)) {\r\n            // only cast empty string / same name to boolean if\r\n            // boolean has higher priority\r\n            const stringIndex = getTypeIndex(String, prop.type);\r\n            if (stringIndex < 0 || booleanIndex < stringIndex) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    // check default value\r\n    if (value === undefined) {\r\n        value = getPropDefaultValue(vm, prop, key);\r\n        // since the default value is a fresh copy,\r\n        // make sure to observe it.\r\n        const prevShouldObserve = shouldObserve;\r\n        toggleObserving(true);\r\n        observe(value);\r\n        toggleObserving(prevShouldObserve);\r\n    }\r\n    {\r\n        assertProp(prop, key, value, vm, absent);\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Get the default value of a prop.\r\n */\r\nfunction getPropDefaultValue(vm, prop, key) {\r\n    // no default, return undefined\r\n    if (!hasOwn(prop, 'default')) {\r\n        return undefined;\r\n    }\r\n    const def = prop.default;\r\n    // warn against non-factory defaults for Object & Array\r\n    if (isObject(def)) {\r\n        warn('Invalid default value for prop \"' +\r\n            key +\r\n            '\": ' +\r\n            'Props with type Object/Array must use a factory function ' +\r\n            'to return the default value.', vm);\r\n    }\r\n    // the raw prop value was also undefined from previous render,\r\n    // return previous default value to avoid unnecessary watcher trigger\r\n    if (vm &&\r\n        vm.$options.propsData &&\r\n        vm.$options.propsData[key] === undefined &&\r\n        vm._props[key] !== undefined) {\r\n        return vm._props[key];\r\n    }\r\n    // call factory function for non-Function types\r\n    // a value is Function if its prototype is function even across different execution context\r\n    return isFunction(def) && getType(prop.type) !== 'Function'\r\n        ? def.call(vm)\r\n        : def;\r\n}\r\n/**\r\n * Assert whether a prop is valid.\r\n */\r\nfunction assertProp(prop, name, value, vm, absent) {\r\n    if (prop.required && absent) {\r\n        warn('Missing required prop: \"' + name + '\"', vm);\r\n        return;\r\n    }\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    let type = prop.type;\r\n    let valid = !type || type === true;\r\n    const expectedTypes = [];\r\n    if (type) {\r\n        if (!isArray(type)) {\r\n            type = [type];\r\n        }\r\n        for (let i = 0; i < type.length && !valid; i++) {\r\n            const assertedType = assertType(value, type[i], vm);\r\n            expectedTypes.push(assertedType.expectedType || '');\r\n            valid = assertedType.valid;\r\n        }\r\n    }\r\n    const haveExpectedTypes = expectedTypes.some(t => t);\r\n    if (!valid && haveExpectedTypes) {\r\n        warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\r\n        return;\r\n    }\r\n    const validator = prop.validator;\r\n    if (validator) {\r\n        if (!validator(value)) {\r\n            warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\r\n        }\r\n    }\r\n}\r\nconst simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\r\nfunction assertType(value, type, vm) {\r\n    let valid;\r\n    const expectedType = getType(type);\r\n    if (simpleCheckRE.test(expectedType)) {\r\n        const t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = isPlainObject(value);\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = isArray(value);\r\n    }\r\n    else {\r\n        try {\r\n            valid = value instanceof type;\r\n        }\r\n        catch (e) {\r\n            warn('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\r\n            valid = false;\r\n        }\r\n    }\r\n    return {\r\n        valid,\r\n        expectedType\r\n    };\r\n}\r\nconst functionTypeCheckRE = /^\\s*function (\\w+)/;\r\n/**\r\n * Use function string name to check built-in types,\r\n * because a simple equality check will fail when running\r\n * across different vms / iframes.\r\n */\r\nfunction getType(fn) {\r\n    const match = fn && fn.toString().match(functionTypeCheckRE);\r\n    return match ? match[1] : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (!isArray(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    for (let i = 0, len = expectedTypes.length; i < len; i++) {\r\n        if (isSameType(expectedTypes[i], type)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\r\n        ` Expected ${expectedTypes.map(capitalize).join(', ')}`;\r\n    const expectedType = expectedTypes[0];\r\n    const receivedType = toRawType(value);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        isExplicable(typeof value) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += ` with value ${styleValue(value, expectedType)}`;\r\n    }\r\n    message += `, got ${receivedType} `;\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += `with value ${styleValue(value, receivedType)}.`;\r\n    }\r\n    return message;\r\n}\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return `\"${value}\"`;\r\n    }\r\n    else if (type === 'Number') {\r\n        return `${Number(value)}`;\r\n    }\r\n    else {\r\n        return `${value}`;\r\n    }\r\n}\r\nconst EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\r\nfunction isExplicable(value) {\r\n    return EXPLICABLE_TYPES.some(elem => value.toLowerCase() === elem);\r\n}\r\nfunction isBoolean(...args) {\r\n    return args.some(elem => elem.toLowerCase() === 'boolean');\r\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\r\nlet initProxy;\r\n{\r\n    const allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +\r\n        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\r\n        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +\r\n        'require' // for Webpack/Browserify\r\n    );\r\n    const warnNonPresent = (target, key) => {\r\n        warn(`Property or method \"${key}\" is not defined on the instance but ` +\r\n            'referenced during render. Make sure that this property is reactive, ' +\r\n            'either in the data option, or for class-based components, by ' +\r\n            'initializing the property. ' +\r\n            'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\r\n    };\r\n    const warnReservedPrefix = (target, key) => {\r\n        warn(`Property \"${key}\" must be accessed with \"$data.${key}\" because ` +\r\n            'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\r\n            'prevent conflicts with Vue internals. ' +\r\n            'See: https://v2.vuejs.org/v2/api/#data', target);\r\n    };\r\n    const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\r\n    if (hasProxy) {\r\n        const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\r\n        config.keyCodes = new Proxy(config.keyCodes, {\r\n            set(target, key, value) {\r\n                if (isBuiltInModifier(key)) {\r\n                    warn(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`);\r\n                    return false;\r\n                }\r\n                else {\r\n                    target[key] = value;\r\n                    return true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    const hasHandler = {\r\n        has(target, key) {\r\n            const has = key in target;\r\n            const isAllowed = allowedGlobals(key) ||\r\n                (typeof key === 'string' &&\r\n                    key.charAt(0) === '_' &&\r\n                    !(key in target.$data));\r\n            if (!has && !isAllowed) {\r\n                if (key in target.$data)\r\n                    warnReservedPrefix(target, key);\r\n                else\r\n                    warnNonPresent(target, key);\r\n            }\r\n            return has || !isAllowed;\r\n        }\r\n    };\r\n    const getHandler = {\r\n        get(target, key) {\r\n            if (typeof key === 'string' && !(key in target)) {\r\n                if (key in target.$data)\r\n                    warnReservedPrefix(target, key);\r\n                else\r\n                    warnNonPresent(target, key);\r\n            }\r\n            return target[key];\r\n        }\r\n    };\r\n    initProxy = function initProxy(vm) {\r\n        if (hasProxy) {\r\n            // determine which proxy handler to use\r\n            const options = vm.$options;\r\n            const handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\r\n            vm._renderProxy = new Proxy(vm, handlers);\r\n        }\r\n        else {\r\n            vm._renderProxy = vm;\r\n        }\r\n    };\r\n}\n\nconst sharedPropertyDefinition = {\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: noop,\r\n    set: noop\r\n};\r\nfunction proxy(target, sourceKey, key) {\r\n    sharedPropertyDefinition.get = function proxyGetter() {\r\n        return this[sourceKey][key];\r\n    };\r\n    sharedPropertyDefinition.set = function proxySetter(val) {\r\n        this[sourceKey][key] = val;\r\n    };\r\n    Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\nfunction initState(vm) {\r\n    const opts = vm.$options;\r\n    if (opts.props)\r\n        initProps$1(vm, opts.props);\r\n    // Composition API\r\n    initSetup(vm);\r\n    if (opts.methods)\r\n        initMethods(vm, opts.methods);\r\n    if (opts.data) {\r\n        initData(vm);\r\n    }\r\n    else {\r\n        const ob = observe((vm._data = {}));\r\n        ob && ob.vmCount++;\r\n    }\r\n    if (opts.computed)\r\n        initComputed$1(vm, opts.computed);\r\n    if (opts.watch && opts.watch !== nativeWatch) {\r\n        initWatch(vm, opts.watch);\r\n    }\r\n}\r\nfunction initProps$1(vm, propsOptions) {\r\n    const propsData = vm.$options.propsData || {};\r\n    const props = (vm._props = shallowReactive({}));\r\n    // cache prop keys so that future props updates can iterate using Array\r\n    // instead of dynamic object key enumeration.\r\n    const keys = (vm.$options._propKeys = []);\r\n    const isRoot = !vm.$parent;\r\n    // root instance props should be converted\r\n    if (!isRoot) {\r\n        toggleObserving(false);\r\n    }\r\n    for (const key in propsOptions) {\r\n        keys.push(key);\r\n        const value = validateProp(key, propsOptions, propsData, vm);\r\n        /* istanbul ignore else */\r\n        {\r\n            const hyphenatedKey = hyphenate(key);\r\n            if (isReservedAttribute(hyphenatedKey) ||\r\n                config.isReservedAttr(hyphenatedKey)) {\r\n                warn(`\"${hyphenatedKey}\" is a reserved attribute and cannot be used as component prop.`, vm);\r\n            }\r\n            defineReactive(props, key, value, () => {\r\n                if (!isRoot && !isUpdatingChildComponent) {\r\n                    warn(`Avoid mutating a prop directly since the value will be ` +\r\n                        `overwritten whenever the parent component re-renders. ` +\r\n                        `Instead, use a data or computed property based on the prop's ` +\r\n                        `value. Prop being mutated: \"${key}\"`, vm);\r\n                }\r\n            });\r\n        }\r\n        // static props are already proxied on the component's prototype\r\n        // during Vue.extend(). We only need to proxy props defined at\r\n        // instantiation here.\r\n        if (!(key in vm)) {\r\n            proxy(vm, `_props`, key);\r\n        }\r\n    }\r\n    toggleObserving(true);\r\n}\r\nfunction initData(vm) {\r\n    let data = vm.$options.data;\r\n    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};\r\n    if (!isPlainObject(data)) {\r\n        data = {};\r\n        warn('data functions should return an object:\\n' +\r\n                'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\r\n    }\r\n    // proxy data on instance\r\n    const keys = Object.keys(data);\r\n    const props = vm.$options.props;\r\n    const methods = vm.$options.methods;\r\n    let i = keys.length;\r\n    while (i--) {\r\n        const key = keys[i];\r\n        {\r\n            if (methods && hasOwn(methods, key)) {\r\n                warn(`Method \"${key}\" has already been defined as a data property.`, vm);\r\n            }\r\n        }\r\n        if (props && hasOwn(props, key)) {\r\n            warn(`The data property \"${key}\" is already declared as a prop. ` +\r\n                    `Use prop default value instead.`, vm);\r\n        }\r\n        else if (!isReserved(key)) {\r\n            proxy(vm, `_data`, key);\r\n        }\r\n    }\r\n    // observe data\r\n    const ob = observe(data);\r\n    ob && ob.vmCount++;\r\n}\r\nfunction getData(data, vm) {\r\n    // #7573 disable dep collection when invoking data getters\r\n    pushTarget();\r\n    try {\r\n        return data.call(vm, vm);\r\n    }\r\n    catch (e) {\r\n        handleError(e, vm, `data()`);\r\n        return {};\r\n    }\r\n    finally {\r\n        popTarget();\r\n    }\r\n}\r\nconst computedWatcherOptions = { lazy: true };\r\nfunction initComputed$1(vm, computed) {\r\n    // $flow-disable-line\r\n    const watchers = (vm._computedWatchers = Object.create(null));\r\n    // computed properties are just getters during SSR\r\n    const isSSR = isServerRendering();\r\n    for (const key in computed) {\r\n        const userDef = computed[key];\r\n        const getter = isFunction(userDef) ? userDef : userDef.get;\r\n        if (getter == null) {\r\n            warn(`Getter is missing for computed property \"${key}\".`, vm);\r\n        }\r\n        if (!isSSR) {\r\n            // create internal watcher for the computed property.\r\n            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\r\n        }\r\n        // component-defined computed properties are already defined on the\r\n        // component prototype. We only need to define computed properties defined\r\n        // at instantiation here.\r\n        if (!(key in vm)) {\r\n            defineComputed(vm, key, userDef);\r\n        }\r\n        else {\r\n            if (key in vm.$data) {\r\n                warn(`The computed property \"${key}\" is already defined in data.`, vm);\r\n            }\r\n            else if (vm.$options.props && key in vm.$options.props) {\r\n                warn(`The computed property \"${key}\" is already defined as a prop.`, vm);\r\n            }\r\n            else if (vm.$options.methods && key in vm.$options.methods) {\r\n                warn(`The computed property \"${key}\" is already defined as a method.`, vm);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction defineComputed(target, key, userDef) {\r\n    const shouldCache = !isServerRendering();\r\n    if (isFunction(userDef)) {\r\n        sharedPropertyDefinition.get = shouldCache\r\n            ? createComputedGetter(key)\r\n            : createGetterInvoker(userDef);\r\n        sharedPropertyDefinition.set = noop;\r\n    }\r\n    else {\r\n        sharedPropertyDefinition.get = userDef.get\r\n            ? shouldCache && userDef.cache !== false\r\n                ? createComputedGetter(key)\r\n                : createGetterInvoker(userDef.get)\r\n            : noop;\r\n        sharedPropertyDefinition.set = userDef.set || noop;\r\n    }\r\n    if (sharedPropertyDefinition.set === noop) {\r\n        sharedPropertyDefinition.set = function () {\r\n            warn(`Computed property \"${key}\" was assigned to but it has no setter.`, this);\r\n        };\r\n    }\r\n    Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\nfunction createComputedGetter(key) {\r\n    return function computedGetter() {\r\n        const watcher = this._computedWatchers && this._computedWatchers[key];\r\n        if (watcher) {\r\n            if (watcher.dirty) {\r\n                watcher.evaluate();\r\n            }\r\n            if (Dep.target) {\r\n                if (Dep.target.onTrack) {\r\n                    Dep.target.onTrack({\r\n                        effect: Dep.target,\r\n                        target: this,\r\n                        type: \"get\" /* TrackOpTypes.GET */,\r\n                        key\r\n                    });\r\n                }\r\n                watcher.depend();\r\n            }\r\n            return watcher.value;\r\n        }\r\n    };\r\n}\r\nfunction createGetterInvoker(fn) {\r\n    return function computedGetter() {\r\n        return fn.call(this, this);\r\n    };\r\n}\r\nfunction initMethods(vm, methods) {\r\n    const props = vm.$options.props;\r\n    for (const key in methods) {\r\n        {\r\n            if (typeof methods[key] !== 'function') {\r\n                warn(`Method \"${key}\" has type \"${typeof methods[key]}\" in the component definition. ` +\r\n                    `Did you reference the function correctly?`, vm);\r\n            }\r\n            if (props && hasOwn(props, key)) {\r\n                warn(`Method \"${key}\" has already been defined as a prop.`, vm);\r\n            }\r\n            if (key in vm && isReserved(key)) {\r\n                warn(`Method \"${key}\" conflicts with an existing Vue instance method. ` +\r\n                    `Avoid defining component methods that start with _ or $.`);\r\n            }\r\n        }\r\n        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\r\n    }\r\n}\r\nfunction initWatch(vm, watch) {\r\n    for (const key in watch) {\r\n        const handler = watch[key];\r\n        if (isArray(handler)) {\r\n            for (let i = 0; i < handler.length; i++) {\r\n                createWatcher(vm, key, handler[i]);\r\n            }\r\n        }\r\n        else {\r\n            createWatcher(vm, key, handler);\r\n        }\r\n    }\r\n}\r\nfunction createWatcher(vm, expOrFn, handler, options) {\r\n    if (isPlainObject(handler)) {\r\n        options = handler;\r\n        handler = handler.handler;\r\n    }\r\n    if (typeof handler === 'string') {\r\n        handler = vm[handler];\r\n    }\r\n    return vm.$watch(expOrFn, handler, options);\r\n}\r\nfunction stateMixin(Vue) {\r\n    // flow somehow has problems with directly declared definition object\r\n    // when using Object.defineProperty, so we have to procedurally build up\r\n    // the object here.\r\n    const dataDef = {};\r\n    dataDef.get = function () {\r\n        return this._data;\r\n    };\r\n    const propsDef = {};\r\n    propsDef.get = function () {\r\n        return this._props;\r\n    };\r\n    {\r\n        dataDef.set = function () {\r\n            warn('Avoid replacing instance root $data. ' +\r\n                'Use nested data properties instead.', this);\r\n        };\r\n        propsDef.set = function () {\r\n            warn(`$props is readonly.`, this);\r\n        };\r\n    }\r\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\r\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\r\n    Vue.prototype.$set = set;\r\n    Vue.prototype.$delete = del;\r\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\r\n        const vm = this;\r\n        if (isPlainObject(cb)) {\r\n            return createWatcher(vm, expOrFn, cb, options);\r\n        }\r\n        options = options || {};\r\n        options.user = true;\r\n        const watcher = new Watcher(vm, expOrFn, cb, options);\r\n        if (options.immediate) {\r\n            const info = `callback for immediate watcher \"${watcher.expression}\"`;\r\n            pushTarget();\r\n            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\r\n            popTarget();\r\n        }\r\n        return function unwatchFn() {\r\n            watcher.teardown();\r\n        };\r\n    };\r\n}\n\nlet uid = 0;\r\nfunction initMixin$1(Vue) {\r\n    Vue.prototype._init = function (options) {\r\n        const vm = this;\r\n        // a uid\r\n        vm._uid = uid++;\r\n        let startTag, endTag;\r\n        /* istanbul ignore if */\r\n        if (config.performance && mark) {\r\n            startTag = `vue-perf-start:${vm._uid}`;\r\n            endTag = `vue-perf-end:${vm._uid}`;\r\n            mark(startTag);\r\n        }\r\n        // a flag to mark this as a Vue instance without having to do instanceof\r\n        // check\r\n        vm._isVue = true;\r\n        // avoid instances from being observed\r\n        vm.__v_skip = true;\r\n        // effect scope\r\n        vm._scope = new EffectScope(true /* detached */);\r\n        vm._scope._vm = true;\r\n        // merge options\r\n        if (options && options._isComponent) {\r\n            // optimize internal component instantiation\r\n            // since dynamic options merging is pretty slow, and none of the\r\n            // internal component options needs special treatment.\r\n            initInternalComponent(vm, options);\r\n        }\r\n        else {\r\n            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\r\n        }\r\n        /* istanbul ignore else */\r\n        {\r\n            initProxy(vm);\r\n        }\r\n        // expose real self\r\n        vm._self = vm;\r\n        initLifecycle(vm);\r\n        initEvents(vm);\r\n        initRender(vm);\r\n        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);\r\n        initInjections(vm); // resolve injections before data/props\r\n        initState(vm);\r\n        initProvide(vm); // resolve provide after data/props\r\n        callHook$1(vm, 'created');\r\n        /* istanbul ignore if */\r\n        if (config.performance && mark) {\r\n            vm._name = formatComponentName(vm, false);\r\n            mark(endTag);\r\n            measure(`vue ${vm._name} init`, startTag, endTag);\r\n        }\r\n        if (vm.$options.el) {\r\n            vm.$mount(vm.$options.el);\r\n        }\r\n    };\r\n}\r\nfunction initInternalComponent(vm, options) {\r\n    const opts = (vm.$options = Object.create(vm.constructor.options));\r\n    // doing this because it's faster than dynamic enumeration.\r\n    const parentVnode = options._parentVnode;\r\n    opts.parent = options.parent;\r\n    opts._parentVnode = parentVnode;\r\n    const vnodeComponentOptions = parentVnode.componentOptions;\r\n    opts.propsData = vnodeComponentOptions.propsData;\r\n    opts._parentListeners = vnodeComponentOptions.listeners;\r\n    opts._renderChildren = vnodeComponentOptions.children;\r\n    opts._componentTag = vnodeComponentOptions.tag;\r\n    if (options.render) {\r\n        opts.render = options.render;\r\n        opts.staticRenderFns = options.staticRenderFns;\r\n    }\r\n}\r\nfunction resolveConstructorOptions(Ctor) {\r\n    let options = Ctor.options;\r\n    if (Ctor.super) {\r\n        const superOptions = resolveConstructorOptions(Ctor.super);\r\n        const cachedSuperOptions = Ctor.superOptions;\r\n        if (superOptions !== cachedSuperOptions) {\r\n            // super option changed,\r\n            // need to resolve new options.\r\n            Ctor.superOptions = superOptions;\r\n            // check if there are any late-modified/attached options (#4976)\r\n            const modifiedOptions = resolveModifiedOptions(Ctor);\r\n            // update base extend options\r\n            if (modifiedOptions) {\r\n                extend(Ctor.extendOptions, modifiedOptions);\r\n            }\r\n            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\r\n            if (options.name) {\r\n                options.components[options.name] = Ctor;\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}\r\nfunction resolveModifiedOptions(Ctor) {\r\n    let modified;\r\n    const latest = Ctor.options;\r\n    const sealed = Ctor.sealedOptions;\r\n    for (const key in latest) {\r\n        if (latest[key] !== sealed[key]) {\r\n            if (!modified)\r\n                modified = {};\r\n            modified[key] = latest[key];\r\n        }\r\n    }\r\n    return modified;\r\n}\n\nfunction Vue(options) {\r\n    if (!(this instanceof Vue)) {\r\n        warn('Vue is a constructor and should be called with the `new` keyword');\r\n    }\r\n    this._init(options);\r\n}\r\n//@ts-expect-error Vue has function type\r\ninitMixin$1(Vue);\r\n//@ts-expect-error Vue has function type\r\nstateMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\neventsMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\nlifecycleMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\nrenderMixin(Vue);\n\nfunction initUse(Vue) {\r\n    Vue.use = function (plugin) {\r\n        const installedPlugins = this._installedPlugins || (this._installedPlugins = []);\r\n        if (installedPlugins.indexOf(plugin) > -1) {\r\n            return this;\r\n        }\r\n        // additional parameters\r\n        const args = toArray(arguments, 1);\r\n        args.unshift(this);\r\n        if (isFunction(plugin.install)) {\r\n            plugin.install.apply(plugin, args);\r\n        }\r\n        else if (isFunction(plugin)) {\r\n            plugin.apply(null, args);\r\n        }\r\n        installedPlugins.push(plugin);\r\n        return this;\r\n    };\r\n}\n\nfunction initMixin(Vue) {\r\n    Vue.mixin = function (mixin) {\r\n        this.options = mergeOptions(this.options, mixin);\r\n        return this;\r\n    };\r\n}\n\nfunction initExtend(Vue) {\r\n    /**\r\n     * Each instance constructor, including Vue, has a unique\r\n     * cid. This enables us to create wrapped \"child\r\n     * constructors\" for prototypal inheritance and cache them.\r\n     */\r\n    Vue.cid = 0;\r\n    let cid = 1;\r\n    /**\r\n     * Class inheritance\r\n     */\r\n    Vue.extend = function (extendOptions) {\r\n        extendOptions = extendOptions || {};\r\n        const Super = this;\r\n        const SuperId = Super.cid;\r\n        const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\r\n        if (cachedCtors[SuperId]) {\r\n            return cachedCtors[SuperId];\r\n        }\r\n        const name = getComponentName(extendOptions) || getComponentName(Super.options);\r\n        if (name) {\r\n            validateComponentName(name);\r\n        }\r\n        const Sub = function VueComponent(options) {\r\n            this._init(options);\r\n        };\r\n        Sub.prototype = Object.create(Super.prototype);\r\n        Sub.prototype.constructor = Sub;\r\n        Sub.cid = cid++;\r\n        Sub.options = mergeOptions(Super.options, extendOptions);\r\n        Sub['super'] = Super;\r\n        // For props and computed properties, we define the proxy getters on\r\n        // the Vue instances at extension time, on the extended prototype. This\r\n        // avoids Object.defineProperty calls for each instance created.\r\n        if (Sub.options.props) {\r\n            initProps(Sub);\r\n        }\r\n        if (Sub.options.computed) {\r\n            initComputed(Sub);\r\n        }\r\n        // allow further extension/mixin/plugin usage\r\n        Sub.extend = Super.extend;\r\n        Sub.mixin = Super.mixin;\r\n        Sub.use = Super.use;\r\n        // create asset registers, so extended classes\r\n        // can have their private assets too.\r\n        ASSET_TYPES.forEach(function (type) {\r\n            Sub[type] = Super[type];\r\n        });\r\n        // enable recursive self-lookup\r\n        if (name) {\r\n            Sub.options.components[name] = Sub;\r\n        }\r\n        // keep a reference to the super options at extension time.\r\n        // later at instantiation we can check if Super's options have\r\n        // been updated.\r\n        Sub.superOptions = Super.options;\r\n        Sub.extendOptions = extendOptions;\r\n        Sub.sealedOptions = extend({}, Sub.options);\r\n        // cache constructor\r\n        cachedCtors[SuperId] = Sub;\r\n        return Sub;\r\n    };\r\n}\r\nfunction initProps(Comp) {\r\n    const props = Comp.options.props;\r\n    for (const key in props) {\r\n        proxy(Comp.prototype, `_props`, key);\r\n    }\r\n}\r\nfunction initComputed(Comp) {\r\n    const computed = Comp.options.computed;\r\n    for (const key in computed) {\r\n        defineComputed(Comp.prototype, key, computed[key]);\r\n    }\r\n}\n\nfunction initAssetRegisters(Vue) {\r\n    /**\r\n     * Create asset registration methods.\r\n     */\r\n    ASSET_TYPES.forEach(type => {\r\n        // @ts-expect-error function is not exact same type\r\n        Vue[type] = function (id, definition) {\r\n            if (!definition) {\r\n                return this.options[type + 's'][id];\r\n            }\r\n            else {\r\n                /* istanbul ignore if */\r\n                if (type === 'component') {\r\n                    validateComponentName(id);\r\n                }\r\n                if (type === 'component' && isPlainObject(definition)) {\r\n                    // @ts-expect-error\r\n                    definition.name = definition.name || id;\r\n                    definition = this.options._base.extend(definition);\r\n                }\r\n                if (type === 'directive' && isFunction(definition)) {\r\n                    definition = { bind: definition, update: definition };\r\n                }\r\n                this.options[type + 's'][id] = definition;\r\n                return definition;\r\n            }\r\n        };\r\n    });\r\n}\n\nfunction _getComponentName(opts) {\r\n    return opts && (getComponentName(opts.Ctor.options) || opts.tag);\r\n}\r\nfunction matches(pattern, name) {\r\n    if (isArray(pattern)) {\r\n        return pattern.indexOf(name) > -1;\r\n    }\r\n    else if (typeof pattern === 'string') {\r\n        return pattern.split(',').indexOf(name) > -1;\r\n    }\r\n    else if (isRegExp(pattern)) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction pruneCache(keepAliveInstance, filter) {\r\n    const { cache, keys, _vnode } = keepAliveInstance;\r\n    for (const key in cache) {\r\n        const entry = cache[key];\r\n        if (entry) {\r\n            const name = entry.name;\r\n            if (name && !filter(name)) {\r\n                pruneCacheEntry(cache, key, keys, _vnode);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction pruneCacheEntry(cache, key, keys, current) {\r\n    const entry = cache[key];\r\n    if (entry && (!current || entry.tag !== current.tag)) {\r\n        // @ts-expect-error can be undefined\r\n        entry.componentInstance.$destroy();\r\n    }\r\n    cache[key] = null;\r\n    remove$2(keys, key);\r\n}\r\nconst patternTypes = [String, RegExp, Array];\r\n// TODO defineComponent\r\nvar KeepAlive = {\r\n    name: 'keep-alive',\r\n    abstract: true,\r\n    props: {\r\n        include: patternTypes,\r\n        exclude: patternTypes,\r\n        max: [String, Number]\r\n    },\r\n    methods: {\r\n        cacheVNode() {\r\n            const { cache, keys, vnodeToCache, keyToCache } = this;\r\n            if (vnodeToCache) {\r\n                const { tag, componentInstance, componentOptions } = vnodeToCache;\r\n                cache[keyToCache] = {\r\n                    name: _getComponentName(componentOptions),\r\n                    tag,\r\n                    componentInstance\r\n                };\r\n                keys.push(keyToCache);\r\n                // prune oldest entry\r\n                if (this.max && keys.length > parseInt(this.max)) {\r\n                    pruneCacheEntry(cache, keys[0], keys, this._vnode);\r\n                }\r\n                this.vnodeToCache = null;\r\n            }\r\n        }\r\n    },\r\n    created() {\r\n        this.cache = Object.create(null);\r\n        this.keys = [];\r\n    },\r\n    destroyed() {\r\n        for (const key in this.cache) {\r\n            pruneCacheEntry(this.cache, key, this.keys);\r\n        }\r\n    },\r\n    mounted() {\r\n        this.cacheVNode();\r\n        this.$watch('include', val => {\r\n            pruneCache(this, name => matches(val, name));\r\n        });\r\n        this.$watch('exclude', val => {\r\n            pruneCache(this, name => !matches(val, name));\r\n        });\r\n    },\r\n    updated() {\r\n        this.cacheVNode();\r\n    },\r\n    render() {\r\n        const slot = this.$slots.default;\r\n        const vnode = getFirstComponentChild(slot);\r\n        const componentOptions = vnode && vnode.componentOptions;\r\n        if (componentOptions) {\r\n            // check pattern\r\n            const name = _getComponentName(componentOptions);\r\n            const { include, exclude } = this;\r\n            if (\r\n            // not included\r\n            (include && (!name || !matches(include, name))) ||\r\n                // excluded\r\n                (exclude && name && matches(exclude, name))) {\r\n                return vnode;\r\n            }\r\n            const { cache, keys } = this;\r\n            const key = vnode.key == null\r\n                ? // same constructor may get registered as different local components\r\n                    // so cid alone is not enough (#3269)\r\n                    componentOptions.Ctor.cid +\r\n                        (componentOptions.tag ? `::${componentOptions.tag}` : '')\r\n                : vnode.key;\r\n            if (cache[key]) {\r\n                vnode.componentInstance = cache[key].componentInstance;\r\n                // make current key freshest\r\n                remove$2(keys, key);\r\n                keys.push(key);\r\n            }\r\n            else {\r\n                // delay setting the cache until update\r\n                this.vnodeToCache = vnode;\r\n                this.keyToCache = key;\r\n            }\r\n            // @ts-expect-error can vnode.data can be undefined\r\n            vnode.data.keepAlive = true;\r\n        }\r\n        return vnode || (slot && slot[0]);\r\n    }\r\n};\n\nvar builtInComponents = {\r\n    KeepAlive\r\n};\n\nfunction initGlobalAPI(Vue) {\r\n    // config\r\n    const configDef = {};\r\n    configDef.get = () => config;\r\n    {\r\n        configDef.set = () => {\r\n            warn('Do not replace the Vue.config object, set individual fields instead.');\r\n        };\r\n    }\r\n    Object.defineProperty(Vue, 'config', configDef);\r\n    // exposed util methods.\r\n    // NOTE: these are not considered part of the public API - avoid relying on\r\n    // them unless you are aware of the risk.\r\n    Vue.util = {\r\n        warn,\r\n        extend,\r\n        mergeOptions,\r\n        defineReactive\r\n    };\r\n    Vue.set = set;\r\n    Vue.delete = del;\r\n    Vue.nextTick = nextTick;\r\n    // 2.6 explicit observable API\r\n    Vue.observable = (obj) => {\r\n        observe(obj);\r\n        return obj;\r\n    };\r\n    Vue.options = Object.create(null);\r\n    ASSET_TYPES.forEach(type => {\r\n        Vue.options[type + 's'] = Object.create(null);\r\n    });\r\n    // this is used to identify the \"base\" constructor to extend all plain-object\r\n    // components with in Weex's multi-instance scenarios.\r\n    Vue.options._base = Vue;\r\n    extend(Vue.options.components, builtInComponents);\r\n    initUse(Vue);\r\n    initMixin(Vue);\r\n    initExtend(Vue);\r\n    initAssetRegisters(Vue);\r\n}\n\ninitGlobalAPI(Vue);\r\nObject.defineProperty(Vue.prototype, '$isServer', {\r\n    get: isServerRendering\r\n});\r\nObject.defineProperty(Vue.prototype, '$ssrContext', {\r\n    get() {\r\n        /* istanbul ignore next */\r\n        return this.$vnode && this.$vnode.ssrContext;\r\n    }\r\n});\r\n// expose FunctionalRenderContext for ssr runtime helper installation\r\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\r\n    value: FunctionalRenderContext\r\n});\r\nVue.version = version;\n\n// these are reserved for web because they are directly compiled away\r\n// during template compilation\r\nconst isReservedAttr = makeMap('style,class');\r\n// attributes that should be using props for binding\r\nconst acceptValue = makeMap('input,textarea,option,select,progress');\r\nconst mustUseProp = (tag, type, attr) => {\r\n    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||\r\n        (attr === 'selected' && tag === 'option') ||\r\n        (attr === 'checked' && tag === 'input') ||\r\n        (attr === 'muted' && tag === 'video'));\r\n};\r\nconst isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\r\nconst isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\r\nconst convertEnumeratedValue = (key, value) => {\r\n    return isFalsyAttrValue(value) || value === 'false'\r\n        ? 'false'\r\n        : // allow arbitrary string value for contenteditable\r\n            key === 'contenteditable' && isValidContentEditableValue(value)\r\n                ? value\r\n                : 'true';\r\n};\r\nconst isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\r\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\r\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\r\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\r\n    'required,reversed,scoped,seamless,selected,sortable,' +\r\n    'truespeed,typemustmatch,visible');\r\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\r\nconst isXlink = (name) => {\r\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\r\n};\r\nconst getXlinkProp = (name) => {\r\n    return isXlink(name) ? name.slice(6, name.length) : '';\r\n};\r\nconst isFalsyAttrValue = (val) => {\r\n    return val == null || val === false;\r\n};\n\nfunction genClassForVnode(vnode) {\r\n    let data = vnode.data;\r\n    let parentNode = vnode;\r\n    let childNode = vnode;\r\n    while (isDef(childNode.componentInstance)) {\r\n        childNode = childNode.componentInstance._vnode;\r\n        if (childNode && childNode.data) {\r\n            data = mergeClassData(childNode.data, data);\r\n        }\r\n    }\r\n    // @ts-expect-error parentNode.parent not VNodeWithData\r\n    while (isDef((parentNode = parentNode.parent))) {\r\n        if (parentNode && parentNode.data) {\r\n            data = mergeClassData(data, parentNode.data);\r\n        }\r\n    }\r\n    return renderClass(data.staticClass, data.class);\r\n}\r\nfunction mergeClassData(child, parent) {\r\n    return {\r\n        staticClass: concat(child.staticClass, parent.staticClass),\r\n        class: isDef(child.class) ? [child.class, parent.class] : parent.class\r\n    };\r\n}\r\nfunction renderClass(staticClass, dynamicClass) {\r\n    if (isDef(staticClass) || isDef(dynamicClass)) {\r\n        return concat(staticClass, stringifyClass(dynamicClass));\r\n    }\r\n    /* istanbul ignore next */\r\n    return '';\r\n}\r\nfunction concat(a, b) {\r\n    return a ? (b ? a + ' ' + b : a) : b || '';\r\n}\r\nfunction stringifyClass(value) {\r\n    if (Array.isArray(value)) {\r\n        return stringifyArray(value);\r\n    }\r\n    if (isObject(value)) {\r\n        return stringifyObject(value);\r\n    }\r\n    if (typeof value === 'string') {\r\n        return value;\r\n    }\r\n    /* istanbul ignore next */\r\n    return '';\r\n}\r\nfunction stringifyArray(value) {\r\n    let res = '';\r\n    let stringified;\r\n    for (let i = 0, l = value.length; i < l; i++) {\r\n        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {\r\n            if (res)\r\n                res += ' ';\r\n            res += stringified;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction stringifyObject(value) {\r\n    let res = '';\r\n    for (const key in value) {\r\n        if (value[key]) {\r\n            if (res)\r\n                res += ' ';\r\n            res += key;\r\n        }\r\n    }\r\n    return res;\r\n}\n\nconst namespaceMap = {\r\n    svg: 'http://www.w3.org/2000/svg',\r\n    math: 'http://www.w3.org/1998/Math/MathML'\r\n};\r\nconst isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +\r\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\r\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\r\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\r\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\r\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\r\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\r\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\r\n    'output,progress,select,textarea,' +\r\n    'details,dialog,menu,menuitem,summary,' +\r\n    'content,element,shadow,template,blockquote,iframe,tfoot');\r\n// this map is intentionally selective, only covering SVG elements that may\r\n// contain child elements.\r\nconst isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\r\n    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\r\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\r\nconst isReservedTag = (tag) => {\r\n    return isHTMLTag(tag) || isSVG(tag);\r\n};\r\nfunction getTagNamespace(tag) {\r\n    if (isSVG(tag)) {\r\n        return 'svg';\r\n    }\r\n    // basic support for MathML\r\n    // note it doesn't support other MathML elements being component roots\r\n    if (tag === 'math') {\r\n        return 'math';\r\n    }\r\n}\r\nconst unknownElementCache = Object.create(null);\r\nfunction isUnknownElement(tag) {\r\n    /* istanbul ignore if */\r\n    if (!inBrowser) {\r\n        return true;\r\n    }\r\n    if (isReservedTag(tag)) {\r\n        return false;\r\n    }\r\n    tag = tag.toLowerCase();\r\n    /* istanbul ignore if */\r\n    if (unknownElementCache[tag] != null) {\r\n        return unknownElementCache[tag];\r\n    }\r\n    const el = document.createElement(tag);\r\n    if (tag.indexOf('-') > -1) {\r\n        // http://stackoverflow.com/a/28210364/1070244\r\n        return (unknownElementCache[tag] =\r\n            el.constructor === window.HTMLUnknownElement ||\r\n                el.constructor === window.HTMLElement);\r\n    }\r\n    else {\r\n        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));\r\n    }\r\n}\r\nconst isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/**\r\n * Query an element selector if it's not an element already.\r\n */\r\nfunction query(el) {\r\n    if (typeof el === 'string') {\r\n        const selected = document.querySelector(el);\r\n        if (!selected) {\r\n            warn('Cannot find element: ' + el);\r\n            return document.createElement('div');\r\n        }\r\n        return selected;\r\n    }\r\n    else {\r\n        return el;\r\n    }\r\n}\n\nfunction createElement(tagName, vnode) {\r\n    const elm = document.createElement(tagName);\r\n    if (tagName !== 'select') {\r\n        return elm;\r\n    }\r\n    // false or null will remove the attribute but undefined will not\r\n    if (vnode.data &&\r\n        vnode.data.attrs &&\r\n        vnode.data.attrs.multiple !== undefined) {\r\n        elm.setAttribute('multiple', 'multiple');\r\n    }\r\n    return elm;\r\n}\r\nfunction createElementNS(namespace, tagName) {\r\n    return document.createElementNS(namespaceMap[namespace], tagName);\r\n}\r\nfunction createTextNode(text) {\r\n    return document.createTextNode(text);\r\n}\r\nfunction createComment(text) {\r\n    return document.createComment(text);\r\n}\r\nfunction insertBefore(parentNode, newNode, referenceNode) {\r\n    parentNode.insertBefore(newNode, referenceNode);\r\n}\r\nfunction removeChild(node, child) {\r\n    node.removeChild(child);\r\n}\r\nfunction appendChild(node, child) {\r\n    node.appendChild(child);\r\n}\r\nfunction parentNode(node) {\r\n    return node.parentNode;\r\n}\r\nfunction nextSibling(node) {\r\n    return node.nextSibling;\r\n}\r\nfunction tagName(node) {\r\n    return node.tagName;\r\n}\r\nfunction setTextContent(node, text) {\r\n    node.textContent = text;\r\n}\r\nfunction setStyleScope(node, scopeId) {\r\n    node.setAttribute(scopeId, '');\r\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createElement: createElement,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\nvar ref = {\r\n    create(_, vnode) {\r\n        registerRef(vnode);\r\n    },\r\n    update(oldVnode, vnode) {\r\n        if (oldVnode.data.ref !== vnode.data.ref) {\r\n            registerRef(oldVnode, true);\r\n            registerRef(vnode);\r\n        }\r\n    },\r\n    destroy(vnode) {\r\n        registerRef(vnode, true);\r\n    }\r\n};\r\nfunction registerRef(vnode, isRemoval) {\r\n    const ref = vnode.data.ref;\r\n    if (!isDef(ref))\r\n        return;\r\n    const vm = vnode.context;\r\n    const refValue = vnode.componentInstance || vnode.elm;\r\n    const value = isRemoval ? null : refValue;\r\n    const $refsValue = isRemoval ? undefined : refValue;\r\n    if (isFunction(ref)) {\r\n        invokeWithErrorHandling(ref, vm, [value], vm, `template ref function`);\r\n        return;\r\n    }\r\n    const isFor = vnode.data.refInFor;\r\n    const _isString = typeof ref === 'string' || typeof ref === 'number';\r\n    const _isRef = isRef(ref);\r\n    const refs = vm.$refs;\r\n    if (_isString || _isRef) {\r\n        if (isFor) {\r\n            const existing = _isString ? refs[ref] : ref.value;\r\n            if (isRemoval) {\r\n                isArray(existing) && remove$2(existing, refValue);\r\n            }\r\n            else {\r\n                if (!isArray(existing)) {\r\n                    if (_isString) {\r\n                        refs[ref] = [refValue];\r\n                        setSetupRef(vm, ref, refs[ref]);\r\n                    }\r\n                    else {\r\n                        ref.value = [refValue];\r\n                    }\r\n                }\r\n                else if (!existing.includes(refValue)) {\r\n                    existing.push(refValue);\r\n                }\r\n            }\r\n        }\r\n        else if (_isString) {\r\n            if (isRemoval && refs[ref] !== refValue) {\r\n                return;\r\n            }\r\n            refs[ref] = $refsValue;\r\n            setSetupRef(vm, ref, value);\r\n        }\r\n        else if (_isRef) {\r\n            if (isRemoval && ref.value !== refValue) {\r\n                return;\r\n            }\r\n            ref.value = value;\r\n        }\r\n        else {\r\n            warn(`Invalid template ref type: ${typeof ref}`);\r\n        }\r\n    }\r\n}\r\nfunction setSetupRef({ _setupState }, key, val) {\r\n    if (_setupState && hasOwn(_setupState, key)) {\r\n        if (isRef(_setupState[key])) {\r\n            _setupState[key].value = val;\r\n        }\r\n        else {\r\n            _setupState[key] = val;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Virtual DOM patching algorithm based on Snabbdom by\r\n * Simon Friis Vindum (@paldepind)\r\n * Licensed under the MIT License\r\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\r\n *\r\n * modified by Evan You (@yyx990803)\r\n *\r\n * Not type-checking this because this file is perf-critical and the cost\r\n * of making flow understand it is not worth it.\r\n */\r\nconst emptyNode = new VNode('', {}, []);\r\nconst hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\r\nfunction sameVnode(a, b) {\r\n    return (a.key === b.key &&\r\n        a.asyncFactory === b.asyncFactory &&\r\n        ((a.tag === b.tag &&\r\n            a.isComment === b.isComment &&\r\n            isDef(a.data) === isDef(b.data) &&\r\n            sameInputType(a, b)) ||\r\n            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));\r\n}\r\nfunction sameInputType(a, b) {\r\n    if (a.tag !== 'input')\r\n        return true;\r\n    let i;\r\n    const typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;\r\n    const typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;\r\n    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));\r\n}\r\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\r\n    let i, key;\r\n    const map = {};\r\n    for (i = beginIdx; i <= endIdx; ++i) {\r\n        key = children[i].key;\r\n        if (isDef(key))\r\n            map[key] = i;\r\n    }\r\n    return map;\r\n}\r\nfunction createPatchFunction(backend) {\r\n    let i, j;\r\n    const cbs = {};\r\n    const { modules, nodeOps } = backend;\r\n    for (i = 0; i < hooks.length; ++i) {\r\n        cbs[hooks[i]] = [];\r\n        for (j = 0; j < modules.length; ++j) {\r\n            if (isDef(modules[j][hooks[i]])) {\r\n                cbs[hooks[i]].push(modules[j][hooks[i]]);\r\n            }\r\n        }\r\n    }\r\n    function emptyNodeAt(elm) {\r\n        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\r\n    }\r\n    function createRmCb(childElm, listeners) {\r\n        function remove() {\r\n            if (--remove.listeners === 0) {\r\n                removeNode(childElm);\r\n            }\r\n        }\r\n        remove.listeners = listeners;\r\n        return remove;\r\n    }\r\n    function removeNode(el) {\r\n        const parent = nodeOps.parentNode(el);\r\n        // element may have already been removed due to v-html / v-text\r\n        if (isDef(parent)) {\r\n            nodeOps.removeChild(parent, el);\r\n        }\r\n    }\r\n    function isUnknownElement(vnode, inVPre) {\r\n        return (!inVPre &&\r\n            !vnode.ns &&\r\n            !(config.ignoredElements.length &&\r\n                config.ignoredElements.some(ignore => {\r\n                    return isRegExp(ignore)\r\n                        ? ignore.test(vnode.tag)\r\n                        : ignore === vnode.tag;\r\n                })) &&\r\n            config.isUnknownElement(vnode.tag));\r\n    }\r\n    let creatingElmInVPre = 0;\r\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\r\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\r\n            // This vnode was used in a previous render!\r\n            // now it's used as a new node, overwriting its elm would cause\r\n            // potential patch errors down the road when it's used as an insertion\r\n            // reference node. Instead, we clone the node on-demand before creating\r\n            // associated DOM element for it.\r\n            vnode = ownerArray[index] = cloneVNode(vnode);\r\n        }\r\n        vnode.isRootInsert = !nested; // for transition enter check\r\n        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\r\n            return;\r\n        }\r\n        const data = vnode.data;\r\n        const children = vnode.children;\r\n        const tag = vnode.tag;\r\n        if (isDef(tag)) {\r\n            {\r\n                if (data && data.pre) {\r\n                    creatingElmInVPre++;\r\n                }\r\n                if (isUnknownElement(vnode, creatingElmInVPre)) {\r\n                    warn('Unknown custom element: <' +\r\n                        tag +\r\n                        '> - did you ' +\r\n                        'register the component correctly? For recursive components, ' +\r\n                        'make sure to provide the \"name\" option.', vnode.context);\r\n                }\r\n            }\r\n            vnode.elm = vnode.ns\r\n                ? nodeOps.createElementNS(vnode.ns, tag)\r\n                : nodeOps.createElement(tag, vnode);\r\n            setScope(vnode);\r\n            createChildren(vnode, children, insertedVnodeQueue);\r\n            if (isDef(data)) {\r\n                invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            }\r\n            insert(parentElm, vnode.elm, refElm);\r\n            if (data && data.pre) {\r\n                creatingElmInVPre--;\r\n            }\r\n        }\r\n        else if (isTrue(vnode.isComment)) {\r\n            vnode.elm = nodeOps.createComment(vnode.text);\r\n            insert(parentElm, vnode.elm, refElm);\r\n        }\r\n        else {\r\n            vnode.elm = nodeOps.createTextNode(vnode.text);\r\n            insert(parentElm, vnode.elm, refElm);\r\n        }\r\n    }\r\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\r\n        let i = vnode.data;\r\n        if (isDef(i)) {\r\n            const isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\r\n            if (isDef((i = i.hook)) && isDef((i = i.init))) {\r\n                i(vnode, false /* hydrating */);\r\n            }\r\n            // after calling the init hook, if the vnode is a child component\r\n            // it should've created a child instance and mounted it. the child\r\n            // component also has set the placeholder vnode's elm.\r\n            // in that case we can just return the element and be done.\r\n            if (isDef(vnode.componentInstance)) {\r\n                initComponent(vnode, insertedVnodeQueue);\r\n                insert(parentElm, vnode.elm, refElm);\r\n                if (isTrue(isReactivated)) {\r\n                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    function initComponent(vnode, insertedVnodeQueue) {\r\n        if (isDef(vnode.data.pendingInsert)) {\r\n            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\r\n            vnode.data.pendingInsert = null;\r\n        }\r\n        vnode.elm = vnode.componentInstance.$el;\r\n        if (isPatchable(vnode)) {\r\n            invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            setScope(vnode);\r\n        }\r\n        else {\r\n            // empty component root.\r\n            // skip all element-related modules except for ref (#3455)\r\n            registerRef(vnode);\r\n            // make sure to invoke the insert hook\r\n            insertedVnodeQueue.push(vnode);\r\n        }\r\n    }\r\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\r\n        let i;\r\n        // hack for #4339: a reactivated component with inner transition\r\n        // does not trigger because the inner node's created hooks are not called\r\n        // again. It's not ideal to involve module-specific logic in here but\r\n        // there doesn't seem to be a better way to do it.\r\n        let innerNode = vnode;\r\n        while (innerNode.componentInstance) {\r\n            innerNode = innerNode.componentInstance._vnode;\r\n            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {\r\n                for (i = 0; i < cbs.activate.length; ++i) {\r\n                    cbs.activate[i](emptyNode, innerNode);\r\n                }\r\n                insertedVnodeQueue.push(innerNode);\r\n                break;\r\n            }\r\n        }\r\n        // unlike a newly created component,\r\n        // a reactivated keep-alive component doesn't insert itself\r\n        insert(parentElm, vnode.elm, refElm);\r\n    }\r\n    function insert(parent, elm, ref) {\r\n        if (isDef(parent)) {\r\n            if (isDef(ref)) {\r\n                if (nodeOps.parentNode(ref) === parent) {\r\n                    nodeOps.insertBefore(parent, elm, ref);\r\n                }\r\n            }\r\n            else {\r\n                nodeOps.appendChild(parent, elm);\r\n            }\r\n        }\r\n    }\r\n    function createChildren(vnode, children, insertedVnodeQueue) {\r\n        if (isArray(children)) {\r\n            {\r\n                checkDuplicateKeys(children);\r\n            }\r\n            for (let i = 0; i < children.length; ++i) {\r\n                createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\r\n            }\r\n        }\r\n        else if (isPrimitive(vnode.text)) {\r\n            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\r\n        }\r\n    }\r\n    function isPatchable(vnode) {\r\n        while (vnode.componentInstance) {\r\n            vnode = vnode.componentInstance._vnode;\r\n        }\r\n        return isDef(vnode.tag);\r\n    }\r\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\r\n        for (let i = 0; i < cbs.create.length; ++i) {\r\n            cbs.create[i](emptyNode, vnode);\r\n        }\r\n        i = vnode.data.hook; // Reuse variable\r\n        if (isDef(i)) {\r\n            if (isDef(i.create))\r\n                i.create(emptyNode, vnode);\r\n            if (isDef(i.insert))\r\n                insertedVnodeQueue.push(vnode);\r\n        }\r\n    }\r\n    // set scope id attribute for scoped CSS.\r\n    // this is implemented as a special case to avoid the overhead\r\n    // of going through the normal attribute patching process.\r\n    function setScope(vnode) {\r\n        let i;\r\n        if (isDef((i = vnode.fnScopeId))) {\r\n            nodeOps.setStyleScope(vnode.elm, i);\r\n        }\r\n        else {\r\n            let ancestor = vnode;\r\n            while (ancestor) {\r\n                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {\r\n                    nodeOps.setStyleScope(vnode.elm, i);\r\n                }\r\n                ancestor = ancestor.parent;\r\n            }\r\n        }\r\n        // for slot content they should also get the scopeId from the host instance.\r\n        if (isDef((i = activeInstance)) &&\r\n            i !== vnode.context &&\r\n            i !== vnode.fnContext &&\r\n            isDef((i = i.$options._scopeId))) {\r\n            nodeOps.setStyleScope(vnode.elm, i);\r\n        }\r\n    }\r\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\r\n        for (; startIdx <= endIdx; ++startIdx) {\r\n            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\r\n        }\r\n    }\r\n    function invokeDestroyHook(vnode) {\r\n        let i, j;\r\n        const data = vnode.data;\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.destroy)))\r\n                i(vnode);\r\n            for (i = 0; i < cbs.destroy.length; ++i)\r\n                cbs.destroy[i](vnode);\r\n        }\r\n        if (isDef((i = vnode.children))) {\r\n            for (j = 0; j < vnode.children.length; ++j) {\r\n                invokeDestroyHook(vnode.children[j]);\r\n            }\r\n        }\r\n    }\r\n    function removeVnodes(vnodes, startIdx, endIdx) {\r\n        for (; startIdx <= endIdx; ++startIdx) {\r\n            const ch = vnodes[startIdx];\r\n            if (isDef(ch)) {\r\n                if (isDef(ch.tag)) {\r\n                    removeAndInvokeRemoveHook(ch);\r\n                    invokeDestroyHook(ch);\r\n                }\r\n                else {\r\n                    // Text node\r\n                    removeNode(ch.elm);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function removeAndInvokeRemoveHook(vnode, rm) {\r\n        if (isDef(rm) || isDef(vnode.data)) {\r\n            let i;\r\n            const listeners = cbs.remove.length + 1;\r\n            if (isDef(rm)) {\r\n                // we have a recursively passed down rm callback\r\n                // increase the listeners count\r\n                rm.listeners += listeners;\r\n            }\r\n            else {\r\n                // directly removing\r\n                rm = createRmCb(vnode.elm, listeners);\r\n            }\r\n            // recursively invoke hooks on child component root node\r\n            if (isDef((i = vnode.componentInstance)) &&\r\n                isDef((i = i._vnode)) &&\r\n                isDef(i.data)) {\r\n                removeAndInvokeRemoveHook(i, rm);\r\n            }\r\n            for (i = 0; i < cbs.remove.length; ++i) {\r\n                cbs.remove[i](vnode, rm);\r\n            }\r\n            if (isDef((i = vnode.data.hook)) && isDef((i = i.remove))) {\r\n                i(vnode, rm);\r\n            }\r\n            else {\r\n                rm();\r\n            }\r\n        }\r\n        else {\r\n            removeNode(vnode.elm);\r\n        }\r\n    }\r\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\r\n        let oldStartIdx = 0;\r\n        let newStartIdx = 0;\r\n        let oldEndIdx = oldCh.length - 1;\r\n        let oldStartVnode = oldCh[0];\r\n        let oldEndVnode = oldCh[oldEndIdx];\r\n        let newEndIdx = newCh.length - 1;\r\n        let newStartVnode = newCh[0];\r\n        let newEndVnode = newCh[newEndIdx];\r\n        let oldKeyToIdx, idxInOld, vnodeToMove, refElm;\r\n        // removeOnly is a special flag used only by <transition-group>\r\n        // to ensure removed elements stay in correct relative positions\r\n        // during leaving transitions\r\n        const canMove = !removeOnly;\r\n        {\r\n            checkDuplicateKeys(newCh);\r\n        }\r\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n            if (isUndef(oldStartVnode)) {\r\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\r\n            }\r\n            else if (isUndef(oldEndVnode)) {\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n            }\r\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                oldStartVnode = oldCh[++oldStartIdx];\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n                newEndVnode = newCh[--newEndIdx];\r\n            }\r\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n                // Vnode moved right\r\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\r\n                canMove &&\r\n                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\r\n                oldStartVnode = oldCh[++oldStartIdx];\r\n                newEndVnode = newCh[--newEndIdx];\r\n            }\r\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n                // Vnode moved left\r\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                canMove &&\r\n                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            else {\r\n                if (isUndef(oldKeyToIdx))\r\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\r\n                idxInOld = isDef(newStartVnode.key)\r\n                    ? oldKeyToIdx[newStartVnode.key]\r\n                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\r\n                if (isUndef(idxInOld)) {\r\n                    // New element\r\n                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\r\n                }\r\n                else {\r\n                    vnodeToMove = oldCh[idxInOld];\r\n                    if (sameVnode(vnodeToMove, newStartVnode)) {\r\n                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                        oldCh[idxInOld] = undefined;\r\n                        canMove &&\r\n                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\r\n                    }\r\n                    else {\r\n                        // same key but different element. treat as new element\r\n                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\r\n                    }\r\n                }\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n        }\r\n        if (oldStartIdx > oldEndIdx) {\r\n            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\r\n            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\r\n        }\r\n        else if (newStartIdx > newEndIdx) {\r\n            removeVnodes(oldCh, oldStartIdx, oldEndIdx);\r\n        }\r\n    }\r\n    function checkDuplicateKeys(children) {\r\n        const seenKeys = {};\r\n        for (let i = 0; i < children.length; i++) {\r\n            const vnode = children[i];\r\n            const key = vnode.key;\r\n            if (isDef(key)) {\r\n                if (seenKeys[key]) {\r\n                    warn(`Duplicate keys detected: '${key}'. This may cause an update error.`, vnode.context);\r\n                }\r\n                else {\r\n                    seenKeys[key] = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function findIdxInOld(node, oldCh, start, end) {\r\n        for (let i = start; i < end; i++) {\r\n            const c = oldCh[i];\r\n            if (isDef(c) && sameVnode(node, c))\r\n                return i;\r\n        }\r\n    }\r\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\r\n        if (oldVnode === vnode) {\r\n            return;\r\n        }\r\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\r\n            // clone reused vnode\r\n            vnode = ownerArray[index] = cloneVNode(vnode);\r\n        }\r\n        const elm = (vnode.elm = oldVnode.elm);\r\n        if (isTrue(oldVnode.isAsyncPlaceholder)) {\r\n            if (isDef(vnode.asyncFactory.resolved)) {\r\n                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\r\n            }\r\n            else {\r\n                vnode.isAsyncPlaceholder = true;\r\n            }\r\n            return;\r\n        }\r\n        // reuse element for static trees.\r\n        // note we only do this if the vnode is cloned -\r\n        // if the new node is not cloned it means the render functions have been\r\n        // reset by the hot-reload-api and we need to do a proper re-render.\r\n        if (isTrue(vnode.isStatic) &&\r\n            isTrue(oldVnode.isStatic) &&\r\n            vnode.key === oldVnode.key &&\r\n            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\r\n            vnode.componentInstance = oldVnode.componentInstance;\r\n            return;\r\n        }\r\n        let i;\r\n        const data = vnode.data;\r\n        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {\r\n            i(oldVnode, vnode);\r\n        }\r\n        const oldCh = oldVnode.children;\r\n        const ch = vnode.children;\r\n        if (isDef(data) && isPatchable(vnode)) {\r\n            for (i = 0; i < cbs.update.length; ++i)\r\n                cbs.update[i](oldVnode, vnode);\r\n            if (isDef((i = data.hook)) && isDef((i = i.update)))\r\n                i(oldVnode, vnode);\r\n        }\r\n        if (isUndef(vnode.text)) {\r\n            if (isDef(oldCh) && isDef(ch)) {\r\n                if (oldCh !== ch)\r\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\r\n            }\r\n            else if (isDef(ch)) {\r\n                {\r\n                    checkDuplicateKeys(ch);\r\n                }\r\n                if (isDef(oldVnode.text))\r\n                    nodeOps.setTextContent(elm, '');\r\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n            }\r\n            else if (isDef(oldCh)) {\r\n                removeVnodes(oldCh, 0, oldCh.length - 1);\r\n            }\r\n            else if (isDef(oldVnode.text)) {\r\n                nodeOps.setTextContent(elm, '');\r\n            }\r\n        }\r\n        else if (oldVnode.text !== vnode.text) {\r\n            nodeOps.setTextContent(elm, vnode.text);\r\n        }\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))\r\n                i(oldVnode, vnode);\r\n        }\r\n    }\r\n    function invokeInsertHook(vnode, queue, initial) {\r\n        // delay insert hooks for component root nodes, invoke them after the\r\n        // element is really inserted\r\n        if (isTrue(initial) && isDef(vnode.parent)) {\r\n            vnode.parent.data.pendingInsert = queue;\r\n        }\r\n        else {\r\n            for (let i = 0; i < queue.length; ++i) {\r\n                queue[i].data.hook.insert(queue[i]);\r\n            }\r\n        }\r\n    }\r\n    let hydrationBailed = false;\r\n    // list of modules that can skip create hook during hydration because they\r\n    // are already rendered on the client or has no need for initialization\r\n    // Note: style is excluded because it relies on initial clone for future\r\n    // deep updates (#7063).\r\n    const isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\r\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\r\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\r\n        let i;\r\n        const { tag, data, children } = vnode;\r\n        inVPre = inVPre || (data && data.pre);\r\n        vnode.elm = elm;\r\n        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\r\n            vnode.isAsyncPlaceholder = true;\r\n            return true;\r\n        }\r\n        // assert node match\r\n        {\r\n            if (!assertNodeMatch(elm, vnode, inVPre)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.init)))\r\n                i(vnode, true /* hydrating */);\r\n            if (isDef((i = vnode.componentInstance))) {\r\n                // child component. it should have hydrated its own tree.\r\n                initComponent(vnode, insertedVnodeQueue);\r\n                return true;\r\n            }\r\n        }\r\n        if (isDef(tag)) {\r\n            if (isDef(children)) {\r\n                // empty element, allow client to pick up and populate children\r\n                if (!elm.hasChildNodes()) {\r\n                    createChildren(vnode, children, insertedVnodeQueue);\r\n                }\r\n                else {\r\n                    // v-html and domProps: innerHTML\r\n                    if (isDef((i = data)) &&\r\n                        isDef((i = i.domProps)) &&\r\n                        isDef((i = i.innerHTML))) {\r\n                        if (i !== elm.innerHTML) {\r\n                            /* istanbul ignore if */\r\n                            if (typeof console !== 'undefined' &&\r\n                                !hydrationBailed) {\r\n                                hydrationBailed = true;\r\n                                console.warn('Parent: ', elm);\r\n                                console.warn('server innerHTML: ', i);\r\n                                console.warn('client innerHTML: ', elm.innerHTML);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // iterate and compare children lists\r\n                        let childrenMatch = true;\r\n                        let childNode = elm.firstChild;\r\n                        for (let i = 0; i < children.length; i++) {\r\n                            if (!childNode ||\r\n                                !hydrate(childNode, children[i], insertedVnodeQueue, inVPre)) {\r\n                                childrenMatch = false;\r\n                                break;\r\n                            }\r\n                            childNode = childNode.nextSibling;\r\n                        }\r\n                        // if childNode is not null, it means the actual childNodes list is\r\n                        // longer than the virtual children list.\r\n                        if (!childrenMatch || childNode) {\r\n                            /* istanbul ignore if */\r\n                            if (typeof console !== 'undefined' &&\r\n                                !hydrationBailed) {\r\n                                hydrationBailed = true;\r\n                                console.warn('Parent: ', elm);\r\n                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isDef(data)) {\r\n                let fullInvoke = false;\r\n                for (const key in data) {\r\n                    if (!isRenderedModule(key)) {\r\n                        fullInvoke = true;\r\n                        invokeCreateHooks(vnode, insertedVnodeQueue);\r\n                        break;\r\n                    }\r\n                }\r\n                if (!fullInvoke && data['class']) {\r\n                    // ensure collecting deps for deep class bindings for future updates\r\n                    traverse(data['class']);\r\n                }\r\n            }\r\n        }\r\n        else if (elm.data !== vnode.text) {\r\n            elm.data = vnode.text;\r\n        }\r\n        return true;\r\n    }\r\n    function assertNodeMatch(node, vnode, inVPre) {\r\n        if (isDef(vnode.tag)) {\r\n            return (vnode.tag.indexOf('vue-component') === 0 ||\r\n                (!isUnknownElement(vnode, inVPre) &&\r\n                    vnode.tag.toLowerCase() ===\r\n                        (node.tagName && node.tagName.toLowerCase())));\r\n        }\r\n        else {\r\n            return node.nodeType === (vnode.isComment ? 8 : 3);\r\n        }\r\n    }\r\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\r\n        if (isUndef(vnode)) {\r\n            if (isDef(oldVnode))\r\n                invokeDestroyHook(oldVnode);\r\n            return;\r\n        }\r\n        let isInitialPatch = false;\r\n        const insertedVnodeQueue = [];\r\n        if (isUndef(oldVnode)) {\r\n            // empty mount (likely as component), create new root element\r\n            isInitialPatch = true;\r\n            createElm(vnode, insertedVnodeQueue);\r\n        }\r\n        else {\r\n            const isRealElement = isDef(oldVnode.nodeType);\r\n            if (!isRealElement && sameVnode(oldVnode, vnode)) {\r\n                // patch existing root node\r\n                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\r\n            }\r\n            else {\r\n                if (isRealElement) {\r\n                    // mounting to a real element\r\n                    // check if this is server-rendered content and if we can perform\r\n                    // a successful hydration.\r\n                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\r\n                        oldVnode.removeAttribute(SSR_ATTR);\r\n                        hydrating = true;\r\n                    }\r\n                    if (isTrue(hydrating)) {\r\n                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\r\n                            invokeInsertHook(vnode, insertedVnodeQueue, true);\r\n                            return oldVnode;\r\n                        }\r\n                        else {\r\n                            warn('The client-side rendered virtual DOM tree is not matching ' +\r\n                                'server-rendered content. This is likely caused by incorrect ' +\r\n                                'HTML markup, for example nesting block-level elements inside ' +\r\n                                '<p>, or missing <tbody>. Bailing hydration and performing ' +\r\n                                'full client-side render.');\r\n                        }\r\n                    }\r\n                    // either not server-rendered, or hydration failed.\r\n                    // create an empty node and replace it\r\n                    oldVnode = emptyNodeAt(oldVnode);\r\n                }\r\n                // replacing existing element\r\n                const oldElm = oldVnode.elm;\r\n                const parentElm = nodeOps.parentNode(oldElm);\r\n                // create new node\r\n                createElm(vnode, insertedVnodeQueue, \r\n                // extremely rare edge case: do not insert if old element is in a\r\n                // leaving transition. Only happens when combining transition +\r\n                // keep-alive + HOCs. (#4590)\r\n                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));\r\n                // update parent placeholder node element, recursively\r\n                if (isDef(vnode.parent)) {\r\n                    let ancestor = vnode.parent;\r\n                    const patchable = isPatchable(vnode);\r\n                    while (ancestor) {\r\n                        for (let i = 0; i < cbs.destroy.length; ++i) {\r\n                            cbs.destroy[i](ancestor);\r\n                        }\r\n                        ancestor.elm = vnode.elm;\r\n                        if (patchable) {\r\n                            for (let i = 0; i < cbs.create.length; ++i) {\r\n                                cbs.create[i](emptyNode, ancestor);\r\n                            }\r\n                            // #6513\r\n                            // invoke insert hooks that may have been merged by create hooks.\r\n                            // e.g. for directives that uses the \"inserted\" hook.\r\n                            const insert = ancestor.data.hook.insert;\r\n                            if (insert.merged) {\r\n                                // start at index 1 to avoid re-invoking component mounted hook\r\n                                for (let i = 1; i < insert.fns.length; i++) {\r\n                                    insert.fns[i]();\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            registerRef(ancestor);\r\n                        }\r\n                        ancestor = ancestor.parent;\r\n                    }\r\n                }\r\n                // destroy old node\r\n                if (isDef(parentElm)) {\r\n                    removeVnodes([oldVnode], 0, 0);\r\n                }\r\n                else if (isDef(oldVnode.tag)) {\r\n                    invokeDestroyHook(oldVnode);\r\n                }\r\n            }\r\n        }\r\n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\r\n        return vnode.elm;\r\n    };\r\n}\n\nvar directives = {\r\n    create: updateDirectives,\r\n    update: updateDirectives,\r\n    destroy: function unbindDirectives(vnode) {\r\n        // @ts-expect-error emptyNode is not VNodeWithData\r\n        updateDirectives(vnode, emptyNode);\r\n    }\r\n};\r\nfunction updateDirectives(oldVnode, vnode) {\r\n    if (oldVnode.data.directives || vnode.data.directives) {\r\n        _update(oldVnode, vnode);\r\n    }\r\n}\r\nfunction _update(oldVnode, vnode) {\r\n    const isCreate = oldVnode === emptyNode;\r\n    const isDestroy = vnode === emptyNode;\r\n    const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);\r\n    const newDirs = normalizeDirectives(vnode.data.directives, vnode.context);\r\n    const dirsWithInsert = [];\r\n    const dirsWithPostpatch = [];\r\n    let key, oldDir, dir;\r\n    for (key in newDirs) {\r\n        oldDir = oldDirs[key];\r\n        dir = newDirs[key];\r\n        if (!oldDir) {\r\n            // new directive, bind\r\n            callHook(dir, 'bind', vnode, oldVnode);\r\n            if (dir.def && dir.def.inserted) {\r\n                dirsWithInsert.push(dir);\r\n            }\r\n        }\r\n        else {\r\n            // existing directive, update\r\n            dir.oldValue = oldDir.value;\r\n            dir.oldArg = oldDir.arg;\r\n            callHook(dir, 'update', vnode, oldVnode);\r\n            if (dir.def && dir.def.componentUpdated) {\r\n                dirsWithPostpatch.push(dir);\r\n            }\r\n        }\r\n    }\r\n    if (dirsWithInsert.length) {\r\n        const callInsert = () => {\r\n            for (let i = 0; i < dirsWithInsert.length; i++) {\r\n                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);\r\n            }\r\n        };\r\n        if (isCreate) {\r\n            mergeVNodeHook(vnode, 'insert', callInsert);\r\n        }\r\n        else {\r\n            callInsert();\r\n        }\r\n    }\r\n    if (dirsWithPostpatch.length) {\r\n        mergeVNodeHook(vnode, 'postpatch', () => {\r\n            for (let i = 0; i < dirsWithPostpatch.length; i++) {\r\n                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\r\n            }\r\n        });\r\n    }\r\n    if (!isCreate) {\r\n        for (key in oldDirs) {\r\n            if (!newDirs[key]) {\r\n                // no longer present, unbind\r\n                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\r\n            }\r\n        }\r\n    }\r\n}\r\nconst emptyModifiers = Object.create(null);\r\nfunction normalizeDirectives(dirs, vm) {\r\n    const res = Object.create(null);\r\n    if (!dirs) {\r\n        // $flow-disable-line\r\n        return res;\r\n    }\r\n    let i, dir;\r\n    for (i = 0; i < dirs.length; i++) {\r\n        dir = dirs[i];\r\n        if (!dir.modifiers) {\r\n            // $flow-disable-line\r\n            dir.modifiers = emptyModifiers;\r\n        }\r\n        res[getRawDirName(dir)] = dir;\r\n        if (vm._setupState && vm._setupState.__sfc) {\r\n            const setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);\r\n            if (typeof setupDef === 'function') {\r\n                dir.def = {\r\n                    bind: setupDef,\r\n                    update: setupDef,\r\n                };\r\n            }\r\n            else {\r\n                dir.def = setupDef;\r\n            }\r\n        }\r\n        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);\r\n    }\r\n    // $flow-disable-line\r\n    return res;\r\n}\r\nfunction getRawDirName(dir) {\r\n    return (dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join('.')}`);\r\n}\r\nfunction callHook(dir, hook, vnode, oldVnode, isDestroy) {\r\n    const fn = dir.def && dir.def[hook];\r\n    if (fn) {\r\n        try {\r\n            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\r\n        }\r\n        catch (e) {\r\n            handleError(e, vnode.context, `directive ${dir.name} ${hook} hook`);\r\n        }\r\n    }\r\n}\n\nvar baseModules = [ref, directives];\n\nfunction updateAttrs(oldVnode, vnode) {\r\n    const opts = vnode.componentOptions;\r\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\r\n        return;\r\n    }\r\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\r\n        return;\r\n    }\r\n    let key, cur, old;\r\n    const elm = vnode.elm;\r\n    const oldAttrs = oldVnode.data.attrs || {};\r\n    let attrs = vnode.data.attrs || {};\r\n    // clone observed objects, as the user probably wants to mutate it\r\n    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {\r\n        attrs = vnode.data.attrs = extend({}, attrs);\r\n    }\r\n    for (key in attrs) {\r\n        cur = attrs[key];\r\n        old = oldAttrs[key];\r\n        if (old !== cur) {\r\n            setAttr(elm, key, cur, vnode.data.pre);\r\n        }\r\n    }\r\n    // #4391: in IE9, setting type can reset value for input[type=radio]\r\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\r\n    /* istanbul ignore if */\r\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\r\n        setAttr(elm, 'value', attrs.value);\r\n    }\r\n    for (key in oldAttrs) {\r\n        if (isUndef(attrs[key])) {\r\n            if (isXlink(key)) {\r\n                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n            }\r\n            else if (!isEnumeratedAttr(key)) {\r\n                elm.removeAttribute(key);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction setAttr(el, key, value, isInPre) {\r\n    if (isInPre || el.tagName.indexOf('-') > -1) {\r\n        baseSetAttr(el, key, value);\r\n    }\r\n    else if (isBooleanAttr(key)) {\r\n        // set attribute for blank value\r\n        // e.g. <option disabled>Select one</option>\r\n        if (isFalsyAttrValue(value)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            // technically allowfullscreen is a boolean attribute for <iframe>,\r\n            // but Flash expects a value of \"true\" when used on <embed> tag\r\n            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\r\n            el.setAttribute(key, value);\r\n        }\r\n    }\r\n    else if (isEnumeratedAttr(key)) {\r\n        el.setAttribute(key, convertEnumeratedValue(key, value));\r\n    }\r\n    else if (isXlink(key)) {\r\n        if (isFalsyAttrValue(value)) {\r\n            el.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        baseSetAttr(el, key, value);\r\n    }\r\n}\r\nfunction baseSetAttr(el, key, value) {\r\n    if (isFalsyAttrValue(value)) {\r\n        el.removeAttribute(key);\r\n    }\r\n    else {\r\n        // #7138: IE10 & 11 fires input event when setting placeholder on\r\n        // <textarea>... block the first input event and remove the blocker\r\n        // immediately.\r\n        /* istanbul ignore if */\r\n        if (isIE &&\r\n            !isIE9 &&\r\n            el.tagName === 'TEXTAREA' &&\r\n            key === 'placeholder' &&\r\n            value !== '' &&\r\n            !el.__ieph) {\r\n            const blocker = e => {\r\n                e.stopImmediatePropagation();\r\n                el.removeEventListener('input', blocker);\r\n            };\r\n            el.addEventListener('input', blocker);\r\n            // $flow-disable-line\r\n            el.__ieph = true; /* IE placeholder patched */\r\n        }\r\n        el.setAttribute(key, value);\r\n    }\r\n}\r\nvar attrs = {\r\n    create: updateAttrs,\r\n    update: updateAttrs\r\n};\n\nfunction updateClass(oldVnode, vnode) {\r\n    const el = vnode.elm;\r\n    const data = vnode.data;\r\n    const oldData = oldVnode.data;\r\n    if (isUndef(data.staticClass) &&\r\n        isUndef(data.class) &&\r\n        (isUndef(oldData) ||\r\n            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {\r\n        return;\r\n    }\r\n    let cls = genClassForVnode(vnode);\r\n    // handle transition classes\r\n    const transitionClass = el._transitionClasses;\r\n    if (isDef(transitionClass)) {\r\n        cls = concat(cls, stringifyClass(transitionClass));\r\n    }\r\n    // set the class\r\n    if (cls !== el._prevClass) {\r\n        el.setAttribute('class', cls);\r\n        el._prevClass = cls;\r\n    }\r\n}\r\nvar klass = {\r\n    create: updateClass,\r\n    update: updateClass\r\n};\n\n// in some cases, the event used has to be determined at runtime\r\n// so we used some reserved tokens during compile.\r\nconst RANGE_TOKEN = '__r';\r\nconst CHECKBOX_RADIO_TOKEN = '__c';\n\n// normalize v-model event tokens that can only be determined at runtime.\r\n// it's important to place the event as the first in the array because\r\n// the whole point is ensuring the v-model callback gets called before\r\n// user-attached handlers.\r\nfunction normalizeEvents(on) {\r\n    /* istanbul ignore if */\r\n    if (isDef(on[RANGE_TOKEN])) {\r\n        // IE input[type=range] only supports `change` event\r\n        const event = isIE ? 'change' : 'input';\r\n        on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\r\n        delete on[RANGE_TOKEN];\r\n    }\r\n    // This was originally intended to fix #4521 but no longer necessary\r\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\r\n    /* istanbul ignore if */\r\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\r\n        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\r\n        delete on[CHECKBOX_RADIO_TOKEN];\r\n    }\r\n}\r\nlet target;\r\nfunction createOnceHandler(event, handler, capture) {\r\n    const _target = target; // save current target element in closure\r\n    return function onceHandler() {\r\n        const res = handler.apply(null, arguments);\r\n        if (res !== null) {\r\n            remove(event, onceHandler, capture, _target);\r\n        }\r\n    };\r\n}\r\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\r\n// implementation and does not fire microtasks in between event propagation, so\r\n// safe to exclude.\r\nconst useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\r\nfunction add(name, handler, capture, passive) {\r\n    // async edge case #6566: inner click event triggers patch, event handler\r\n    // attached to outer element during patch, and triggered again. This\r\n    // happens because browsers fire microtask ticks between event propagation.\r\n    // the solution is simple: we save the timestamp when a handler is attached,\r\n    // and the handler would only fire if the event passed to it was fired\r\n    // AFTER it was attached.\r\n    if (useMicrotaskFix) {\r\n        const attachedTimestamp = currentFlushTimestamp;\r\n        const original = handler;\r\n        //@ts-expect-error\r\n        handler = original._wrapper = function (e) {\r\n            if (\r\n            // no bubbling, should always fire.\r\n            // this is just a safety net in case event.timeStamp is unreliable in\r\n            // certain weird environments...\r\n            e.target === e.currentTarget ||\r\n                // event is fired after handler attachment\r\n                e.timeStamp >= attachedTimestamp ||\r\n                // bail for environments that have buggy event.timeStamp implementations\r\n                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\r\n                // #9681 QtWebEngine event.timeStamp is negative value\r\n                e.timeStamp <= 0 ||\r\n                // #9448 bail if event is fired in another document in a multi-page\r\n                // electron/nw.js app, since event.timeStamp will be using a different\r\n                // starting reference\r\n                e.target.ownerDocument !== document) {\r\n                return original.apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n    target.addEventListener(name, handler, supportsPassive ? { capture, passive } : capture);\r\n}\r\nfunction remove(name, handler, capture, _target) {\r\n    (_target || target).removeEventListener(name, \r\n    //@ts-expect-error\r\n    handler._wrapper || handler, capture);\r\n}\r\nfunction updateDOMListeners(oldVnode, vnode) {\r\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\r\n        return;\r\n    }\r\n    const on = vnode.data.on || {};\r\n    const oldOn = oldVnode.data.on || {};\r\n    // vnode is empty when removing all listeners,\r\n    // and use old vnode dom element\r\n    target = vnode.elm || oldVnode.elm;\r\n    normalizeEvents(on);\r\n    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);\r\n    target = undefined;\r\n}\r\nvar events = {\r\n    create: updateDOMListeners,\r\n    update: updateDOMListeners,\r\n    // @ts-expect-error emptyNode has actually data\r\n    destroy: (vnode) => updateDOMListeners(vnode, emptyNode)\r\n};\n\nlet svgContainer;\r\nfunction updateDOMProps(oldVnode, vnode) {\r\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\r\n        return;\r\n    }\r\n    let key, cur;\r\n    const elm = vnode.elm;\r\n    const oldProps = oldVnode.data.domProps || {};\r\n    let props = vnode.data.domProps || {};\r\n    // clone observed objects, as the user probably wants to mutate it\r\n    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {\r\n        props = vnode.data.domProps = extend({}, props);\r\n    }\r\n    for (key in oldProps) {\r\n        if (!(key in props)) {\r\n            elm[key] = '';\r\n        }\r\n    }\r\n    for (key in props) {\r\n        cur = props[key];\r\n        // ignore children if the node has textContent or innerHTML,\r\n        // as these will throw away existing DOM nodes and cause removal errors\r\n        // on subsequent patches (#3360)\r\n        if (key === 'textContent' || key === 'innerHTML') {\r\n            if (vnode.children)\r\n                vnode.children.length = 0;\r\n            if (cur === oldProps[key])\r\n                continue;\r\n            // #6601 work around Chrome version <= 55 bug where single textNode\r\n            // replaced by innerHTML/textContent retains its parentNode property\r\n            if (elm.childNodes.length === 1) {\r\n                elm.removeChild(elm.childNodes[0]);\r\n            }\r\n        }\r\n        if (key === 'value' && elm.tagName !== 'PROGRESS') {\r\n            // store value as _value as well since\r\n            // non-string values will be stringified\r\n            elm._value = cur;\r\n            // avoid resetting cursor position when value is the same\r\n            const strCur = isUndef(cur) ? '' : String(cur);\r\n            if (shouldUpdateValue(elm, strCur)) {\r\n                elm.value = strCur;\r\n            }\r\n        }\r\n        else if (key === 'innerHTML' &&\r\n            isSVG(elm.tagName) &&\r\n            isUndef(elm.innerHTML)) {\r\n            // IE doesn't support innerHTML for SVG elements\r\n            svgContainer = svgContainer || document.createElement('div');\r\n            svgContainer.innerHTML = `<svg>${cur}</svg>`;\r\n            const svg = svgContainer.firstChild;\r\n            while (elm.firstChild) {\r\n                elm.removeChild(elm.firstChild);\r\n            }\r\n            while (svg.firstChild) {\r\n                elm.appendChild(svg.firstChild);\r\n            }\r\n        }\r\n        else if (\r\n        // skip the update if old and new VDOM state is the same.\r\n        // `value` is handled separately because the DOM value may be temporarily\r\n        // out of sync with VDOM state due to focus, composition and modifiers.\r\n        // This  #4521 by skipping the unnecessary `checked` update.\r\n        cur !== oldProps[key]) {\r\n            // some property updates can throw\r\n            // e.g. `value` on <progress> w/ non-finite value\r\n            try {\r\n                elm[key] = cur;\r\n            }\r\n            catch (e) { }\r\n        }\r\n    }\r\n}\r\nfunction shouldUpdateValue(elm, checkVal) {\r\n    return (\r\n    //@ts-expect-error\r\n    !elm.composing &&\r\n        (elm.tagName === 'OPTION' ||\r\n            isNotInFocusAndDirty(elm, checkVal) ||\r\n            isDirtyWithModifiers(elm, checkVal)));\r\n}\r\nfunction isNotInFocusAndDirty(elm, checkVal) {\r\n    // return true when textbox (.number and .trim) loses focus and its value is\r\n    // not equal to the updated value\r\n    let notInFocus = true;\r\n    // #6157\r\n    // work around IE bug when accessing document.activeElement in an iframe\r\n    try {\r\n        notInFocus = document.activeElement !== elm;\r\n    }\r\n    catch (e) { }\r\n    return notInFocus && elm.value !== checkVal;\r\n}\r\nfunction isDirtyWithModifiers(elm, newVal) {\r\n    const value = elm.value;\r\n    const modifiers = elm._vModifiers; // injected by v-model runtime\r\n    if (isDef(modifiers)) {\r\n        if (modifiers.number) {\r\n            return toNumber(value) !== toNumber(newVal);\r\n        }\r\n        if (modifiers.trim) {\r\n            return value.trim() !== newVal.trim();\r\n        }\r\n    }\r\n    return value !== newVal;\r\n}\r\nvar domProps = {\r\n    create: updateDOMProps,\r\n    update: updateDOMProps\r\n};\n\nconst parseStyleText = cached(function (cssText) {\r\n    const res = {};\r\n    const listDelimiter = /;(?![^(]*\\))/g;\r\n    const propertyDelimiter = /:(.+)/;\r\n    cssText.split(listDelimiter).forEach(function (item) {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiter);\r\n            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return res;\r\n});\r\n// merge static and dynamic style data on the same vnode\r\nfunction normalizeStyleData(data) {\r\n    const style = normalizeStyleBinding(data.style);\r\n    // static style is pre-processed into an object during compilation\r\n    // and is always a fresh object, so it's safe to merge into it\r\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\r\n}\r\n// normalize possible array / string values into Object\r\nfunction normalizeStyleBinding(bindingStyle) {\r\n    if (Array.isArray(bindingStyle)) {\r\n        return toObject(bindingStyle);\r\n    }\r\n    if (typeof bindingStyle === 'string') {\r\n        return parseStyleText(bindingStyle);\r\n    }\r\n    return bindingStyle;\r\n}\r\n/**\r\n * parent component style should be after child's\r\n * so that parent component's style could override it\r\n */\r\nfunction getStyle(vnode, checkChild) {\r\n    const res = {};\r\n    let styleData;\r\n    if (checkChild) {\r\n        let childNode = vnode;\r\n        while (childNode.componentInstance) {\r\n            childNode = childNode.componentInstance._vnode;\r\n            if (childNode &&\r\n                childNode.data &&\r\n                (styleData = normalizeStyleData(childNode.data))) {\r\n                extend(res, styleData);\r\n            }\r\n        }\r\n    }\r\n    if ((styleData = normalizeStyleData(vnode.data))) {\r\n        extend(res, styleData);\r\n    }\r\n    let parentNode = vnode;\r\n    // @ts-expect-error parentNode.parent not VNodeWithData\r\n    while ((parentNode = parentNode.parent)) {\r\n        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\r\n            extend(res, styleData);\r\n        }\r\n    }\r\n    return res;\r\n}\n\nconst cssVarRE = /^--/;\r\nconst importantRE = /\\s*!important$/;\r\nconst setProp = (el, name, val) => {\r\n    /* istanbul ignore if */\r\n    if (cssVarRE.test(name)) {\r\n        el.style.setProperty(name, val);\r\n    }\r\n    else if (importantRE.test(val)) {\r\n        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\r\n    }\r\n    else {\r\n        const normalizedName = normalize(name);\r\n        if (Array.isArray(val)) {\r\n            // Support values array created by autoprefixer, e.g.\r\n            // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\r\n            // Set them one by one, and the browser will only set those it can recognize\r\n            for (let i = 0, len = val.length; i < len; i++) {\r\n                el.style[normalizedName] = val[i];\r\n            }\r\n        }\r\n        else {\r\n            el.style[normalizedName] = val;\r\n        }\r\n    }\r\n};\r\nconst vendorNames = ['Webkit', 'Moz', 'ms'];\r\nlet emptyStyle;\r\nconst normalize = cached(function (prop) {\r\n    emptyStyle = emptyStyle || document.createElement('div').style;\r\n    prop = camelize(prop);\r\n    if (prop !== 'filter' && prop in emptyStyle) {\r\n        return prop;\r\n    }\r\n    const capName = prop.charAt(0).toUpperCase() + prop.slice(1);\r\n    for (let i = 0; i < vendorNames.length; i++) {\r\n        const name = vendorNames[i] + capName;\r\n        if (name in emptyStyle) {\r\n            return name;\r\n        }\r\n    }\r\n});\r\nfunction updateStyle(oldVnode, vnode) {\r\n    const data = vnode.data;\r\n    const oldData = oldVnode.data;\r\n    if (isUndef(data.staticStyle) &&\r\n        isUndef(data.style) &&\r\n        isUndef(oldData.staticStyle) &&\r\n        isUndef(oldData.style)) {\r\n        return;\r\n    }\r\n    let cur, name;\r\n    const el = vnode.elm;\r\n    const oldStaticStyle = oldData.staticStyle;\r\n    const oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\r\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\r\n    const oldStyle = oldStaticStyle || oldStyleBinding;\r\n    const style = normalizeStyleBinding(vnode.data.style) || {};\r\n    // store normalized style under a different key for next diff\r\n    // make sure to clone it if it's reactive, since the user likely wants\r\n    // to mutate it.\r\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\r\n    const newStyle = getStyle(vnode, true);\r\n    for (name in oldStyle) {\r\n        if (isUndef(newStyle[name])) {\r\n            setProp(el, name, '');\r\n        }\r\n    }\r\n    for (name in newStyle) {\r\n        cur = newStyle[name];\r\n        if (cur !== oldStyle[name]) {\r\n            // ie9 setting to null has no effect, must use empty string\r\n            setProp(el, name, cur == null ? '' : cur);\r\n        }\r\n    }\r\n}\r\nvar style = {\r\n    create: updateStyle,\r\n    update: updateStyle\r\n};\n\nconst whitespaceRE = /\\s+/;\r\n/**\r\n * Add class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction addClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (!cls || !(cls = cls.trim())) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (el.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(whitespaceRE).forEach(c => el.classList.add(c));\r\n        }\r\n        else {\r\n            el.classList.add(cls);\r\n        }\r\n    }\r\n    else {\r\n        const cur = ` ${el.getAttribute('class') || ''} `;\r\n        if (cur.indexOf(' ' + cls + ' ') < 0) {\r\n            el.setAttribute('class', (cur + cls).trim());\r\n        }\r\n    }\r\n}\r\n/**\r\n * Remove class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction removeClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (!cls || !(cls = cls.trim())) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (el.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(whitespaceRE).forEach(c => el.classList.remove(c));\r\n        }\r\n        else {\r\n            el.classList.remove(cls);\r\n        }\r\n        if (!el.classList.length) {\r\n            el.removeAttribute('class');\r\n        }\r\n    }\r\n    else {\r\n        let cur = ` ${el.getAttribute('class') || ''} `;\r\n        const tar = ' ' + cls + ' ';\r\n        while (cur.indexOf(tar) >= 0) {\r\n            cur = cur.replace(tar, ' ');\r\n        }\r\n        cur = cur.trim();\r\n        if (cur) {\r\n            el.setAttribute('class', cur);\r\n        }\r\n        else {\r\n            el.removeAttribute('class');\r\n        }\r\n    }\r\n}\n\nfunction resolveTransition(def) {\r\n    if (!def) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (typeof def === 'object') {\r\n        const res = {};\r\n        if (def.css !== false) {\r\n            extend(res, autoCssTransition(def.name || 'v'));\r\n        }\r\n        extend(res, def);\r\n        return res;\r\n    }\r\n    else if (typeof def === 'string') {\r\n        return autoCssTransition(def);\r\n    }\r\n}\r\nconst autoCssTransition = cached(name => {\r\n    return {\r\n        enterClass: `${name}-enter`,\r\n        enterToClass: `${name}-enter-to`,\r\n        enterActiveClass: `${name}-enter-active`,\r\n        leaveClass: `${name}-leave`,\r\n        leaveToClass: `${name}-leave-to`,\r\n        leaveActiveClass: `${name}-leave-active`\r\n    };\r\n});\r\nconst hasTransition = inBrowser && !isIE9;\r\nconst TRANSITION = 'transition';\r\nconst ANIMATION = 'animation';\r\n// Transition property/event sniffing\r\nlet transitionProp = 'transition';\r\nlet transitionEndEvent = 'transitionend';\r\nlet animationProp = 'animation';\r\nlet animationEndEvent = 'animationend';\r\nif (hasTransition) {\r\n    /* istanbul ignore if */\r\n    if (window.ontransitionend === undefined &&\r\n        window.onwebkittransitionend !== undefined) {\r\n        transitionProp = 'WebkitTransition';\r\n        transitionEndEvent = 'webkitTransitionEnd';\r\n    }\r\n    if (window.onanimationend === undefined &&\r\n        window.onwebkitanimationend !== undefined) {\r\n        animationProp = 'WebkitAnimation';\r\n        animationEndEvent = 'webkitAnimationEnd';\r\n    }\r\n}\r\n// binding to window is necessary to make hot reload work in IE in strict mode\r\nconst raf = inBrowser\r\n    ? window.requestAnimationFrame\r\n        ? window.requestAnimationFrame.bind(window)\r\n        : setTimeout\r\n    : /* istanbul ignore next */ /* istanbul ignore next */ fn => fn();\r\nfunction nextFrame(fn) {\r\n    raf(() => {\r\n        // @ts-expect-error\r\n        raf(fn);\r\n    });\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    const transitionClasses = el._transitionClasses || (el._transitionClasses = []);\r\n    if (transitionClasses.indexOf(cls) < 0) {\r\n        transitionClasses.push(cls);\r\n        addClass(el, cls);\r\n    }\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    if (el._transitionClasses) {\r\n        remove$2(el._transitionClasses, cls);\r\n    }\r\n    removeClass(el, cls);\r\n}\r\nfunction whenTransitionEnds(el, expectedType, cb) {\r\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\r\n    if (!type)\r\n        return cb();\r\n    const event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\r\n    let ended = 0;\r\n    const end = () => {\r\n        el.removeEventListener(event, onEnd);\r\n        cb();\r\n    };\r\n    const onEnd = e => {\r\n        if (e.target === el) {\r\n            if (++ended >= propCount) {\r\n                end();\r\n            }\r\n        }\r\n    };\r\n    setTimeout(() => {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(event, onEnd);\r\n}\r\nconst transformRE = /\\b(transform|all)(,|$)/;\r\nfunction getTransitionInfo(el, expectedType) {\r\n    const styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    const transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\r\n    const transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\r\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    const animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\r\n    const animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\r\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    let type;\r\n    let timeout = 0;\r\n    let propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    const hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\r\n    return {\r\n        type,\r\n        timeout,\r\n        propCount,\r\n        hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    /* istanbul ignore next */\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max.apply(null, durations.map((d, i) => {\r\n        return toMs(d) + toMs(delays[i]);\r\n    }));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\r\n// in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\r\n// as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\r\n}\n\nfunction enter(vnode, toggleDisplay) {\r\n    const el = vnode.elm;\r\n    // call leave callback now\r\n    if (isDef(el._leaveCb)) {\r\n        el._leaveCb.cancelled = true;\r\n        el._leaveCb();\r\n    }\r\n    const data = resolveTransition(vnode.data.transition);\r\n    if (isUndef(data)) {\r\n        return;\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\r\n        return;\r\n    }\r\n    const { css, type, enterClass, enterToClass, enterActiveClass, appearClass, appearToClass, appearActiveClass, beforeEnter, enter, afterEnter, enterCancelled, beforeAppear, appear, afterAppear, appearCancelled, duration } = data;\r\n    // activeInstance will always be the <transition> component managing this\r\n    // transition. One edge case to check is when the <transition> is placed\r\n    // as the root node of a child component. In that case we need to check\r\n    // <transition>'s parent for appear check.\r\n    let context = activeInstance;\r\n    let transitionNode = activeInstance.$vnode;\r\n    while (transitionNode && transitionNode.parent) {\r\n        context = transitionNode.context;\r\n        transitionNode = transitionNode.parent;\r\n    }\r\n    const isAppear = !context._isMounted || !vnode.isRootInsert;\r\n    if (isAppear && !appear && appear !== '') {\r\n        return;\r\n    }\r\n    const startClass = isAppear && appearClass ? appearClass : enterClass;\r\n    const activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\r\n    const toClass = isAppear && appearToClass ? appearToClass : enterToClass;\r\n    const beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\r\n    const enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;\r\n    const afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\r\n    const enterCancelledHook = isAppear\r\n        ? appearCancelled || enterCancelled\r\n        : enterCancelled;\r\n    const explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\r\n    if (explicitEnterDuration != null) {\r\n        checkDuration(explicitEnterDuration, 'enter', vnode);\r\n    }\r\n    const expectsCSS = css !== false && !isIE9;\r\n    const userWantsControl = getHookArgumentsLength(enterHook);\r\n    const cb = (el._enterCb = once(() => {\r\n        if (expectsCSS) {\r\n            removeTransitionClass(el, toClass);\r\n            removeTransitionClass(el, activeClass);\r\n        }\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            if (expectsCSS) {\r\n                removeTransitionClass(el, startClass);\r\n            }\r\n            enterCancelledHook && enterCancelledHook(el);\r\n        }\r\n        else {\r\n            afterEnterHook && afterEnterHook(el);\r\n        }\r\n        el._enterCb = null;\r\n    }));\r\n    if (!vnode.data.show) {\r\n        // remove pending leave element on enter by injecting an insert hook\r\n        mergeVNodeHook(vnode, 'insert', () => {\r\n            const parent = el.parentNode;\r\n            const pendingNode = parent && parent._pending && parent._pending[vnode.key];\r\n            if (pendingNode &&\r\n                pendingNode.tag === vnode.tag &&\r\n                pendingNode.elm._leaveCb) {\r\n                pendingNode.elm._leaveCb();\r\n            }\r\n            enterHook && enterHook(el, cb);\r\n        });\r\n    }\r\n    // start enter transition\r\n    beforeEnterHook && beforeEnterHook(el);\r\n    if (expectsCSS) {\r\n        addTransitionClass(el, startClass);\r\n        addTransitionClass(el, activeClass);\r\n        nextFrame(() => {\r\n            removeTransitionClass(el, startClass);\r\n            // @ts-expect-error\r\n            if (!cb.cancelled) {\r\n                addTransitionClass(el, toClass);\r\n                if (!userWantsControl) {\r\n                    if (isValidDuration(explicitEnterDuration)) {\r\n                        setTimeout(cb, explicitEnterDuration);\r\n                    }\r\n                    else {\r\n                        whenTransitionEnds(el, type, cb);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (vnode.data.show) {\r\n        toggleDisplay && toggleDisplay();\r\n        enterHook && enterHook(el, cb);\r\n    }\r\n    if (!expectsCSS && !userWantsControl) {\r\n        cb();\r\n    }\r\n}\r\nfunction leave(vnode, rm) {\r\n    const el = vnode.elm;\r\n    // call enter callback now\r\n    if (isDef(el._enterCb)) {\r\n        el._enterCb.cancelled = true;\r\n        el._enterCb();\r\n    }\r\n    const data = resolveTransition(vnode.data.transition);\r\n    if (isUndef(data) || el.nodeType !== 1) {\r\n        return rm();\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isDef(el._leaveCb)) {\r\n        return;\r\n    }\r\n    const { css, type, leaveClass, leaveToClass, leaveActiveClass, beforeLeave, leave, afterLeave, leaveCancelled, delayLeave, duration } = data;\r\n    const expectsCSS = css !== false && !isIE9;\r\n    const userWantsControl = getHookArgumentsLength(leave);\r\n    const explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\r\n    if (isDef(explicitLeaveDuration)) {\r\n        checkDuration(explicitLeaveDuration, 'leave', vnode);\r\n    }\r\n    const cb = (el._leaveCb = once(() => {\r\n        if (el.parentNode && el.parentNode._pending) {\r\n            el.parentNode._pending[vnode.key] = null;\r\n        }\r\n        if (expectsCSS) {\r\n            removeTransitionClass(el, leaveToClass);\r\n            removeTransitionClass(el, leaveActiveClass);\r\n        }\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            if (expectsCSS) {\r\n                removeTransitionClass(el, leaveClass);\r\n            }\r\n            leaveCancelled && leaveCancelled(el);\r\n        }\r\n        else {\r\n            rm();\r\n            afterLeave && afterLeave(el);\r\n        }\r\n        el._leaveCb = null;\r\n    }));\r\n    if (delayLeave) {\r\n        delayLeave(performLeave);\r\n    }\r\n    else {\r\n        performLeave();\r\n    }\r\n    function performLeave() {\r\n        // the delayed leave may have already been cancelled\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            return;\r\n        }\r\n        // record leaving element\r\n        if (!vnode.data.show && el.parentNode) {\r\n            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =\r\n                vnode;\r\n        }\r\n        beforeLeave && beforeLeave(el);\r\n        if (expectsCSS) {\r\n            addTransitionClass(el, leaveClass);\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, leaveClass);\r\n                // @ts-expect-error\r\n                if (!cb.cancelled) {\r\n                    addTransitionClass(el, leaveToClass);\r\n                    if (!userWantsControl) {\r\n                        if (isValidDuration(explicitLeaveDuration)) {\r\n                            setTimeout(cb, explicitLeaveDuration);\r\n                        }\r\n                        else {\r\n                            whenTransitionEnds(el, type, cb);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        leave && leave(el, cb);\r\n        if (!expectsCSS && !userWantsControl) {\r\n            cb();\r\n        }\r\n    }\r\n}\r\n// only used in dev mode\r\nfunction checkDuration(val, name, vnode) {\r\n    if (typeof val !== 'number') {\r\n        warn(`<transition> explicit ${name} duration is not a valid number - ` +\r\n            `got ${JSON.stringify(val)}.`, vnode.context);\r\n    }\r\n    else if (isNaN(val)) {\r\n        warn(`<transition> explicit ${name} duration is NaN - ` +\r\n            'the duration expression might be incorrect.', vnode.context);\r\n    }\r\n}\r\nfunction isValidDuration(val) {\r\n    return typeof val === 'number' && !isNaN(val);\r\n}\r\n/**\r\n * Normalize a transition hook's argument length. The hook may be:\r\n * - a merged hook (invoker) with the original in .fns\r\n * - a wrapped component method (check ._length)\r\n * - a plain function (.length)\r\n */\r\nfunction getHookArgumentsLength(fn) {\r\n    if (isUndef(fn)) {\r\n        return false;\r\n    }\r\n    // @ts-expect-error\r\n    const invokerFns = fn.fns;\r\n    if (isDef(invokerFns)) {\r\n        // invoker\r\n        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\r\n    }\r\n    else {\r\n        // @ts-expect-error\r\n        return (fn._length || fn.length) > 1;\r\n    }\r\n}\r\nfunction _enter(_, vnode) {\r\n    if (vnode.data.show !== true) {\r\n        enter(vnode);\r\n    }\r\n}\r\nvar transition = inBrowser\r\n    ? {\r\n        create: _enter,\r\n        activate: _enter,\r\n        remove(vnode, rm) {\r\n            /* istanbul ignore else */\r\n            if (vnode.data.show !== true) {\r\n                // @ts-expect-error\r\n                leave(vnode, rm);\r\n            }\r\n            else {\r\n                rm();\r\n            }\r\n        }\r\n    }\r\n    : {};\n\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n// the directive module should be applied last, after all\r\n// built-in modules have been applied.\r\nconst modules = platformModules.concat(baseModules);\r\nconst patch = createPatchFunction({ nodeOps, modules });\n\n/**\r\n * Not type checking this file because flow doesn't like attaching\r\n * properties to Elements.\r\n */\r\n/* istanbul ignore if */\r\nif (isIE9) {\r\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\r\n    document.addEventListener('selectionchange', () => {\r\n        const el = document.activeElement;\r\n        // @ts-expect-error\r\n        if (el && el.vmodel) {\r\n            trigger(el, 'input');\r\n        }\r\n    });\r\n}\r\nconst directive = {\r\n    inserted(el, binding, vnode, oldVnode) {\r\n        if (vnode.tag === 'select') {\r\n            // #6903\r\n            if (oldVnode.elm && !oldVnode.elm._vOptions) {\r\n                mergeVNodeHook(vnode, 'postpatch', () => {\r\n                    directive.componentUpdated(el, binding, vnode);\r\n                });\r\n            }\r\n            else {\r\n                setSelected(el, binding, vnode.context);\r\n            }\r\n            el._vOptions = [].map.call(el.options, getValue);\r\n        }\r\n        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\r\n            el._vModifiers = binding.modifiers;\r\n            if (!binding.modifiers.lazy) {\r\n                el.addEventListener('compositionstart', onCompositionStart);\r\n                el.addEventListener('compositionend', onCompositionEnd);\r\n                // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n                // switching focus before confirming composition choice\r\n                // this also fixes the issue where some browsers e.g. iOS Chrome\r\n                // fires \"change\" instead of \"input\" on autocomplete.\r\n                el.addEventListener('change', onCompositionEnd);\r\n                /* istanbul ignore if */\r\n                if (isIE9) {\r\n                    el.vmodel = true;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    componentUpdated(el, binding, vnode) {\r\n        if (vnode.tag === 'select') {\r\n            setSelected(el, binding, vnode.context);\r\n            // in case the options rendered by v-for have changed,\r\n            // it's possible that the value is out-of-sync with the rendered options.\r\n            // detect such cases and filter out values that no longer has a matching\r\n            // option in the DOM.\r\n            const prevOptions = el._vOptions;\r\n            const curOptions = (el._vOptions = [].map.call(el.options, getValue));\r\n            if (curOptions.some((o, i) => !looseEqual(o, prevOptions[i]))) {\r\n                // trigger change event if\r\n                // no matching option found for at least one value\r\n                const needReset = el.multiple\r\n                    ? binding.value.some(v => hasNoMatchingOption(v, curOptions))\r\n                    : binding.value !== binding.oldValue &&\r\n                        hasNoMatchingOption(binding.value, curOptions);\r\n                if (needReset) {\r\n                    trigger(el, 'change');\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nfunction setSelected(el, binding, vm) {\r\n    actuallySetSelected(el, binding, vm);\r\n    /* istanbul ignore if */\r\n    if (isIE || isEdge) {\r\n        setTimeout(() => {\r\n            actuallySetSelected(el, binding, vm);\r\n        }, 0);\r\n    }\r\n}\r\nfunction actuallySetSelected(el, binding, vm) {\r\n    const value = binding.value;\r\n    const isMultiple = el.multiple;\r\n    if (isMultiple && !Array.isArray(value)) {\r\n        warn(`<select multiple v-model=\"${binding.expression}\"> ` +\r\n                `expects an Array value for its binding, but got ${Object.prototype.toString\r\n                    .call(value)\r\n                    .slice(8, -1)}`, vm);\r\n        return;\r\n    }\r\n    let selected, option;\r\n    for (let i = 0, l = el.options.length; i < l; i++) {\r\n        option = el.options[i];\r\n        if (isMultiple) {\r\n            selected = looseIndexOf(value, getValue(option)) > -1;\r\n            if (option.selected !== selected) {\r\n                option.selected = selected;\r\n            }\r\n        }\r\n        else {\r\n            if (looseEqual(getValue(option), value)) {\r\n                if (el.selectedIndex !== i) {\r\n                    el.selectedIndex = i;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\nfunction hasNoMatchingOption(value, options) {\r\n    return options.every(o => !looseEqual(o, value));\r\n}\r\nfunction getValue(option) {\r\n    return '_value' in option ? option._value : option.value;\r\n}\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    // prevent triggering an input event for no reason\r\n    if (!e.target.composing)\r\n        return;\r\n    e.target.composing = false;\r\n    trigger(e.target, 'input');\r\n}\r\nfunction trigger(el, type) {\r\n    const e = document.createEvent('HTMLEvents');\r\n    e.initEvent(type, true, true);\r\n    el.dispatchEvent(e);\r\n}\n\n// recursively search for possible transition defined inside the component root\r\nfunction locateNode(vnode) {\r\n    // @ts-expect-error\r\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\r\n        ? locateNode(vnode.componentInstance._vnode)\r\n        : vnode;\r\n}\r\nvar show = {\r\n    bind(el, { value }, vnode) {\r\n        vnode = locateNode(vnode);\r\n        const transition = vnode.data && vnode.data.transition;\r\n        const originalDisplay = (el.__vOriginalDisplay =\r\n            el.style.display === 'none' ? '' : el.style.display);\r\n        if (value && transition) {\r\n            vnode.data.show = true;\r\n            enter(vnode, () => {\r\n                el.style.display = originalDisplay;\r\n            });\r\n        }\r\n        else {\r\n            el.style.display = value ? originalDisplay : 'none';\r\n        }\r\n    },\r\n    update(el, { value, oldValue }, vnode) {\r\n        /* istanbul ignore if */\r\n        if (!value === !oldValue)\r\n            return;\r\n        vnode = locateNode(vnode);\r\n        const transition = vnode.data && vnode.data.transition;\r\n        if (transition) {\r\n            vnode.data.show = true;\r\n            if (value) {\r\n                enter(vnode, () => {\r\n                    el.style.display = el.__vOriginalDisplay;\r\n                });\r\n            }\r\n            else {\r\n                leave(vnode, () => {\r\n                    el.style.display = 'none';\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            el.style.display = value ? el.__vOriginalDisplay : 'none';\r\n        }\r\n    },\r\n    unbind(el, binding, vnode, oldVnode, isDestroy) {\r\n        if (!isDestroy) {\r\n            el.style.display = el.__vOriginalDisplay;\r\n        }\r\n    }\r\n};\n\nvar platformDirectives = {\r\n    model: directive,\r\n    show\r\n};\n\n// Provides transition support for a single element/component.\r\nconst transitionProps = {\r\n    name: String,\r\n    appear: Boolean,\r\n    css: Boolean,\r\n    mode: String,\r\n    type: String,\r\n    enterClass: String,\r\n    leaveClass: String,\r\n    enterToClass: String,\r\n    leaveToClass: String,\r\n    enterActiveClass: String,\r\n    leaveActiveClass: String,\r\n    appearClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    duration: [Number, String, Object]\r\n};\r\n// in case the child is also an abstract component, e.g. <keep-alive>\r\n// we want to recursively retrieve the real component to be rendered\r\nfunction getRealChild(vnode) {\r\n    const compOptions = vnode && vnode.componentOptions;\r\n    if (compOptions && compOptions.Ctor.options.abstract) {\r\n        return getRealChild(getFirstComponentChild(compOptions.children));\r\n    }\r\n    else {\r\n        return vnode;\r\n    }\r\n}\r\nfunction extractTransitionData(comp) {\r\n    const data = {};\r\n    const options = comp.$options;\r\n    // props\r\n    for (const key in options.propsData) {\r\n        data[key] = comp[key];\r\n    }\r\n    // events.\r\n    // extract listeners and pass them directly to the transition methods\r\n    const listeners = options._parentListeners;\r\n    for (const key in listeners) {\r\n        data[camelize(key)] = listeners[key];\r\n    }\r\n    return data;\r\n}\r\nfunction placeholder(h, rawChild) {\r\n    // @ts-expect-error\r\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\r\n        return h('keep-alive', {\r\n            props: rawChild.componentOptions.propsData\r\n        });\r\n    }\r\n}\r\nfunction hasParentTransition(vnode) {\r\n    while ((vnode = vnode.parent)) {\r\n        if (vnode.data.transition) {\r\n            return true;\r\n        }\r\n    }\r\n}\r\nfunction isSameChild(child, oldChild) {\r\n    return oldChild.key === child.key && oldChild.tag === child.tag;\r\n}\r\nconst isNotTextNode = (c) => c.tag || isAsyncPlaceholder(c);\r\nconst isVShowDirective = d => d.name === 'show';\r\nvar Transition = {\r\n    name: 'transition',\r\n    props: transitionProps,\r\n    abstract: true,\r\n    render(h) {\r\n        let children = this.$slots.default;\r\n        if (!children) {\r\n            return;\r\n        }\r\n        // filter out text nodes (possible whitespaces)\r\n        children = children.filter(isNotTextNode);\r\n        /* istanbul ignore if */\r\n        if (!children.length) {\r\n            return;\r\n        }\r\n        // warn multiple elements\r\n        if (children.length > 1) {\r\n            warn('<transition> can only be used on a single element. Use ' +\r\n                '<transition-group> for lists.', this.$parent);\r\n        }\r\n        const mode = this.mode;\r\n        // warn invalid mode\r\n        if (mode && mode !== 'in-out' && mode !== 'out-in') {\r\n            warn('invalid <transition> mode: ' + mode, this.$parent);\r\n        }\r\n        const rawChild = children[0];\r\n        // if this is a component root node and the component's\r\n        // parent container node also has transition, skip.\r\n        if (hasParentTransition(this.$vnode)) {\r\n            return rawChild;\r\n        }\r\n        // apply transition data to child\r\n        // use getRealChild() to ignore abstract components e.g. keep-alive\r\n        const child = getRealChild(rawChild);\r\n        /* istanbul ignore if */\r\n        if (!child) {\r\n            return rawChild;\r\n        }\r\n        if (this._leaving) {\r\n            return placeholder(h, rawChild);\r\n        }\r\n        // ensure a key that is unique to the vnode type and to this transition\r\n        // component instance. This key will be used to remove pending leaving nodes\r\n        // during entering.\r\n        const id = `__transition-${this._uid}-`;\r\n        child.key =\r\n            child.key == null\r\n                ? child.isComment\r\n                    ? id + 'comment'\r\n                    : id + child.tag\r\n                : isPrimitive(child.key)\r\n                    ? String(child.key).indexOf(id) === 0\r\n                        ? child.key\r\n                        : id + child.key\r\n                    : child.key;\r\n        const data = ((child.data || (child.data = {})).transition =\r\n            extractTransitionData(this));\r\n        const oldRawChild = this._vnode;\r\n        const oldChild = getRealChild(oldRawChild);\r\n        // mark v-show\r\n        // so that the transition module can hand over the control to the directive\r\n        if (child.data.directives && child.data.directives.some(isVShowDirective)) {\r\n            child.data.show = true;\r\n        }\r\n        if (oldChild &&\r\n            oldChild.data &&\r\n            !isSameChild(child, oldChild) &&\r\n            !isAsyncPlaceholder(oldChild) &&\r\n            // #6687 component root is a comment node\r\n            !(oldChild.componentInstance &&\r\n                oldChild.componentInstance._vnode.isComment)) {\r\n            // replace old child transition data with fresh one\r\n            // important for dynamic transitions!\r\n            const oldData = (oldChild.data.transition = extend({}, data));\r\n            // handle transition mode\r\n            if (mode === 'out-in') {\r\n                // return placeholder node and queue update when leave finishes\r\n                this._leaving = true;\r\n                mergeVNodeHook(oldData, 'afterLeave', () => {\r\n                    this._leaving = false;\r\n                    this.$forceUpdate();\r\n                });\r\n                return placeholder(h, rawChild);\r\n            }\r\n            else if (mode === 'in-out') {\r\n                if (isAsyncPlaceholder(child)) {\r\n                    return oldRawChild;\r\n                }\r\n                let delayedLeave;\r\n                const performLeave = () => {\r\n                    delayedLeave();\r\n                };\r\n                mergeVNodeHook(data, 'afterEnter', performLeave);\r\n                mergeVNodeHook(data, 'enterCancelled', performLeave);\r\n                mergeVNodeHook(oldData, 'delayLeave', leave => {\r\n                    delayedLeave = leave;\r\n                });\r\n            }\r\n        }\r\n        return rawChild;\r\n    }\r\n};\n\n// Provides transition support for list items.\r\nconst props = extend({\r\n    tag: String,\r\n    moveClass: String\r\n}, transitionProps);\r\ndelete props.mode;\r\nvar TransitionGroup = {\r\n    props,\r\n    beforeMount() {\r\n        const update = this._update;\r\n        this._update = (vnode, hydrating) => {\r\n            const restoreActiveInstance = setActiveInstance(this);\r\n            // force removing pass\r\n            this.__patch__(this._vnode, this.kept, false, // hydrating\r\n            true // removeOnly (!important, avoids unnecessary moves)\r\n            );\r\n            this._vnode = this.kept;\r\n            restoreActiveInstance();\r\n            update.call(this, vnode, hydrating);\r\n        };\r\n    },\r\n    render(h) {\r\n        const tag = this.tag || this.$vnode.data.tag || 'span';\r\n        const map = Object.create(null);\r\n        const prevChildren = (this.prevChildren = this.children);\r\n        const rawChildren = this.$slots.default || [];\r\n        const children = (this.children = []);\r\n        const transitionData = extractTransitionData(this);\r\n        for (let i = 0; i < rawChildren.length; i++) {\r\n            const c = rawChildren[i];\r\n            if (c.tag) {\r\n                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\r\n                    children.push(c);\r\n                    map[c.key] = c;\r\n                    (c.data || (c.data = {})).transition = transitionData;\r\n                }\r\n                else {\r\n                    const opts = c.componentOptions;\r\n                    const name = opts\r\n                        ? getComponentName(opts.Ctor.options) || opts.tag || ''\r\n                        : c.tag;\r\n                    warn(`<transition-group> children must be keyed: <${name}>`);\r\n                }\r\n            }\r\n        }\r\n        if (prevChildren) {\r\n            const kept = [];\r\n            const removed = [];\r\n            for (let i = 0; i < prevChildren.length; i++) {\r\n                const c = prevChildren[i];\r\n                c.data.transition = transitionData;\r\n                // @ts-expect-error .getBoundingClientRect is not typed in Node\r\n                c.data.pos = c.elm.getBoundingClientRect();\r\n                if (map[c.key]) {\r\n                    kept.push(c);\r\n                }\r\n                else {\r\n                    removed.push(c);\r\n                }\r\n            }\r\n            this.kept = h(tag, null, kept);\r\n            this.removed = removed;\r\n        }\r\n        return h(tag, null, children);\r\n    },\r\n    updated() {\r\n        const children = this.prevChildren;\r\n        const moveClass = this.moveClass || (this.name || 'v') + '-move';\r\n        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\r\n            return;\r\n        }\r\n        // we divide the work into three loops to avoid mixing DOM reads and writes\r\n        // in each iteration - which helps prevent layout thrashing.\r\n        children.forEach(callPendingCbs);\r\n        children.forEach(recordPosition);\r\n        children.forEach(applyTranslation);\r\n        // force reflow to put everything in position\r\n        // assign to this to avoid being removed in tree-shaking\r\n        // $flow-disable-line\r\n        this._reflow = document.body.offsetHeight;\r\n        children.forEach((c) => {\r\n            if (c.data.moved) {\r\n                const el = c.elm;\r\n                const s = el.style;\r\n                addTransitionClass(el, moveClass);\r\n                s.transform = s.WebkitTransform = s.transitionDuration = '';\r\n                el.addEventListener(transitionEndEvent, (el._moveCb = function cb(e) {\r\n                    if (e && e.target !== el) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el.removeEventListener(transitionEndEvent, cb);\r\n                        el._moveCb = null;\r\n                        removeTransitionClass(el, moveClass);\r\n                    }\r\n                }));\r\n            }\r\n        });\r\n    },\r\n    methods: {\r\n        hasMove(el, moveClass) {\r\n            /* istanbul ignore if */\r\n            if (!hasTransition) {\r\n                return false;\r\n            }\r\n            /* istanbul ignore if */\r\n            if (this._hasMove) {\r\n                return this._hasMove;\r\n            }\r\n            // Detect whether an element with the move class applied has\r\n            // CSS transitions. Since the element may be inside an entering\r\n            // transition at this very moment, we make a clone of it and remove\r\n            // all other transition classes applied to ensure only the move class\r\n            // is applied.\r\n            const clone = el.cloneNode();\r\n            if (el._transitionClasses) {\r\n                el._transitionClasses.forEach((cls) => {\r\n                    removeClass(clone, cls);\r\n                });\r\n            }\r\n            addClass(clone, moveClass);\r\n            clone.style.display = 'none';\r\n            this.$el.appendChild(clone);\r\n            const info = getTransitionInfo(clone);\r\n            this.$el.removeChild(clone);\r\n            return (this._hasMove = info.hasTransform);\r\n        }\r\n    }\r\n};\r\nfunction callPendingCbs(c) {\r\n    /* istanbul ignore if */\r\n    if (c.elm._moveCb) {\r\n        c.elm._moveCb();\r\n    }\r\n    /* istanbul ignore if */\r\n    if (c.elm._enterCb) {\r\n        c.elm._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    c.data.newPos = c.elm.getBoundingClientRect();\r\n}\r\nfunction applyTranslation(c) {\r\n    const oldPos = c.data.pos;\r\n    const newPos = c.data.newPos;\r\n    const dx = oldPos.left - newPos.left;\r\n    const dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        c.data.moved = true;\r\n        const s = c.elm.style;\r\n        s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`;\r\n        s.transitionDuration = '0s';\r\n    }\r\n}\n\nvar platformComponents = {\r\n    Transition,\r\n    TransitionGroup\r\n};\n\n// install platform specific utils\r\nVue.config.mustUseProp = mustUseProp;\r\nVue.config.isReservedTag = isReservedTag;\r\nVue.config.isReservedAttr = isReservedAttr;\r\nVue.config.getTagNamespace = getTagNamespace;\r\nVue.config.isUnknownElement = isUnknownElement;\r\n// install platform runtime directives & components\r\nextend(Vue.options.directives, platformDirectives);\r\nextend(Vue.options.components, platformComponents);\r\n// install platform patch function\r\nVue.prototype.__patch__ = inBrowser ? patch : noop;\r\n// public mount method\r\nVue.prototype.$mount = function (el, hydrating) {\r\n    el = el && inBrowser ? query(el) : undefined;\r\n    return mountComponent(this, el, hydrating);\r\n};\r\n// devtools global hook\r\n/* istanbul ignore next */\r\nif (inBrowser) {\r\n    setTimeout(() => {\r\n        if (config.devtools) {\r\n            if (devtools) {\r\n                devtools.emit('init', Vue);\r\n            }\r\n            else {\r\n                // @ts-expect-error\r\n                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' +\r\n                    'https://github.com/vuejs/vue-devtools');\r\n            }\r\n        }\r\n        if (config.productionTip !== false &&\r\n            typeof console !== 'undefined') {\r\n            // @ts-expect-error\r\n            console[console.info ? 'info' : 'log'](`You are running Vue in development mode.\\n` +\r\n                `Make sure to turn on production mode when deploying for production.\\n` +\r\n                `See more tips at https://vuejs.org/guide/deployment.html`);\r\n        }\r\n    }, 0);\r\n}\n\nextend(Vue, vca);\n\nmodule.exports = Vue;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}